# Программирование на языке Python (Лекция 5)

[Часть 2](#part2)

## Кодировки символов: ANSI, UTF-8, UNICODE.
Прежде чем разбираться с кодировкой символов разберемся как компьютер вообще хранит информацию.

У нас 10 пальцев, и система — десятичная. То есть, любое, сколь угодно большое число мы можем представить с помощью цифр 0, 1, 2, 3, 4, 5, 6, 7, 8, 9. В зависимости от того, где в числе стоит цифра, она может означать разное: если эта цифра последняя, то она расположена в разряде единиц, предпоследняя — разряд десятков, еще левее — разряд сотен и так далее. По сути, любое число можно расписать в виде суммы цифр, каждая из которых умножена на десять в определенной степени. В случае единиц, эта степень — нулевая.

Например,

1573 = 3\*10<sup>0</sup> + 7\*10<sup>1</sup> + 5\*10<sup>2</sup> + 1\*10<sup>3</sup>

Число, на степень которого умножаются цифры называется базой системы счисления. Для десятичной системы базой, логично, является десятка.

У компьютера пальцев нет, но есть два состояния: условно «ток идет» и «ток не идет», нулик и единичка. Соответственно все числа (да и вообще информация) в памяти компьютера состоят только из двух цифр — 0 и 1. Их расположение, как и в случае десятичной системы счисления, указывает на разряд. Только теперь число можно разложить на сумму цифр, помноженных не на степени десятки, а степени двойки.

0 в двоичной системе = 0</br>
1 в двоичной системе = 1</br> 
2 в двоичной системе = 10</br>
7<sub>10</sub>=111<sub>2</sub></br>

Научитесь переводить из двоичной системы в десятичую. Вы, наверное, уже поняли, как это делается — просто берем цифру числа начиная с самой правой и умножаем её на базу системы счисления в степени, соответствующей её разряду, так с каждым разрядом. Затем складываем все получившиеся таким образом числа.

Пример:

Давайте найдем десятичный аналог двоичного числа 101101<sub>2</sub>

Самая правая единичка = 1\*2<sup>0</sup></br>
Следующий нулик = 0\*2<sup>1</sup></br>
Третья справа единичка = 1\*2<sup>2</sup></br>
Четвертая = 1\*2<sup>3</sup></br>
… и так далее</br>

101101<sub>2</sub> = 1\*2<sup>0</sup> + 0\*2<sup>1</sup> + 1\*2<sup>2</sup> + 1\*2<sup>3</sup> + 0\*2<sup>4</sup> + 1\*2<sup>5</sup> = 1 + 0 + 4 + 8 + 0 + 32 = 45<sub>10</sub>

### Перевод из десятичной системы в двоичную
Тут тоже всё просто, если понимать суть.

Пример:

У нас есть десятичное число 57<sub>10</sub>. Чтобы перевести его в двоичную систему, нужно определить, какая максимальная степень двойки не превосходит это число.

2<sup>6</sup> = 64.  
Это явно многовато.  
А вот 2<sup>5</sup> = 32.  

Мы определили старший разряд. 32<sub>10</sub> = 100000<sub>2</sub>.  
Теперь ищем следующий разряд. 57-32 = 25.  
Теперь для 25 ищем степень двойки, которая не превосходит 25.  
2<sup>4</sup> = 16.  
Значит, следующий разряд у нас тоже равен "1".  
32+16 = 48<sub>10</sub> = 110000<sub>2</sub>.  
57 – 48 = 9.  
2<sup>3</sup> = 8, это больше, чем 9. Значит следующий разряд тоже будет единичкой.

32 + 16 + 8 = 56<sub>10</sub> = 111000<sub>2</sub>.  
57 - 56 = 1, то есть осталась только одна степень 2<sup>0</sup>.  
Таким образом, 57<sub>10</sub> = 111001<sub>2</sub>.

### ASCII
Мы выяснили, что компьютер понимает только нулики и единички, а его память можно представить в виде очень длинной строки из лампочек с выключателями. Как представить цифры в компьютере мы уже поняли. А что делать с остальной информацией? Буквами, картинками?

Скажем, в английском алфавите 26 букв. Теоретически мы можем представить буквы цифрами от 0 до 25, только в двоичной системе. Возникает другой вопрос: а как понять, перед нами строчная буква или прописная? А знаки препинания? Что делать со знаками-«невидимками», вроде пробела? Словом, нужна система кодирования.

В 1960-х годах существовало множество разных схем, кодирующих символы. Отсутствие единообразия довольно быстро переросло в серьёзную проблему, и уже в 1963 году Американский институт стандартизации ANSI разработал и ввел в обиход схему кодировки ASCII (American Standard Code for Information Interchange). 

Каждый символ ASCII состоит из семи разрядов или семи бит, каждый из которых может принимать значение 0 или 1. В 7 бит можно поместить числа от 0 до 127 в двоичной системе, то есть у нас есть 128 чисел для кодирования символов. Казалось бы, достаточно для кодировки письменной английской речи? 

Давайте прикинем: 

a-z — 26 вариантов  
A-Z — еще 26  
0-9 — 10  
,;:~& и прочие знаки пунктуации — 32  
Ещё нам нужен пробел.  
Итого — 95 символов.  

Оставшиеся 33 (128 - 95) вакантных варианта используют для так называемых управляющих символов, вроде перевода строки или возврата каретки.

Важно различать символы "0"-"9" и числовые значения 0-9.
Символы "0"-"9" представлены значениями ASCII 48-57 (0x30-0x39).

Интересно отметить, что крайние правые четыре бита этих значений ASCII представляют собой двоичные представления числовых значений 0-9. Это несколько упрощает способ преобразования между значениями ASCII и их фактическими числовыми значениями (в шестнадцатиричном виде это особенно заметно).

С появлением восьмибитной кодировки, в ASCII смогли закодировать и другие алфавиты. Расширенных кодировок ASCII много - существуют версии для многих национальных алфавитов. При этом первая половина кодировки (значения от нуля до 127) везде одинаковая.

Русский алфавит (кириллица) закодирован в кодировке с названием windows-1251 (Это актуальная кодировка для Windows, но и до неё существовало несколько кодировок. Наиболее распространены были CP866 и КОИ-8r, вы вполне можете с ними столкнуться при работе со старым "железом" или сайтами).


### Кодировка Юникод (Unicode)
Один байт может иметь только 256 значений. Это значит, что в кодировке ASCII можно закодировать 256 символов: цифр, букв, пиктограмм, знаков пунктуации и других различных символов. В то же время существуют письменности, в которых гораздо больше символов, например, китайские или японские иероглифы.

Для решения этой (и некоторых других) проблемы в начале девяностых была создана кодировка Юникод(Unicode). Первоначально все символы юникода занимали два байта. Соответственно, в unicode можно было закодировать 2<sup>16</sup> = 65536 значений. Затем кодовое пространство было расширено до более чем миллиона символов. В результате этого появилось несколько представлений юникода.

Наиболее популярными представлениями юникода являются два: **UTF-8** - используется в интернете и **UTF-16** - используется в Windows (начиная с Windows XP).

Существует две версии UTF-16: UTF-16LE (little-endian) - кодировка с обратным порядком байтов и UTF-16BE (big-endian) - кодировка с прямым порядком байтов. В Windows используется UTF16-LE.

Код символов в юникоде обозначается так: U+hhhh (четыре шестнадцатеричных цифры,h - от hexadecimal - шестнадцатеричный). Например, U+221A - символ квадратного корня - √.

Часть символов в UTF-16 кодируются двумя байтами (первые 63 тысячи). Остальные символы кодируются суррогатными парами. 

В **UTF-8** первые 128 символов кодируются одним байтом. Остальные символы могут кодироваться несколькими байтами (от двух до четырёх). Именно поэтому длина строки в юникоде не равна длине буфера, который эта строка занимает. Это нужно учитывать при обмене данными.

И ещё один момент (самый важный): в юникод закодированы все символы всех современных и многих мёртвых письменностей плюс знаки из различных областей науки и культуры (математические и экономически символы, нотные знаки и многое другое). Именно по этой причине и нужно использовать юникод.

### Кодирование текста в Microsoft Windows (начиная с Windows XP)
В современных версиях Windows существует два способа представления текста: UTF-16 и кодовые страницы (в основном это восьмибитные кодировки). Основной способ - юникод. Кодовые страницы нужны для совместимости со старыми приложениями (в Windows 95, Windows 98 - в основном использовалась ASCII). Кроме того, юникод не понимает одна очень важная программа - консоль.

Пусть вас не смущает новый термин - кодовая страница (code page). В windows так называются все кодировки (character sets или encodings). Т.е. понятие кодировка равнозначно кодовой странице.

Сразу сделаю замечание, которое лучше запомнить. В Windows есть чёткое разделение: вот юникод (UTF-16LE), а вот все остальные кодировки. И юникод, и остальные кодировки в Windows называются кодовыми страницами, но этот термин (кодовые страницы) я буду применять ко всем кодировкам за исключением юникода.

Напомню, что в Питоне используется кодировка UTF-8.

>Ниже мы подробно рассмотрим работу со сложными типами.
В тексте могут быть описаны не все методы, т.к. язык постоянно развивается и в следующих версиях могут добавиться новые методы.
>
>В редакторе, поддерживающем технологию IntelliSenese, Вы в любое время можете посмотреть какие методы реализует объект. Достаточно поставить точку после названия объекта и нажать комбинацию клавиш \<ctrl>+<пробел>. А, чтобы узнать параметры метода, достаточно навести на него курсор мышки.

## Работа со списками.
Список - **изменяемая** коллекция объектов произвольных типов.

Создать список можно несколькими способами. Например, можно обработать любой итерируемый объект (например, строку) встроенной функцией **list**:
```python
>>>my_list = list("список")
['с', 'п', 'и', 'с', 'о', 'к']
```

Список можно создать и при помощи литерала **[]**:
```python
list_1 = []  # Пустой список
list_2 = ['s', 'p', ['isok'], 2]
```

Еще один способ создать список - это **генераторы** списков. Генератор списков - способ построить новый список, применяя выражение к каждому элементу последовательности. Генераторы списков очень похожи на цикл for:
```python
list_3 = [c * 3 for c in 'list']
```

Генератор расшифровывается просто: выполнить операцию (выражение до ключевого слова for) для каждого элемента итерируемого объекта и поместить результат в список. Причем сам элемент можно и не использовать, помните как мы получали с клавиатуры несколько значений:
```python
list_4 = [input('введите число: ') for _ in range(5)]
```

Возможна и более сложная конструкция генератора списков:
```python
# обрабатывать элемент с условием (не равен 'i')
c = [c * 3 for c in 'list' if c != 'i']
['lll', 'sss', 'ttt']

# вложенный цикл
c = [c + d for c in 'list' if c != 'i' for d in 'spam' if d != 'a']
['ls', 'lp', 'lm', 'ss', 'sp', 'sm', 'ts', 'tp', 'tm']
```

## Функции и методы списков
Рассмотрим на примере списка a = [1,2,3]
* list.append( element ) - добавляет элемент в конец списка  
    ``a.append(4) #a=[1,2,3,4]``
* list.extend( other_list )	- расширяет список list, добавляя в конец все элементы списка other_list  
    ``a.extent([5,5,6]) #a=[1,2,3,4,5,5,6]``
* list.insert(i, x)	- вставляет на i-ый элемент значение x  
    ``a.insert(0, 0) #a=[0,1,2,3,4,5,5,6]``
* list.remove(x) - Удаляет первый элемент в списке, имеющий значение x.</br> Выдаст исключение ValueError, если такого элемента не существует  
    ``a.remove(6) #a=[0,1,2,3,4,5,5]``
* list.pop([i]) - Удаляет i-ый элемент и возвращает его. Если индекс не указан, удаляется последний элемент (квадратные скобки тут обозначают не массив, а опциональность параметра)  
    ``b = a.pop(5); #b=5, a=[0,1,2,3,4,5]``
* list.index(x, [start [, end]]) - Возвращает положение первого элемента со значением x (при этом поиск может вестись от start до end)  
    ``i = a.index(2) #i=2``
* list.count(x) -	Возвращает количество элементов со значением x
* list.sort(key=None, reverse=False) -> None  
    ``-> None`` означает, что функция ничего не возвращает, она меняет сам список (тип результата появился в Python 3)</br>
    По-умолчанию (если не указан ни один параметр) сортирует по алфавиту, а также от меньшего значения к большему, например:
```python
a = ['cc','a','bbb']
a.sort()
['a','bbb','cc']
```

Можно поменять порядок сортировки, указав reverse=True:
```python
a = ['cc','a','bbb']
a.sort(reverse=True)
['cc','bbb','a']
```

С помощью параметра *key* можно поменять принцип сортировки, например, не по алфавиту, а по длине строки:
```python
#Создаем "внешнюю" функцию, которая будет возвращать длину строки
def sortByLength(inputStr):
    return len(inputStr)

a = ['cc','a','bbb']
a.sort(key=sortByLength)
['a','cc','bbb']
```
т.е. при сортировке сравниваются не элементы, а результаты функции sortByLength в которую каждый элемент передается при сортировке (возможно вместо написания новой функции можно было сразу указать ``key=len``, но принцип понятен).

В Python 2 вместо параметра *key* был параметр *cmp*, которому тоже присваивалась функция, но в отличии от нового варианта, где решение *больше, меньше* принимет метод sort, там решение принимала функция.

Функция, принимает аргументами два стоящих рядом элемента, и должна вернуть отрицательное число (если первый меньше второго), нуль (если равны) и положительное (если первый больше второго).
```python
#Создаем "внешнюю" функцию, которая будет "говорить" что все элементы одинаковые
def my_sort(inputStr):
    return 0

a = ['cc','a','bbb']
a.sort(cmp=my_sort)
['cc','a','bbb']
```

Хоть в Python 3 она больше и не используется, но знать о ней нужно, чтобы понимать старый код.

В Python 2.6 и в более ранних версиях способ упорядочения основан на именах типов, вовлеченных в операцию сравнения, например любые целые числа всегда меньше любых строк. При выполнении операции сравнения никогда не выполняется преобразование типов объектов, за исключением сравнивания объектов числовых типов. 

В Python 3.0 такой порядок был изменен: попытки сравнивания объектов различных типов возбуждают исключение. Так как метод сортировки использует операцию сравнения, это означает, что инструкция [1, 2, 'spam'].sort() будет успешно выполнена в Python 2.X, но возбудит исключение в версии Python 3.0 и выше. 

* list.reverse() - Разворачивает список (в принципе то же самое, что ``sort(reverse=True)``)
* list.copy() - возвращает копию списка, т.е. создает новый список и заполняет его теми же элементами (надо помнить, что если мы просто присвоим один список другому ``a=b``, то копирования данных при этом не происходит, а просто копируется ссылка на существующий объект списка)
* list.clear() - Очищает список

## Кортеж (tuple)
Кортеж (tuple) – это неизменяемая структура данных, которая по своему подобию очень похожа на список.

### Зачем нужны кортежи в Python?
Существует несколько причин, по которым стоит использовать кортежи вместо списков. Одна из них – это обезопасить данные от случайного изменения. Если мы получили откуда-то массив данных, и у нас есть желание поработать с ним, но при этом непосредственно менять данные мы не собираемся, тогда, это как раз тот случай, когда кортежи придутся как нельзя кстати. Используя их в данной задаче, мы дополнительно получаем сразу несколько бонусов – во-первых, это экономия места. Дело в том, что кортежи в памяти занимают меньший объем по сравнению со списками.

Во-вторых – прирост производительности, который связан с тем, что кортежи работают быстрее, чем списки (т.е. на операции перебора элементов и т.п. будет тратиться меньше времени). Важно также отметить, что кортежи можно использовать в качестве ключа у словаря.

### Создание, удаление кортежей и работа с его элементами

**Создание кортежей**</br>
Для создания пустого кортежа можно воспользоваться одной из следующих команд.
```python
a = ()
b = tuple()
```

Кортеж с заданным содержанием создается также как список, только вместо квадратных скобок используются круглые.
```python
a = (1, 2, 3, 4, 5)
```

При желании можно воспользоваться функцией tuple().
```python
a = tuple((1, 2, 3, 4))
```

**Доступ к элементам кортежа**</br>
Доступ к элементам кортежа осуществляется также как к элементам списка – через указание индекса. Но, как уже было сказано – изменять элементы кортежа нельзя!
```python
a = (1, 2, 3, 4, 5)
print(a[0])
print(a[1:3])
```

**Удаление кортежей**</br>
Удалить отдельные элементы из кортежа невозможно, но можно удалить кортеж целиком.
```python
del a
```

**Преобразование кортежа в список и обратно**</br>
На базе кортежа можно создать список, верно и обратное утверждение. Для превращения списка в кортеж достаточно передать его в качестве аргумента функции tuple().
```python
new_tuple = tuple([1,2,3])
```

Для получения списка из кортежа используется функция list:
```python
new_list = list( (1,2,3) )
```

Фактически, кортежи вообще поддерживают те же операции с последовательностями, как и строки: объединение (a+b), клонирование (a*3)

**Список методов**</br>
Кортежи в Python имеют всего два метода: index() и count(). Поведение аналогично таким же методам у списка.
```python
(1, 32, 34, 45).index(32) # 1
(2, 32, 36, 43, 32, 143, 32).count(32) # 3
```

**Меняем данные**
После создания кортежа в Python нельзя менять его структуру. Однако вы сможете управлять данными внутри него. Рассмотрим на примере:
```python
a = [] # пустой список
b = {} # пустой словарь
c = (a, b) # наш кортеж с данными
print(c) # получим на выводе ([], {})

a.append('ROOT') # добавили новое значение в список
b['name'] = 'Максим' # новое значение в словарь
print(c) # получим (['ROOT'], {'name': 'Максим'})
```

Все дело в том ,что кортеж хранит два объекта и структура кортежа не изменилась, изменилось содержимое объектов.

## Работа со словарями
Итак, словарь — это **изменяемый** и **неупорядоченный** объект.

Давайте вспомним списки в Python: [1, 2, 3, 4, 5] при отображении данного списка он в таком же порядке и будет выведен, так как список является упорядоченным. Со словарями все немного по-другому. В зависимости от версии Python при выводе словаря он может выводиться совершенно в другом порядке. Но есть одна особенность: вызов определенных данных со словаря возможен по ключам. В коде Python словари обозначаются фигурными скобками {}. Сама структура словаря выглядит так: {key: data, key2: data}.

>Возможно Python не первый язык программирования, который вы изучаете. Если это так, то вы ранее должны были сталкиваться с массивами. Так вот, словарь по сути тот же ассоциативный массив к примеру в PHP.

Рассмотрим все на примере, создадим словарь: data = {'red': 'Красный', 'green': 'Зеленый'}. Переменная data содержит некие данные, где ключ к данным на английском языке, а содержание на русском. То есть некий переводчик.

Пробуем получить наши данные: ``print(data['red'])``. Получение данных в отличии от списков только в том, что здесь все по ключу.

Так же есть еще и другой способ создания словарей c помощью функции dict(key='data', key2='data'). Это уже дело вкуса. Создавайте так, как вам удобно.

Давайте на примере этого словаря рассмотрим операции, которые с ним можно проводить.

Для того чтобы подсчитать элементы в словаре используем уже знакомую нам  *функцию* **len()**. При ``print(len(data))`` мы увидим количество элементов в словаре (2).

**keys()**
Для того чтобы вывести список ключей необходимо использовать *метод* keys(). Используем код ``print(list(data.keys()))``, в итоге мы получаем список ключей в нашем словаре: ['red','green'].

**values()**
Для того чтобы вывести список значений, а не ключей следует использовать *метод* values(). В итоге мы получаем такой код ``print(list(data.values()))``, это приведет к тому, что в создаваемый нами список будет вставлен список значений из словаря: ['красный','зеленый'].

**items()**
А вот для того чтобы получить список значений и ключей стоит использовать *метод* items(). Код ``list(data.items())`` создаст новый список с уже вложенными элементами: [('red', 'красный'), ('green', 'зеленый')].

**del**
Если нужно удалить элемент словаря стоит использовать *функцию* del: ``del data('red')``, останется список с одним элементом {'green':'зеленый'} (тут похоже пример в нотации Python 2, надо попробовать вариант ``del( data('red') )``).

**Добавление данных в словарь**
Для того чтобы добавить данные в словарь необходимо только указать новый ключ, а также определить его значение. К примеру, ``data['blue'] = 'синий'``, получим список {'green':'зеленый', 'blue':'синий'}.

**Метод fromkeys()**</br>
fromkeys(seq[, value])  -> dict 

Возвращает новый словарь, сформированный из указанной последовательности, с указанным значением элементов (не обязательный параметр).

* seq - Любая последовательность, например список list.
* value - Необязательный аргумент. Значение для каждого элемента списка. Если не задан, в качестве значений используется None.
```python
my_new_dict = dict.fromkeys(['one', 'two', 3])  
# {'one': None, 'two': None, 3: None}

my_new_dict = dict.fromkeys(['one', 'two', 3], 10)  
# {'one': 10, 'two': 10, 3: 10}
```

**Метод get()**</br>
dict.get(key[, default]) -> Значение по ключу, либо default.

Возвращает значение из словаря по указанному ключу.

* key - Ключ, значение по которому требуется получить.
* default - Значение, которое следует вернуть, если в словаре не окажется указанного ключа. По умолчанию — None.

В случае, если ключ не найден в словаре возвращает значение аргумента default. Таким образом, исключение KeyError при использование данного метода не возбуждается никогда (в этом и отличие от простого доступа по ключу ``dict[key]``).

**Метод popitem()**</br>
dict.popitem()  -> tuple,  Кортеж вида (ключ, значение)

Возвращает произвольную пару (ключ, значение) и удалят её из словаря.

Может применяться при необходимости обработать все значения словаря. Аналогом (если данные удалять не нужно) может быть вызов метода keys() и последующий перебор значений в цикле.
```python
a = dict(...)
keys = a.keys()
for i in keys:
    print( a[i] )
```

**Метод setdefault()**</br>
dict.setdefault(key[, default])  -> Значение по ключу, либо default

Возвращает значение по ключу, инициализируя элемент словаря, если необходимо, указанным значением.

* key - Ключ, значение по которому следует получить, если таковое имеется в словаре, либо создать.
* default=None = Значение, которое будет использовано при добавлении нового элемента в словарь.

Позволяет получить значение из словаря по ключу. Автоматически добавляет элемент словаря, если он отсутствует (если ключ есть, то по идее ничего не должен изменять - проверить на практике). 

**Метод update()**</br>
dict.update([other]**kwargs) -> None

>D.update([E, ]**F) -> None</br>
Update D from dict/iterable E and F.</br>
If E is present and has a .keys() method, then does:</br> 
for k in E: D[k] = E[k]</br> 
If E is present and lacks a .keys() method, then does: </br>
for k, v in E: D[k] = v </br>
In either case, this is followed by: for k in F: D[k] = F[k]</br>

обновляет словарь, добавляя пары (ключ, значение) из other. Существующие ключи перезаписываются. Позволяет обновить данные словаря, или дополнить их.

* other - Необязательный аргумент. Другой словарь, либо итерируемый объект с парами ключ, значение (кортеж, либо другой итерируемый объект с двумя элементами).
```python
d = {'x': 2}
""" список выражений, название переменной одновременно станет названием ключа.
Я уже неоднократно отмечал, что всё в Питоне является объектами, а у объекта есть свойства 'имя' и 'значение' """
d.update(y = 3, z = 0) 

# аналогично предыдущему примеру
c=5; d=6
d.update(c, d) 

# список из пар объектов
d.update([('a',1),('b',4)])
```

* **kwargs - Необязательный аргумент. Именованные аргументы значениями которых требуется обновить словарь. Если используется вместе с other, значения из именованных аргументов имеют приоритет.

Есть методы аналогичные методам списков:

**Метод pop()**</br>
dict.pop(key[, default]) -> Значение по ключу, default либо исключение.

Возвращает значение по указанному ключу и убирает элемент из словаря.

* key - Ключ, значение по которому следует добыть
* default - Значение, которое следует вернуть, если указанный ключ отсутствует в словаре. Если не указано, при отсутствии ключа возбуждается исключение KeyError.

**Метод clear()**
Очищает словарь.

**Метод copy()**
Делает копию словаря (мы помним, что при простом присваивании переменных происходит только присваивание указателя на существующий объект).

Важно также понять вложенность словарей. Если в примере выше нашими ключами в словарях служили только строки, и значение ключей тоже были исключительно строчными, то на практике все будет иначе.

Словари в Python могут содержать все что угодно. Значением может быть число, строка, функция, объект или даже сам словарь внутри словаря со своими вложениями.


## Объявление множества. Операции над множествами.
Множества — неупорядоченные наборы уникальных объектов, поддерживающих хеширование.

Множества не упорядочены, они не хранят ни позицию элемента, ни порядок вставки. Поэтому наборы не поддерживают ни обращение к элементам по индексам, ни срезы, ни какое-либо другое поведение, присущее последовательностям.

Множества обычно используются для проверки вхождения элемента, устранения из последовательности дубликатов, и таких математических операций как: пересечение,объединение, разница и симметичная разница.

Для создания множества используется функция **set**, в параметрах любой список.
```python
a = set([1,2,3,4,5,6])
```

### Операции над множествами
Множество итерируемый объект, можно использовать в операции **for**:
```python
for item in {1, 2, 'some'}:
    print(item)
```

**Количество элементов** в последовательности можно получить, используя функцию len().
```python
    len({1, 2, 'some'})  # 3
```

**Сравнение**</br>
Два множества равны тогда и только тогда, когда каждый из элементов множества содержится во втором (когда каждое из множест является подмножеством другого).
```python
set({1,2,3}) == set({3,2,1}) # True
```

Одно множество больше другого тогда и только тогда, когда первое является правильным надмножеством последнего (является надмножеством, но не равно).
```python
set({1,2,3}) > set({2,1}) # True
```

Два любых непустых непересекающихся множества не являются равными и не являются подмножествами друг для друга, поэтому следующию сравнения вернут False: a == b,a > b, a < b. 
```python
set({1,2,3}) > set({4,1}) # False
```

**copy()**
Возвращает копию множества.
```python
set_1 = {1, 2, 3}
set_2 = set_1.copy()

set_1 == set_2  # True (содержимое одинаковое)
set_1 is set_2  # False (но объекты разные)
```

**difference(*others)**</br>
Описать остальные методы

<a name="part2"></a>

>Из своей практики могу предположить что в таких объектах удобно хранить состояние какого-нибудь "железа", например, принтера:</br>
кончилась бумага - модуль добавил это событие (просто строка 'no paper') в множество, одновременно двух одинаковых событий быть не может и при появлении бумаги событие просто удаляется из множества.</br></br>
Это же самое можно просто закодировать в переменной с типом "целое" и помещать/извлекать события соответствующими битовыми операциями (|, ~&), но множество не ограничего размерами и одновременно хранит текст события.


