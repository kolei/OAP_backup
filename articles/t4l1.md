# Тема 4. Лекция 1 и 2
* Понятие подпрограммы. 
* Процедуры и функции, их сущность, назначение и различие. 
* Организация процедур, стандартные процедуры. 
* Процедуры, определенные пользователем: синтаксис, передача аргументов. 
* Возврат результата.
* Формальные и фактические параметры. 
* Процедуры с параметрами, описание процедур.

До этого мы изучали императивный (структурный) тип программирования. Хотя это наиболее естественный тип работы для компьютера, но с точки зрения разработки программ людьми он не годится для разработки сколько нибудь сложных проектов, человек просто не в состоянии запомнить весь этот код.

Для упрощения работы стали выделять обособленные или повторяющиеся части программы в отдельные подпрограммы.

<a name="subroutine"></a>

**Подпрограмма** - это отдельная функционально независимая часть программы. Любая подпрограмма обладает той же структурой, которой обладает и вся программа.

Подпрограммы решают три важные задачи:
* избавляют от необходимости многократно повторять в тексте программы аналогичные фрагменты;
* улучшают структуру программы, облегчая ее понимание;
* повышают устойчивость к ошибкам программирования и непредвидимым последствиям при модификациях программы.

Очень важно понимать, что в подпрограммы выделяется любой законченный фрагмент программы. В качестве ориентиров просмотрите следующие рекомендации:
* Когда Вы несколько раз перепишите в программе одни и те же последовательности команд, необходимость введения подпрограммы приобретает характер острой внутренней потребности.
* Иногда слишком много мелочей закрывают главное. Полезно убрать в подпрограмму подробности, заслоняющие смысл основной программы.
* Полезно разбить длинную программу на составные части - просто как книгу разбивают на главы. При этом основная программа становится похожей на оглавление.

Бывают сложные частные алгоритмы. Полезно отладить их отдельно в небольших тестирующих программах. Включение программ с отлаженными алгоритмами в основную программу будет легким, если они оформлены как подпрограммы.

Все, что Вы сделали хорошо в одной программе, Вам захочется перенести в новые. Для повторного использования таких частей лучше сразу выделять в программе полезные алгоритмы в отдельные подпрограммы.

Подпрограммы могут быть *встроенными*, т.е. определенными системой, и *собственными*, т.е. определенными программистом.

Встроенная подпрограмма (процедура или функция) - подпрограмма, включенная в ядро языка программирования, доступ к которой обеспечивается средствами языка программирования.

Из набора процедур и функций по обработке одного типа информации составляются модули. Доступ к процедурам и функциям модуля осуществляется при подключении этого модуля (import array).

В ядре и стандартных модулях содержится большое количество стандартных подпрограмм, но невозможно создать модуля, который бы содержал все нужные программисту подпрограммы. Поэтому большую роль в создании программ играют собственные подпрограммы, которые создает программист для решения конкретной задачи.

Подпрограммы группируются в отдельных файлах - модулях. Для того чтобы основная программа могла использовать модуль, он должен быть подключен к основной программе.

Структура текста подпрограммы соответствует структуре текста основной программы.

Вызов подпрограммы происходит при каждом употреблении ее имени в основной (или вызывающей) программе. При вызове подпрограммы выполнение основной программы приостанавливается, и управление передается в подпрограмму, где выполняются команды, заданные в ней. Подпрограмма завершается, если выполнены все ее процедуры или по специальной команде выхода из подпрограммы return. По окончании работы подпрограммы управление возвращается основной программе, иначе говоря, к первой команде, следующей за обращением к этой подпрограмме.

<a name="область_видимости"></a>

## Область видимости
При разбиении программы на подпрограммы возникает вопрос с областью видимости переменных объявленных в основном модуле, в подпрограммах и модулях.

Область видимости указывает интерпретатору, когда наименование (или переменная) видимо. Другими словами, область видимости определяет, когда и где вы можете использовать свои переменные, функции, и т.д. Если вы попытаетесь использовать что-либо, что не является в вашей области видимости, вы получите ошибку NameError.

Python содержит три разных типа области видимости:
* Глобальная область видимости
* Локальная область видимости
* Нелокальная область видимости (была добавлена в Python 3)

### Глобальная область видимости
Глобальный контекст подразумевает, что переменная является глобальной, она определена вне любой из функций и доступна любой функции в программе. 

Например:
```python
name = "Tom"
 
def say_hi():
    print("Hello", name)
 
def say_bye():
    print("Good bye", name)
 
say_hi()  # Hello Tom
say_bye() # Good bye Tom
```

Здесь переменная *name* является глобальной и имеет глобальную область видимости. И обе определенные здесь функции могут свободно ее использовать.

### Локальная область видимости
В отличие от глобальных переменных локальная переменная определяется внутри функции и доступна только из этой функции, то есть имеет локальную область видимости:
```python
def say_hi():
    name = "Sam"
    surname = "Johnson"
    print("Hello", name, surname)
 
 
def say_bye():
    name = "Tom"
    print("Good bye", name)
 
say_hi()  # Hello Sam Johnson
say_bye() # Good bye Tom
```

В данном случае в каждой из двух функций определяется локальная переменная name. И хотя эти переменные называются одинаково, но тем не менее это две разных переменных, каждая из которых доступна только в рамках своей функции. Также в функции say_hi определена переменная surname, которая также является локальной, поэтому в функции say_bye мы ее использовать не сможем.

Есть еще один вариант определения переменной, когда локальная переменная скрывают глобальную с тем же именем:
```python
name = "Tom"
  
def say_hi():
    print("Hello", name)

def say_bye():
    name = "Bob"
    print("Good bye", name)
 
say_hi()  # Hello Tom
say_bye() # Good bye Bob
```

Здесь определена глобальная переменная *name*. Однако в функции say_bye определена локальная переменная с тем же именем *name*. И если функция say_hi использует глобальную переменную, то функция say_bye использует локальную переменную, которая скрывает глобальную.

Если же мы хотим изменить в локальной функции глобальную переменную, а не определить локальную, то необходимо использовать ключевое слово global:
```python
def say_bye():
    global name
    name = "Bob"
    print("Good bye", name)
```

В Python, как и во многих других языках программирования, не рекомендуется использовать глобальные переменные. Единственной допустимой практикой является определение небольшого числа глобальных констант, которые не изменяются в процессе работы программы.

```python
PI = 3.14
 
# вычисление площади круга
def get_circle_square(radius):
    print("Площадь круга с радиусом", radius, "равна", PI * radius * radius)
 
get_circle_square(50)
```

В данном случае число 3.14 представлено константой PI. Понятно, что это значение в принципе не изменится, поэтому его можно вынести из функций и определить в виде константы. Как правило, имя константы определяется заглавными буквами.

### Нелокальная область видимости
Оператор **nonlocal** заставляет перечисленные идентификаторы ссылаться на ранее связанные переменные в ближайшей охватывающей области. Например:
```python
def foo():
    x = 10
    def bar():
        nonlocal x
        print(x)
        x += 1
    bar()
    print(x)
foo()
>10
>11
```

### Неочевидные моменты видимости переменных
Рассмотрим пример:
```python
x = 10
def foo():
    print(x)
    x += 1
```

Питон при попытке выполнить функцию **foo** выдаст ошибку. Это происходит потому, что локальная переменная х перекрывает глобальную, но на момент выполнения команды print она еще не определена. Для исправления такой ситуации нужно добавить команду global х или nonlocal х перед функцией print.

### Как организовать совместный доступ к глобальным переменным для нескольких модулей?
Канонический способ организовать подобный доступ - это создать отдельный модуль (часто называемый config или cfg). Просто добавьте import config в каждый модуль приложения. При этом модуль становится доступен через глобальное имя. Поскольку существует только один экземпляр модуля, любые изменения, произведённые в модуле отражаются везде. Например:

``config.py ``
```python 
x = 0
```

``mod.py``
```python
import config
config.x = 1
```

``main.py``
```python

import config
import mod
print(config.x)
```

<a name="function"></a>

## Функции в Python

### Именные функции, инструкция def
Функция – это структура, которую вы определяете. Вам нужно решить, будут ли в ней аргументы, или нет. Вы можете добавить как аргументы ключевых слов, так и готовые по умолчанию. Функция – это блок кода, который начинается с ключевого слова def, названия функции и двоеточия.

Определим простейшую функцию:
```python
def add(x, y):
    return x + y
```

Инструкция *return* говорит, что нужно вернуть значение. В нашем случае функция возвращает сумму x и y.

Теперь мы ее можем вызвать:
```python
add(1, 10)
>11
add('abc', 'def')
>'abcdef'
```

Функция может быть любой сложности и возвращать любые объекты (списки, кортежи, и даже функции!):
```python
def newfunc(n):
    def myfunc(x):
        return x + n
    return myfunc

new = newfunc(100)  # new - это функция
new(200)
>300
```

Функция может и не заканчиваться инструкцией return, при этом функция вернет значение None:
```python
def func():
    pass
print(func())
None
```

### Пустая функция
Иногда, когда вы пишете какой-нибудь код, вам нужно просто ввести определения функции, которое не содержит в себе код.
```python
def empty_function():
    pass
```

А вот здесь кое-что новенькое: оператор pass. Это пустая операция, это означает, что когда оператор pass выполняется, не происходит ничего.

### Аргументы функции
Функция может принимать произвольное количество аргументов или не принимать их вовсе. Также распространены функции с произвольным числом аргументов, функции с позиционными и именованными аргументами, обязательными и необязательными.

Параметры, указываемые при описании функции, называются **формальными**, а параметры, указываемые при вызове – **фактическими**.

#### Обязательные аргументы функции
Если при создании функции мы указали количество передаваемых ей аргументов и их порядок, то и вызывать ее мы должны с тем же количеством аргументов, заданных в нужном порядке.
```python
def bigger(a,b):
    if a > b:
        print a
    else:
       print b

# В описании функции указано, что она принимает 2 аргумента
 
# Корректное использование функции
bigger(5,6)
 
# Некорректное использование функции
bigger()
bigger(3)
bigger(12,7,3)        
```

#### Аргументы - ключевые слова
Аргументы одновременно являются ключевыми словами. Благодаря ключевым аргументам, вы можете задавать произвольный (то есть не такой каким он описа при создании функции) порядок аргументов.

Например:
```python
def person(name, age):
    print name, "is", age, "years old"
 
# Хотя в описании функции первым аргументом идет имя, мы можем вызвать функцию вот так
 
person(age=23, name="John")
```

#### Аргументы, заданные по-умолчанию
Аргумент по умолчанию, это аргумент, значение для которого задано изначально, при создании функции.
```python
def space(planet_name, center="Star"):
    print planet_name, "is orbiting a", center
 
# Можно вызвать функцию space так:
space("Mars")
# В результате получим: Mars is orbiting a Star
 
# Можно вызвать функцию space иначе:
space("Mars", "Black Hole")
# В результате получим: Mars is orbiting a Black Hole
```

Функция также может принимать переменное количество позиционных аргументов, тогда перед именем аргумента ставится *:
```python
def func(*args):
    return args

func(1, 2, 3, 'abc')
>(1, 2, 3, 'abc')

func()
>()

func(1)
>(1,)
```

Как видно из примера, *args* - это кортеж из всех переданных аргументов функции, и с переменной можно работать также, как и с кортежем.

Функция может принимать и произвольное число именованных аргументов, тогда перед именем ставится **:
```python
def func(**kwargs):
    return kwargs

func(a=1, b=2, c=3)
{'a': 1, 'c': 3, 'b': 2}

func()
{}

func(a='python')
{'a': 'python'}
```

В переменной kwargs у нас хранится словарь, с которым мы, опять-таки, можем делать все, что нам заблагорассудится.

### Анонимные функции, инструкция lambda
Анонимные функции могут содержать лишь одно выражение, но и выполняются они быстрее. Анонимные функции создаются с помощью инструкции *lambda*. Кроме этого, их не обязательно присваивать переменной, как делали мы инструкцией ``def func():``
```python
func = lambda x, y: x + y
func(1, 2)
>3

func('a', 'b')
>'ab'

(lambda x, y: x + y)(1, 2)
>3

(lambda x, y: x + y)('a', 'b')
>'ab'
```

lambda функции, в отличие от обычной, не требуется инструкция return, а в остальном, ведет себя точно так же:
```python
func = lambda *args: args
func(1, 2, 3, 4)
>(1, 2, 3, 4)
```

### Типы агрументов функций
Вообще самому питону не нужно явно указывать типы переменных, т.к. все типы в питоне являются объектами, то питон "знает" и название и класс объекта и значение переданного аргумента.

Но в третьем питоне появилась возможность записывать типы агрументов и возвращаемого резульата (наверное много программистов перешло с Си):
```python
def some_function(l: list, i: int) -> int:
```

### Автоматическое документирование
Считается хорошей практикой сразу за определением функции записать краткий комментарий, что эта функция делает, какие аргументы принимает (если вы пишете типы агрументов при описании функции, то этот пункт не обязателен), что возвращает.

Это нужно для того чтобы с вашим кодом было легче разбираться тем, кто будет его поддерживать/развивать после вас.

```python
def возведение_в_квадрат(параметр: int) -> int:
  """Функция возвращает квадрат переданного агрумента"""
  return параметр**2
```

Этот пример несколько утрирован, здесь название функции говорит само за себя, но в более сложных случаях документирование очень облегчает жизнь.

### Передача параметров *по ссылке* или *по значению*
В языках типа Си или Паскаль есть такая тема. По-умолчанию там все параметры (простых типов) передаются *по значению*, т.е. создается новая переменная в стеке, изменения которой никак не повлияют на вызывающую программу. Но при необходимости можно передать не значение переменной, а указатель на нее, тогда все что функция наменяет в этой переменной останется таким и при выходе из функции, такой способ передачи параметров называется передача *по ссылке*.

В питоне завист от того, какой тип объектов мы передаем в качестве переменной. В Питоне существует два типа объектов

* Неизменяемые (immutable)</br>
    Неизменяемые объекты передаются по значению. Это значит, что при изменении значения переменной будет создан новый объект. К этому типу относятся: - числовые данные (int, float, complex) - символьные строки (str) - кортежи (tuple) При инициализации переменной незменяемого типа создается объект (например, целое число), этот объект имеет некоторый идентификатор:
```py
a = 10 
id(a)
>10914656
```

оператор = связывает переменную a и объект посредством ссылки. При этом вы не можете изменить сам объект, т.е. когда вы присвоите переменной новое значение, интерпретатор создаст новый объект (если до этого этот объект был создан, то переменная просто получит ссылку), а первоначальный объект удалится из памяти сбощиком мусора, если ссылок на него больше нет.

* Изменяемые (mutable)</br>
    Изменяемые объекты передаются по ссылке. Это значит, что при изменении значения переменной объект будет изменен. К этому типу относятся: - списки (list) - множества (set) - словари (dict)

**Подводные камни**</br>
Создадим список a, установим для переменной b ссылку на a, прибавим к b элемент списка и выведем их значения и идентификаторы на экран:
```py
a = [1, 2]
b = a
b.append(3)
print(a, b)
>[1, 2, 3] [1, 2, 3]
print(id(a), id(b))
>139748057891656 139748057891656
```

Как мы видим, переменные имеют одинаковые id и элементы списка. Если ты не знаешь об этой особенности изменяемых объетов, то такое поведение программы для тебя становится полной неожиданностью и может привести к ошибке в работе программы. Таким же образом с помощью ссылки на изменяемый объект, переменная передается в функцию:
```py
def add_value(a):
  a.append(3)

b = [1, 2]
add_value(b)
print(b)
>[1, 2, 3]
```

Даже возвращая None, функция изменила список b, чего бы нам не хотелось.

**Что с этим можно сделать**</br>
Для того, чтобы передать в функцию изменяемую переменную как значение, нужно сделать копию изменяемого элемента. Создадим копию списка:

``новый_лист = старый_лист[:]``

Тоже самое можем сделать вот так:

``новый_лист = list(старый_лист)``

Переменная новый_лист ссылается на новый объект:
```py
id(старый_лист), id(новый_лист)
>(139748050279112, 139748057891656)
```

Это дает нам возможность изменять оба объекта независимо друг от друга.

# Секреты хорошей функции (копипаст с хабра)
Что отличает «хорошую» функцию Python от посредственной? Вы удивитесь, как много трактовок допускает слово «хорошая». В рамках этой статьи я буду считать функцию Python «хорошей», если она удовлетворяет большинству пунктов из следующего списка (выполнить все пункты для конкретной функции порой невозможно):
* Она внятно названа
* Соответствует принципу единственной обязанности
* Содержит докстроку
* Возвращает значение
* Состоит не более чем из 50 строк
* Она идемпотентная и, если это возможно, чистая

Многим из вас эти требования могут показаться чрезмерно суровыми. Однако, обещаю: если ваши функции будут соответствовать этим правилам, то получатся настолько прекрасны, что пробьют на слезу даже единорога. Ниже я посвящу по разделу каждому из элементов вышеприведенного списка, а затем завершу повествование, рассказав, как они гармонируют друг с другом и помогают создавать хорошие функции. 

## Именование
Вот моя любимая цитата на эту тему, часто ошибочно приписываемая Дональду, а на самом деле принадлежащая Филу Карлтону:

>В компьютерных науках есть две сложности: инвалидация кэша и именование.

Как бы глупо это ни звучало, именование – действительно сложная штука. Вот пример «плохого» названия функции:

``def get_knn_from_df(df):``

Теперь плохие названия попадаются мне практически повсюду, но данный пример взят из области Data Science (точнее, машинного обучения), где практикующие специалисты обычно пишут код в блокноте Jupyter, а потом пытаются собрать из этих ячеек удобоваримую программу.

Первая проблема с названием этой функции – в нем используются аббревиатуры. Лучше использовать полные английские слова, а не аббревиатуры и не малоизвестные сокращения. Единственная причина, по которой хочется сокращать слова — не тратить сил на набор лишнего текста, но в любом современном редакторе есть функция автозавершения, поэтому вам придется набрать полное название функции всего один раз. Аббревиатура – это проблема,поскольку зачастую она специфична для предметной области. В вышеприведенном коде knn означает «K-ближайшие соседи», а df означает «DataFrame», структуру данных, повсеместно используемую в библиотеке pandas. Если код будет читать программист, не знающий этих сокращений, то он практически ничего не поймет в названии функции.

Еще в названии этой функции есть два более мелких недочета. Во-первых, слово "get" избыточно. В большинстве грамотно поименованных функций сразу понятно, что данная функция что-то возвращает, что конкретно – отражено в имени. Элемент from_df также не нужен. Либо в докстроке функции, либо (если она находится на периферии) в аннотации типа будет описан тип параметра, если эта информация и так не очевидна из названия параметра.

Так как же нам переименовать эту функцию? Просто:

``def k_nearest_neighbors(dataframe):``

Теперь даже неспециалисту понятно, что вычисляется в этой функции, а имя параметра (dataframe) не оставляет сомнений, какой аргумент ей следует передавать.

## Единственная ответственность
Развивая мысль Боба Мартина, скажу, что *Принцип единственной ответственности* касается функций не меньше, чем классов и модулей (о которых изначально и писал господин Мартин). Согласно этому принципу (в нашем случае) у функции должна быть единственная ответственность. То есть, она должна делать одну и только одну вещь. Один из самых веских доводов в пользу этого: если функция делает всего одну вещь, то и переписывать ее придется в единственном случае: если эту самую вещь придется делать по-новому. Также становится ясно, когда функцию можно удалить; если, внеся изменения где-то в другом месте, мы поймем, что единственная обязанность функции более не актуальна, то мы от нее просто избавимся.

Здесь лучше привести пример. Вот функция, делающая более одной «вещи»:
```python
def calculate_and print_stats(list_of_numbers):
    sum = sum(list_of_numbers)
    mean = statistics.mean(list_of_numbers)
    median = statistics.median(list_of_numbers)
    mode = statistics.mode(list_of_numbers)

    print('-----------------Stats-----------------')
    print('SUM: {}'.format(sum)
    print('MEAN: {}'.format(mean)
    print('MEDIAN: {}'.format(median)
    print('MODE: {}'.format(mode)
```

А именно две: вычисляет набор статистических данных о списке чисел и выводит их в STDOUT. Функция нарушает правило: должна быть единственная конкретная причина, по которой ее, возможно, потребовалось бы изменить. В данном случае просматриваются две очевидные причины, по которым это понадобится: либо потребуется вычислять новую или иную статистику, либо потребуется изменить формат вывода. Поэтому данную функцию лучше переписать в виде двух отдельных функций: одна будет выполнять вычисления и возвращать их результаты, а другая – принимать эти результаты и выводить их в консоль. Функцию (вернее, наличие у нее двух обязанностей) с потрохами выдает слово and в ее названии.

Такое разделение также серьезно упрощает тестирование функции, а еще позволяет не только разбить ее на две функции в рамках одного и того же модуля, но даже разнести две эти функции в совершенно разные модули, если это уместно. Это дополнительно способствует более чистому тестированию и упрощает поддержку кода.

На самом деле, функции, выполняющие ровно две вещи, встречаются редко. Гораздо чаще натыкаешься на функции, делающие намного, намного больше операций. Опять же, из соображений удобочитаемости и тестируемости такие «многостаночные» функции следует дробить на однозадачные, в каждой из которых заключен единственный аспект работы.

## Докстроки
Казалось бы, все в курсе, что есть документ *PEP-8*, где даются рекомендации по стилю кода на Python, но гораздо меньше среди нас тех, кто знает *PEP-257*, в котором такие же рекомендации даются по поводу докстрок. Чтобы не пересказывать содержание *PEP-257*, отсылаю вас самих к этому документу – почитайте в свободное время. Однако, основные его идеи таковы:

* Для каждой функции нужна докстрока
* В ней следует соблюдать грамматику и пунктуацию; писать законченными предложениями
* Докстрока начинается с краткого (в одно предложение) описания того, что делает функция
* Докстрока формулируется в предписывающем, а не в описательном стиле

Все эти пункты легко соблюсти, когда пишешь функции. Просто написание докстрок должно войти в привычку, причем, старайтесь писать их прежде, чем приступать к коду самой функции. Если у вас не получается написать четкую докстроку, характеризующую функцию – это хороший повод задуматься, зачем вы вообще пишете эту функцию. 

## Возвращаемые значения
Функции можно (и следует) трактовать как маленькие самодостаточные программы. Они принимают некоторый ввод в форме параметров и возвращают результат. Параметры, конечно, опциональны. А вот возвращаемые значения обязательны с точки зрения внутреннего устройства Python. Если вы даже попытаетесь написать функцию, которая не возвращает значения – не сможете. Если функция даже не станет возвращать значения, то интерпретатор Python «принудит» ее возвращать None.

Я даже не побоюсь утверждать следующее: каждая функция должна возвращать полезное значение, хотя бы ради тестируемости. Код, который я пишу, должен быть протестирован (это не обсуждается). Кроме того, возвращая значение, мы можем выполнять сцепление методов и, следовательно, писать код вот так: 
```python
with open('foo.txt', 'r') as input_file:
    for line in input_file:
        if line.strip().lower().endswith('cat'):
            # ... делаем с этими строками что-нибудь полезное
```

Строка ``if line.strip().lower().endswith('cat'):`` работает, поскольку каждый из строковых методов (strip(), lower(), endswith()) в результате вызова функции возвращает строку.

Вот несколько распространенных доводов, которые вам может привести программист, объясняя, почему написанная им функция не возвращает значения:
```
«Она всего лишь [какая-то операция, связанная с вводом/выводом, например, сохранение значения в базе данных]. Здесь я не могу вернуть ничего полезного.»
```
Не соглашусь. Функция может вернуть True, если операция завершилась успешно.
```
«Здесь мы изменяем один из имеющихся параметров, используем его как ссылочный параметр.»
```
Здесь – два замечания. Во-первых, всеми силами старайтесь так не делать. Во-вторых, снабжать функцию каким-либо аргументом лишь для того, чтобы узнать, что она изменилась – в лучшем случае удивительно, а в худшем – попросту опасно. Вместо этого, как и при работе со строковыми методами, старайтесь возвращать новый экземпляр параметра, в котором уже отражены примененные к нему изменения. Даже если это не получается делать, поскольку создание копии какого-то параметра сопряжено с чрезмерными издержками, все равно можно откатываться к предложенному выше варианту «Вернуть True, если операция завершилась успешно».
```
«Мне нужно возвращать несколько значений. Нет такого единственного значения,которое в данном случае было бы целесообразно возвращать.»
```
Этот аргумент немного надуманный, но мне доводилось его слышать. Ответ, разумеется, как раз в том, что автор и хотел сделать – но не знал как: для возврата нескольких значений используйте кортеж.

Наконец, самый сильный аргумент в пользу того, что полезное значение лучше возвращать в любом случае – в том, что вызывающая сторона всегда может с полным правом эти значения игнорировать. Короче говоря, возврат значения от функции – практически наверняка здравая идея, и крайне маловероятно, что мы таким образом что-нибудь повредим, даже в сложившихся базах кода.

## Длина функции
Я не раз признавался, что довольно туп. Могу одновременно держать в голове примерно три вещи. Если вы дадите мне прочесть 200-строчную функцию и спросите, что она делает, я, вероятно, буду таращиться на нее не менее 10 секунд. Длина функции прямо сказывается на ее удобочитаемости и, следовательно, на поддержке. Поэтому старайтесь, чтобы ваши функции оставались короткими. 50 строк – величина, взятая совершенно с потолка, но мне она кажется разумной. (Надеюсь), что большинство функций, которые вам доведется писать, будут значительно короче.

Если функция соответствует *Принципу единственной ответственности*, то, вероятно, она будет достаточно краткой. Если она чистая или идемпотентная (об этом мы поговорим) ниже – то, наверное, она также получится короткой. Все эти идеи гармонично сочетаются друг с другом и помогают писать хороший, чистый код.

Итак, что же делать, если ваша функция получилась слишком длинной? РЕФАКТОРИТЬ! Вероятно, вам приходится заниматься рефакторингом постоянно, даже если вы не знаете этого термина. Рефакторинг – это попросту изменение структуры программы, без изменения ее поведения. Поэтому, извлечение нескольких строк кода из длинной функции и превращение их в самостоятельную функцию – это один из типов рефакторинга. Оказывается, это еще и наиболее распространенный, и самый быстрый способ продуктивного укорачивания длинных функций. Поскольку вы даете этим новым функциям подходящие имена, получающийся у вас код гораздо проще читать. Я написал целую книгу о рефакторинге (на самом деле, я им постоянно занимаюсь), так что здесь вдаваться в детали не буду. Просто знайте, что, если у вас есть слишком длинная функция – то ее следует рефакторить.

## Идемпотентность и функциональная чистота
Заголовок этого раздела может показаться слегка устрашающим, но концептуально раздел прост. Идемпотентная функция при одинаковом наборе аргументов всегда возвращает одно и то же значение, независимо от того, сколько раз ее вызывают. Результат не зависит от нелокальных переменных, изменяемости аргументов или от любых данных, поступающих из потоков ввода/вывода. Следующая функция add_three(number) идемпотентна:
```py
def add_three(number):
    """вернуть *число* + 3."""
    return number + 3
```

Независимо от того, сколько раз мы вызовем add_three(7), ответ всегда будет равен 10. А вот другой случай – функция, не являющаяся идемпотентной:
```py
def add_three():
    """Вернуть 3 + число, введенное пользователем."""
    number = int(input('Enter a number: '))
    return number + 3
```

Эта откровенно надуманная функция не идемпотентна, поскольку возвращаемое значение функции зависит от ввода/вывода, а именно – от числа, введенного пользователем. Разумеется, при разных вызовах add_three() возвращаемые значения будут отличаться. Если мы дважды вызовем эту функцию, то пользователь в первом случае может ввести 3, а во втором – 7, и тогда два вызова add_three() вернут 6 и 10 соответственно.

Вне программирования также встречаются примеры идемпотентности – например, по такому принципу устроена кнопка «вверх» у лифта. Нажимая ее в первый раз,мы «уведомляем» лифт, что хотим подняться. Поскольку кнопка идемпотентна, то сколько ее потом ни нажимать – ничего страшного не произойдет. Результат будет всегда одинаков. 

## Почему идемпотентность так важна
Тестируемость и удобство в поддержке. Идемпотентные функции легко тестировать, поскольку они гарантированно, в любом случае вернут одинаковый результат, если вызвать их с одними и теми же аргументами. Тестирование сводится к проверке того, что при разнообразных вызовах функция всегда возвращает ожидаемое значение. Более того, эти тесты будут быстрыми: скорость тестов – важная проблема, которую часто обходят вниманием при модульном тестировании. А рефакторинг при работе с идемпотентными функциями – вообще легкая прогулка. Не важно, как вы измените код вне функции – результат ее вызова с одними и теми же аргументами всегда будет один и тот же. 

## Что такое «чистая» функция?
В функциональном программировании функция считается чистой, если она, во-первых, идемпотентна, а во-вторых – не вызывает наблюдаемых побочных эффектов. Не забывайте: функция идемпотентна, если всегда возвращает один и тот же результат при конкретном наборе аргументов. Однако, это не означает, что функция не может влиять на другие компоненты – например, на нелокальные переменные или потоки ввода/вывода. Например, если бы идемпотентная версия вышеприведенной функции add_three(number) выводила результат в консоль, а лишь затем возвращала бы его, она все равно считалась бы идемпотентной, поскольку при ее обращении к потоку ввода/вывода эта операция доступа никак не влияет на значение, возвращаемое от функции. Вызов print() – это просто побочный эффект: взаимодействие с остальной программой или системой как таковой, происходящее наряду с возвратом значения.

Давайте немного разовьем наш пример с add_three(number). Можно написать следующий код, чтобы определить, сколько раз была вызвана add_three(number):
```py
add_three_calls = 0

def add_three(number):
    """Вернуть *число* + 3."""
    global add_three_calls
    print(f'Returning {number + 3}')
    add_three_calls += 1
    return number + 3

def num_calls():
    """Вернуть, сколько раз была вызвана *add_three*."""
    return add_three_calls
```

Теперь мы выполняем вывод в консоль (это побочный эффект) и изменяем нелокальную переменную (другой побочный эффект), но, поскольку ни то, ни другое не влияет на значение, возвращаемое функцией, она все равно идемпотентна.

Чистая функция не оказывает побочных эффектов. Она не только не использует никаких «внешних данных» при расчете значения, но и не взаимодействует с остальной программой/системой, только вычисляет и возвращает указанное значение. Следовательно, хотя наше новое определение add_three(number) остается идемпотентным, эта функция уже не чистая.

В чистых функциях нет инструкций логирования или вызовов print(). При работе они не обращаются к базе данных и не используют соединений с интернетом. Не обращаются к нелокальным переменным и не изменяют их. И не вызывают других не-чистых функций. 

Короче говоря, они не оказывают «жуткого дальнодействия», выражаясь словами Эйнштейна (но в контексте информатики, а не физики). Они не изменяют каким-либо образом остальные части программы или системы. В императивном программировании (а именно им вы и занимаетесь, когда пишете код на Python),такие функции – самые безопасные. Они известны своей тестируемостью и удобством в поддержке; более того, поскольку они идемпотентны, тестирование таких функций гарантированно будет столь же быстрым, как и выполнение. Сами тесты также просты: не приходится подключаться к базе данных либо имитировать какие-либо внешние ресурсы, готовить стартовую конфигурацию кода, а по окончании работы не нужно ничего подчищать.

Честно говоря, идемпотентность и чистота очень желательны, но не обязательны. То есть, нам бы хотелось писать только чистые или идемпотентные функции, учитывая все вышеупомянутые их преимущества, но это не всегда возможно. Суть, однако, в том, чтобы приучиться писать код, естественным образом не допуская побочных эффектов и внешних зависимостей. Таким образом, каждую написанную нами строку кода станет проще тестировать, даже если не удастся обойтись только лишь чистыми или идемпотентными функциями. 

***
* [Понятие подпрограммы](#subroutine)
* [Область видимости](#область_видимости)
* [Функции в Python](#function)
