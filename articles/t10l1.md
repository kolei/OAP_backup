[содержание](/readme.md)  

# Тема 10. Знакомство с отдельными модулями<br/>Лекция 1 HTTP-запросы

В стандартной библиотеке Python есть ряд готовых модулей по работе с HTTP.

* urllib
* httplib

Если уж совсем хочется хардкора, то можно и сразу с *socket* поработать. Но у всех этих модулей есть один большой недостаток - неудобство работы.

Во-первых, большое обилие классов и функций. Во-вторых, код получается вовсе не pythonic. Многие программисты любят Python за его элегантность и простоту, поэтому и был создан модуль, призванный решать проблему существующих и имя ему **requests** или HTTP For Humans.

## Что же умеет requests?
Для начала хочется показать как выглядит код работы с http, используя модули из стандартной библиотеки Python и код при работе с requests. В качестве мишени для стрельбы http запросами будет использоваться очень удобный сервис httpbin.org

```py
import urllib.request
response = urllib.request.urlopen('https://httpbin.org/get')
print(response.read())
print(response.getheader('Server'))
print(response.getcode())
```

В консоли будет примерно такое:

```
'{\n  "args": {}, \n  "headers": {\n    "Accept-Encoding": "identity", \n    "Host": "httpbin.org", \n    "User-Agent": "Python-urllib/3.5"\n  }, \n  "origin": "95.56.82.136", \n  "url": "https://httpbin.org/get"\n}\n'
nginx
200
```

Кстати, urllib.request это надстройка над "низкоуровневой" библиотекой httplib.

Теперь попробуем выполнить то же самое с помощью **requests**

```py
import requests
response = requests.get('https://httpbin.org/get')
print(response.content)
print(response.json())
print(response.headers)
print(response.headers.get('Server'))
```

В консоли будет что-то типа:

```
b'{\n  "args": {}, \n  "headers": {\n    "Accept": "*/*", \n    "Accept-Encoding": "gzip, deflate", \n    "Host": "httpbin.org", \n    "User-Agent": "python-requests/2.9.1"\n  }, \n  "origin": "95.56.82.136", \n  "url": "https://httpbin.org/get"\n}\n'

{'headers': {'Accept-Encoding': 'gzip, deflate', 'User-Agent': 'python-requests/2.9.1', 'Host': 'httpbin.org', 'Accept': '*/*'}, 'args': {}, 'origin': '95.56.82.136', 'url': 'https://httpbin.org/get'}

{'Connection': 'keep-alive', 'Content-Type': 'application/json', 'Server': 'nginx', 'Access-Control-Allow-Credentials': 'true', 'Access-Control-Allow-Origin': '*', 'Content-Length': '237', 'Date': 'Wed, 23 Dec 2015 17:56:46 GMT'}

nginx
```

В простых методах запросов значительных отличий у них не имеется. Но давайте взглянем на работу с Basic Auth:

Стандартная библиотека:

'''py
import urllib.request
password_mgr = urllib.request.HTTPPasswordMgrWithDefaultRealm()
top_level_url = 'https://httpbin.org/basic-auth/user/passwd'
password_mgr.add_password(None, top_level_url, 'user', 'passwd')
handler = urllib.request.HTTPBasicAuthHandler(password_mgr)
opener = urllib.request.build_opener(handler)
response = opener.open(top_level_url)
response.getcode()
# 200
response.read()
# b'{\n  "authenticated": true, \n  "user": "user"\n}\n'
```

requests:

```py
import requests
response = requests.get('https://httpbin.org/basic-auth/user/passwd', auth=('user', 'passwd'))
print(response.content)
# b'{\n  "authenticated": true, \n  "user": "user"\n}\n'
print(response.json())
# {'user': 'user', 'authenticated': True}
```

Разница на лицо. И несмотря на тот факт, что **requests** ничто иное как обёртка над urllib3, а последняя является надстройкой над стандартными средствами Python, удобство написания кода в большинстве случаев является приоритетом номер один.

В requests имеется:

* Множество методов http аутентификации
* Сессии с куками
* Полноценная поддержка SSL
* Различные методы-плюшки вроде .json(), которые вернут данные в нужном формате
* Проксирование
* Грамотная и логичная работа с исключениями

О последнем пункте хотелось бы поговорить чуточку подробнее.

## Обработка исключений в requests

**При работе с внешними сервисами никогда не стоит полагаться на их отказоустойчивость**. Всё упадёт рано или поздно, поэтому нам, программистам, необходимо быть всегда к этому готовыми, желательно заранее и в спокойной обстановке.

Итак, как у requests дела обстоят с различными ошибками в момент сетевых соединений? Для начала определим ряд проблем, которые могут возникнуть:

* Хост недоступен. Обычно такого рода ошибка происходит из-за проблем конфигурирования DNS. (DNS lookup failure)
* "Вылет" соединения по таймауту
* Ошибки HTTP. Подробнее о HTTP кодах можно посмотреть [здесь](https://www.restapitutorial.com/httpstatuscodes.html).
* Ошибки SSL соединений (обычно при наличии проблем с SSL сертификатом: просрочен, не является доверенным и т.д.)

Базовым классом-исключением в requests является **RequestException**. От него наследуются все остальные

* HTTPError
* ConnectionError
* Timeout
* SSLError
* ProxyError

И так далее. Полный список всех исключений можно посмотреть в requests.exceptions.

### Timeout
В requests имеется 2 вида таймаут-исключений:

* **ConnectTimeout** - таймаут на соединения
* **ReadTimeout** - таймаут на чтение

```py
import requests

try:
    response = requests.get('https://httpbin.org/user-agent', 
                            timeout=(0.00001, 10))
except requests.exceptions.ConnectTimeout:
    print('Oops. Connection timeout occured!')

# Oops. Connection timeout occured!

try:
    response = requests.get('https://httpbin.org/user-agent', 
                            timeout=(10, 0.0001))
except requests.exceptions.ReadTimeout:
    print('Oops. Read timeout occured')
except requests.exceptions.ConnectTimeout:
    print('Oops. Connection timeout occured!')

# Oops. Read timeout occured
```

### ConnectionError

```py
import requests

try:
    response = requests.get('http://urldoesnotexistforsure.bom')
except requests.exceptions.ConnectionError:
    print('Seems like dns lookup failed..')
     
# Seems like dns lookup failed..
```

### HTTPError

```py
import requests

try:
    response = requests.get('https://httpbin.org/status/500')
    response.raise_for_status()
except requests.exceptions.HTTPError as err:
    print('Oops. HTTP Error occured')
    print('Response is: {content}'.format(content=err.response.content))
     
# Oops. HTTP Error occured
# Response is: b''
```

Я перечислил основные виды исключений, которые покрывают, пожалуй, 90% всех проблем, возникающих при работе с http. Главное помнить, что если мы действительно намерены отловить что-то и обработать, то это необходимо явно запрограммировать, если же нам неважен тип конкретного исключения, то можно отлавливать общий базовый класс RequestException и действовать уже от конкретного случая, например, залоггировать исключение и выкинуть его дальше наверх. 


## Быстрый старт

### Простые запросы

```py
import requests

# обычный GET
r = requests.get('https://api.github.com/events')

# POST, в параметре data передается словарь
r = requests.post('https://httpbin.org/post', data = {'key':'value'})

# поддерживаются дополнительные методы, позволяющие организовать запросы к REST-серверу
r = requests.put('https://httpbin.org/put', data = {'key':'value'})
r = requests.delete('https://httpbin.org/delete')
r = requests.head('https://httpbin.org/get')
r = requests.options('https://httpbin.org/get')
```

### Передача параметров в GET-запросе
Как послать POST запрос выше уже показано, а как насчет GET?

```py
payload = {'key1': 'value1', 'key2': 'value2'}
r = requests.get('https://httpbin.org/get', params=payload)

# можно посмотреть на получившийся URL:
print(r.url)

# https://httpbin.org/get?key2=value2&key1=value1
```

### Содержимое ответа сервера (content)

```py
import requests

r = requests.get('https://api.github.com/events')
print(r.text)
# [{"id": "9140873463","type": "CreateEvent","actor":{...
```

Строка, как и положено Питону, в UTF-8. Оригинальную кодировку (которая указана в HTTP-заголовке) можно посмотреть в аттрибуте ``r.encoding``

### JSON
Если в ответе сервера ожидается JSON, то можно просто вызвать встроенный метод ``.json()`` для получения словаря.

### Настраиваемые заголовки
Если нужно изменить стандарные заголовки или добавить свой, то используйте параметр *headers* 

```py
url = 'https://api.github.com/some/endpoint'
headers = {'user-agent': 'my-app/0.0.1'}
r = requests.get(url, headers=headers)
```

>в [некоторых](http://docs.python-requests.org/en/master/user/quickstart/#custom-headers) случаях заголовки могут быть изменены или удалены


### Подробнее о POST-запросах

Если нужно послать данные в формате ``form-encoded``, то достаточно  параметру data присвоить словарь или кортеж. 

```py
#обычный запрос, в data передается словарь 
payload = {'key1': 'value1', 'key2': 'value2'}
r = requests.post("https://httpbin.org/post", data=payload)

# в data передается кортеж 
payload_tuples = [('key1', 'value1'), ('key1', 'value2')]
r1 = requests.post('https://httpbin.org/post', data=payload_tuples)

# в data передается словарь с массивом в значении ключа 
payload_dict = {'key1': ['value1', 'value2']}
r2 = requests.post('https://httpbin.org/post', data=payload_dict)
```

Если же нужно послать не в ``form-encoded`` формате, то нужно либо присвоить параметру data строку:

```py
import json

payload = {'some': 'data'}

r = requests.post('https://api.github.com/some/endpoint', data=json.dumps(payload))
```

Либо вместо *data* использовать параметр *json*:

```py
payload = {'some': 'data'}
r = requests.post(url, json=payload)
```

>параметр *json* будет проигнорирован, если одновременно задать параметр *data* или *files*

### Отправка файлов (Multipart-Encoded)
С **requests** это делается элементарно:

```py
files = {'file': open('report.xls', 'rb')}
r = requests.post(url, files=files)
```

Можно добавить имя файла, content_type и headers:

```py
files = {'file': ('report.xls', open('report.xls', 'rb'), 'application/vnd.ms-excel', {'Expires': '0'})}

r = requests.post(url, files=files)
```

Можно даже послать строку, а на севрере при этом получить файл:

```py
files = {'file': ('report.csv', 'some,data,to,send\nanother,row,to,send\n')}
r = requests.post(url, files=files)
```

**requests** не поддерживает работу с потоками, а они могут пригодиться при передаче больших файлов. В этом случае используйте другой [модуль](https://toolbelt.readthedocs.io/en/latest/) 

>ВНИМАНИЕ! При передаче файлов обязательно открывайте их в двоичном виде, иначе заголовок ``Content-Length`` может быть неверно сосчитан.

### Код ответа

```py
r = requests.get('https://httpbin.org/get')
r.status_code # 200
```

### Заголовки ответа

Ответы хранятся в словаре *headers*

```py
r.headers
# {
#     'content-encoding': 'gzip',
#     'transfer-encoding': 'chunked',
#     'connection': 'close',
#     'server': 'nginx/1.0.4',
#     'x-runtime': '148ms',
#     'etag': '"e1ca502697e5c9317743dc078f67693f"',
#     'content-type': 'application/json'
# }
```

Словарь специальный, т.к. HTTP-заголовки должны быть регистро независимыми. Обратиться к элементу словаря можно используя любой регистр:

```py
r.headers['Content-Type']
# 'application/json'

r.headers.get('content-type')
# 'application/json'
```

### Плюшки (Cookies)

```py
r = requests.get(url)

#вытаскивает из ответа куку по имени
r.cookies['example_cookie_name']
```

Для отправки куки вместе с запросом используйте параметр *cookies*:

```py
cookies = dict(cookies_are='working')

r = requests.get(url, cookies=cookies)
```

Есть и более продвинутые способы работы с куками:

```py
jar = requests.cookies.RequestsCookieJar()
jar.set('tasty_cookie', 'yum', domain='httpbin.org', path='/cookies')
jar.set('gross_cookie', 'blech', domain='httpbin.org', path='/elsewhere')
r = requests.get(url, cookies=jar)
r.text #'{"cookies": {"tasty_cookie": "yum"}}'
```

### Redirection and History
By default Requests will perform location redirection for all verbs except HEAD.

We can use the history property of the Response object to track redirection.

The Response.history list contains the Response objects that were created in order to complete the request. The list is sorted from the oldest to the most recent response.

For example, GitHub redirects all HTTP requests to HTTPS:

```py
r = requests.get('http://github.com/')
r.url         #'https://github.com/'
r.status_code #200
r.history     # [<Response [301]>]
```

If you’re using GET, OPTIONS, POST, PUT, PATCH or DELETE, you can disable redirection handling with the allow_redirects parameter:

```py
r = requests.get('http://github.com/', allow_redirects=False)
r.status_code #301
r.history     #[]
```

If you’re using HEAD, you can enable redirection as well:

```py
r = requests.head('http://github.com/', allow_redirects=True)
r.url     #'https://github.com/'
r.history #[<Response [301]>]
```

### Timeout
Желательно задавать время ожидания запроса, т.к. значение по-умолчанию может быть достаточно большим. Время задается в секундах.

Можно задать таймаут как на соединение в целом, так и выделить таймаут на чтение отдельно

```py
# общий таймаут
r = requests.get('https://github.com', timeout=5)
# таймаут на соединение 3 сек, таймаут на чтение 27 сек 
r = requests.get('https://github.com', timeout=(3.05, 27))
```

>подробнее с методами requests можно ознакомиться [тут](http://docs.python-requests.org/en/master/)

[содержание](/readme.md)  
