[содержание](/readme.md)  

# Тема 7.<br/>Лекция 4 Ошибки и исключения. Декораторы.

В любой, особенно большой, программе могут возникать ошибки, приводящие к ее неработоспособности или к тому, что программа делает не то, что должна. 
Причин возникновения ошибок много.

Программист может сделать ошибку в употреблении самого языка программирования. Другими словами, выразиться так, как выражаться не положено. Например, начать имя переменной с цифры или забыть поставить двоеточие в заголовке сложной инструкции. Подобные ошибки называют **синтаксическими**, они нарушают синтаксис и пунктуацию языка. Интерпретатор Питона, встретив ошибочное выражение, не знает как его интерпретировать. Поэтому останавливает выполнение программы и выводит соответствующее сообщение, указав на место возникновения ошибки:

```
1a = 10
>File "<stdin>", line 1
1a = 10
^
SyntaxError: invalid syntax
```

В терминологии языка Python здесь возникло исключение, принадлежащее классу SyntaxError. Согласно документации Python синтаксические ошибки все-таки принято относить к ошибкам, а все остальные – к исключениям. В некоторых языках программирования не используется слово "исключение", а ошибки делят на синтаксические и семантические. Нарушение семантики обычно означает, что, хотя выражения написаны верно с точки зрения синтаксиса языка, программа не работает так, как от нее ожидалось. Для сравнения. Вы можете грамотным русским языком сказать несколько предложений, но по смыслу это будет белиберда, или вас поймут не так, как хотелось бы.

В Python не говорят о семантических ошибках, говорят об исключениях.

>**Traceback**<br/>
>В большой программе исключения часто возникают во время выполнения. Чтобы упростить программисту понимание ошибки и причины такого поведения Python предлагает Traceback или в сленге - трэйс. Каждое исключение содержит краткую информацию, но при этом полную, информацию о месте появления ошибки. По трэйсу найти и исправить ошибку становится проще.
>
>Рассмотрим такой пример:
>
>```
>Traceback (most recent call last):
>  File "test/app.py", line 862, in _handle
>    return route.call(**args)
>  File "test/app.py", line 1729, in wrapper
>    rv = callback(*a, **ka)
>  File "test/__init__.py", line 76, in wrapper
>    body = callback(*args, **kwargs)
>  File "test/my_app.py", line 16, in index
>    raise Exception('test exception')
>```
>
>В данном примере четко видно, какой путь исполнения у программы. Смотрим снизу вверх и по шагам пониманием, как же мы докатились до такого исключения.

Если вы попытаетесь обратиться к переменной, которой не было присвоено значение, что в случае Python означает, что переменная вообще не была объявлена, она не существует, то возникнет исключение NameError.

```
a = 0
print(a + b)
>Traceback (most recent call last):
File "<stdin>", line 1, in <module>
NameError: name 'b' is not defined
```

Последнюю строку сообщения можно перевести как "Ошибка имени: имя 'b' не определено".

Если исключение возникает при выполнении кода из файла, то вместо "line 1" будет указана строка, в которой оно возникло, например, "line 24". Вместо "<stdin>" будет указано имя файла, например, "test.py". В данном же случае stdin обозначает стандартный поток ввода. По-умолчанию это поток ввода с клавиатуры. Строка 1 – потому что в интерактивном режиме каждое выражение интерпретируется отдельно, как обособленная программа. Если написать выражение, состоящее из нескольких строк, то линия возникновения ошибки может быть другой:

```
a = 0
if a == 0:
  print(a)
  print(a + b)
...
>0
>Traceback (most recent call last):
File "<stdin>", line 3, in <module>
NameError: name 'b' is not defined
```

Следующие два исключения, о которых следует упомянуть, и с которыми вы уже могли встретиться в предыдущих уроках, это ValueError и TypeError – ошибка значения и ошибка типа.

```
int("Hi")
>Traceback (most recent call last):
File "<stdin>", line 1, in <module>
ValueError: invalid literal for int() with base 10: 'Hi'

8 + "3"
>Traceback (most recent call last):
File "<stdin>", line 1, in <module>
TypeError: unsupported operand type(s) for +: 'int' and 'str'
```

В примере строку "Hi" нельзя преобразовать к целому числу. Возникает исключение ValueError, потому что функция int() не может преобразовать такое значение.

Число 8 и строка "3" принадлежат разным типам, операнд сложения между которыми не поддерживается. При попытке их сложить возникает исключение TypeError.

Деление на ноль вызывает исключение ZeroDivisionError:

```
1/0
>Traceback (most recent call last):
File "<stdin>", line 1, in <module>
ZeroDivisionError: division by zero
```
 
## Обработка исключений. Оператор try-except
Когда ошибки в программе возникают в процессе написания кода или его тестирования, то код исправляется программистом так, чтобы ошибок не возникало. Однако нередко действия пользователя приводят к тому, что в программе возникает исключение. Например, программа ожидает ввод числа, но человек ввел букву. Попытка преобразовать ее к числу приведет к возбуждению исключения ValueError, и программа аварийно завершится.

На этот случай в языках программирования, в том числе Python, существует специальный оператор, позволяющий перехватывать возникающие исключения и обрабатывать их так, чтобы программа продолжала работать или корректно завершала свою работу.

В Питоне такой перехват выполняет оператор try-except. "Try" переводится как "попытаться", "except" – как исключение. Словами описать его работу можно так: "Попытаться сделать то-то и то-то, если при этом возникло исключение, то сделать вот это и это." Его конструкция похожа на условный оператор с веткой else. Рассмотрим пример:

```py
n = input("Введите целое число: ")
try:
    n = int(n)
    print("Удачно")
except:
    print("Что-то пошло не так")
```

Исключительная ситуация может возникнуть в третьей строчке кода, когда значение переменной n преобразуется к целому числу. Если это невозможно, то дальнейшее выполнение выражений в теле try прекращается. В данном случае выражение print("Удачно") выполнено не будет. При этом поток выполнения программы перейдет на ветку except и выполнит ее тело.

Если в теле try исключения не возникает, то тело ветки except не выполняется.

Вот пример вывода программы, когда пользователь вводит целое число:

```
Введите целое число: 100
Удачно
```

А здесь – когда вводит не то, что ожидалось:

```
Введите целое число: AA
Что-то пошло не так
```

Есть одна проблема. Код выше обработает любое исключение. Однако в теле try могут возникать разные исключения, и у каждого из них должен быть свой обработчик. Поэтому более правильным является указание типа исключения после ключевого слова except.

```py
try:
    n = input('Введите целое число: ')
    n = int(n)
    print("Все нормально. Вы ввели число", n)
except ValueError:
    print("Вы ввели не целое число")
```

Теперь если сработает тело except мы точно знаем, из-за чего возникла ошибка. Но если в теле try возникнет еще какое-нибудь исключение, то оно не будет обработано. Для него надо написать отдельную ветку except. Рассмотрим программу:

```py
try:
    a = float(input("Введите делимое: "))
    b = float(input("Введите делитель: "))
    c = a / b
    print("Частное: %.2f" % c)
except ValueError:
    print("Нельзя вводить строки")
except ZeroDivisionError:
    print("Нельзя делить на ноль")
```

При ее выполнении исключения могут возникнуть в трех строчках кода: где происходит преобразование введенных значений к вещественным числам и в месте, где происходит деление. В первом случае может возникнуть ValueError, во втором – ZeroDivisionError. Каждый тип исключения обрабатывается своей веткой except.

Несколько исключений можно сгруппировать в одну ветку и обработать совместно:

```py
try:
    a = float(input("Введите делимое: "))
    b = float(input("Введите делитель: "))
    c = a / b
    print("Частное: %.2f" % c)
except (ValueError, ZeroDivisionError):
    print("Нельзя вводить строки или делить на ноль")
```

У оператора обработки исключений, кроме except, могут быть еще ветки **finally** и **else** (не обязательно обе сразу). Тело finally выполняется всегда, независимо от того, выполнялись ли блоки except в ответ на возникшие исключения или нет. Обычно его используют при работе с файлами, когда необходимо в любом случае закрыть файл.
Тело else сработает, если исключений в try не было, т.е. не было переходов на блоки except.

```py
try:
    n = input('Введите целое число: ')
    n = int(n)
except ValueError:
    print("Вы что-то попутали с вводом")
else: # выполняется, когда в блоке try не возникло исключения
    print("Все нормально. Вы ввели число", n)
finally: # выполняется в любом случае
    print("Конец программы")
```

Посмотрите, как выполняется программа в случае возникновения исключения и без этого:

```
python test.py
Введите целое число: 4.3
Вы что-то попутали с вводом
Конец программы
```

```
python test.py
Введите целое число: 4
Все нормально. Вы ввели число 4
Конец программы
```

В данном уроке изложены не все особенности обработки исключений. Так в более крупных программах, содержащих несколько уровней вложенности кода, функции, модули и классы, исключения могут обрабатываться не по месту их возникновения, а передаваться дальше по иерархии вызовов.

Также исключение может возникнуть в блоке except, else или finally, и тогда им нужен собственный обработчик. Модифицируем немного предыдущую программу и специально сгенерируем исключение в теле except:

```py
try:
    n = input('Введите целое число: ')
    n = int(n)
except ValueError:
    print("Вы что-то попутали с вводом")
    3 / 0
except ZeroDivisionError:
    print("Деление на ноль")
else:
    print("Все нормально. Вы ввели число", n)
finally:
    print("Конец программы")
```

Поначалу может показаться, что все нормально. Исключение, генерируемое выражением 3 / 0 будет обработано веткой except ZeroDivisionError. Однако это не так. Эта ветка обрабатывает только исключения, возникающие в блоке try, к которому она сама относится. Вот вывод программы, если ввести не целое число:

```
Введите целое число: а
Вы что-то попутали с вводом
Конец программы
Traceback (most recent call last):
File "test.py", line 15, in <module>
n = int(n)
 
ValueError: invalid literal for int() with base 10: 'а'
 
During handling of the above exception, another exception occurred:
 
Traceback (most recent call last):
File "test.py", line 18, in <module>
3 / 0
ZeroDivisionError: division by zero
```

Мало того, что не было обработано деление на ноль, поскольку тело except ValueError неудачно завершилось, само исключение ValueError посчиталось необработанным. Решение проблемы может быть, например, таким:

```py
...
except ValueError:
    print("Вы что-то попутали с вводом")
    try:
       3 / 0
    except ZeroDivisionError:
        print("Деление на ноль")
```

Здесь в тело except вложен свой внутренний обработчик исключений.

## Вызов исключений
При работе с исключениями программист тратит большую часть времени на обработку, но при этом возникают ситуации, когда исключениями надо и бросать в других.

На сленге программистов "бросить исключение" означает написать код, который при исполнении будет инициировать исключительную ситуацию.

Например, функция, которая решает квадратное уравнение. Вы условились, что корни только вещественные, тогда в случае комплексных корней стоит бросить исключение.

Чтобы бросить исключение необходимо воспользоваться raise

Пример:

```
raise IOError("текст исключения")
где IOError это класс исключения.
```

Если при обработке исключения вы желаете пробросить его еще выше, то следует написать такой код:

```py
try:
    your_code
except Exception as e:
    raise
```

## Собственные исключения
При написании собственных программ разумное желание добавить выразительности коду, а так же обратить других программистов на особые исключительные ситуации. Для решения этой задачи стоит использовать собственные исключения.

В минимальном исполнении необходимо наследоваться от какого-нибудь класса в иерархии исключений. Например так:

```py
class MyException(Exception):
    pass
```

Тогда можно бросить свое исключение:

``raise MyException('текст исключения')``

Легко заметить, мы создаем класс, а значит все, что мы знаем о классах справедливо и для исключений. Можно завести переменные и делать их обработку. 

```py
class ShortInputException(Exception):
    # в конструкторе своего исключения предусматриваем параметры 
    def __init__(self, length, atleast):
        Exception.__init__(self)
        self.length = length
        self.atleast = atleast

try:
    text = input('Введите что-нибудь --> ')
    if len(text) < 3:
        raise ShortInputException(len(text), 3)
    # Здесь может происходить обычная работа
except ShortInputException as ex:
    print('ShortInputException: Длина введённой строки - {0}; \
           ожидалось, как минимум, {1}'.format(ex.length, ex.atleast))
else:
    print('Не было исключений.')        
```        

Как это работает:

Здесь мы создаём наш собственный тип исключения. Этот новый тип исключения называется ShortInputException. Он содержит два поля: length, хранящее длину введённого текста, и atleast, указывающее, какую минимальную длину текста ожидала программа.

В пункте except мы указываем класс ошибки ShortInputException, который будет сохранён как переменная ex, содержащая соответствующий объект ошибки/исключения. Это аналогично параметрам и аргументам при вызове функции. Внутри этого пункта except мы используем поля length и atleast объекта исключения для вывода необходимых сообщений пользователю.

## Утверждения (assert)
Используется для проверки истинности указанного утверждения.

Инструкция **assert** позволяет производить проверки истинности утверждений, что может быть использовано в отладочных целях.

Если проверка не прошла, возбуждается исключение AssertionError.

Рекомендуется использовать инструкцию только для проверки внутреннего состояния программы — ситуаций, которые не должны происходить вовсе, которые нельзя обработать или это не имеет смысла (обычно это является указанием на то, что код программы содержит ошибку). Инструкция также может использоваться для документирования ожиданий (например, входных параметров или результата). В остальных случаях следует определять свои типы исключений.

```py
passed = False

assert passed, 'Not passed'
# Поднимается исключение.
# assert passed  
# # Можно и не указывать текст описания, но рекомендуется.

# Запись выше эквивалентна следующей конструкции:
if __debug__:
    if not passed: 
        raise AssertionError('Not passed')
```

>В текущей реализации \_\_debug\_\_ — встроенная константа, по умолчанию имеющая значение True. Если интерпретатор запущен в режиме оптимизации (с флагом командной строки -O), значение константы становится False, а генератор кода перестаёт производить байткод для рассматриваемой инструкции. Таким образом, отключив проверки, но не убирая их из кода, можно снизить неизбежные для них накладные расходы.

## Декораторы
Тема скопипастена с хабра: https://habr.com/ru/post/141411/, https://habr.com/ru/post/141501/

Пример работы декораторов:

```py
def makebold(fn):
    def wrapped():
        return "<b>" + fn() + "</b>"
    return wrapped
 
def makeitalic(fn):
    def wrapped():
        return "<i>" + fn() + "</i>"
    return wrapped
 
@makebold
@makeitalic
def hello():
    return "hello habr"
 
print hello() ## выведет <b><i>hello habr</i></b>
```

Для того, чтобы понять, как работают декораторы, в первую очередь следует осознать, что в Python'е функции — это тоже объекты.

Давайте посмотрим, что из этого следует:

```py
def shout(word="да"):
    return word.capitalize()+"!"
 
print( shout() )
# выведет: 'Да!'
``` 

Так как функция - это объект, вы можете связать её с переменнной,
как и любой другой объект

``scream = shout``
 
Заметьте, что мы не используем скобок: мы НЕ вызываем функцию "shout",
мы связываем её с переменной "scream". Это означает, что теперь мы
можем вызывать "shout" через "scream":

```py
print scream()
# выведет: 'Да!'
```

Более того, это значит, что мы можем удалить "shout", и функция всё ещё
будет доступна через переменную "scream"

```py 
del shout
try:
    print( shout() )
except NameError, e:
    print(e)
    #выведет: "name 'shout' is not defined"
 
print( scream() )
# выведет: 'Да!'
```

Запомним этот факт, скоро мы к нему вернёмся, но кроме того, стоит понимать, что функция в Python'e может быть определена… внутри другой функции!

```py
def talk():
    # Внутри определения функции "talk" мы можем определить другую...
    def whisper(word="да"):
        return word.lower()+"...";
 
    # ... и сразу же её использовать!
    print( whisper() )

# Теперь, КАЖДЫЙ РАЗ при вызове "talk", внутри неё определяется а затем
# и вызывается функция "whisper".
talk()
# выведет: "да..."
 
# Но вне функции "talk" НЕ существует никакой функции "whisper":
try:
    print( whisper() )
except NameError, e:
    print e
    #выведет : "name 'whisper' is not defined"
```

### Ссылки на функции
Теперь мы знаем, что функции являются полноправными объектами, а значит:
* могут быть связаны с переменной;
* могут быть определены одна внутри другой.

Что ж, а это значит, что одна функция может вернуть другую функцию!
Давайте посмотрим:

```py
def getTalk(type="shout"):
 
    # Мы определяем функции прямо здесь
    def shout(word="да"):
        return word.capitalize()+"!"
 
    def whisper(word="да") :
        return word.lower()+"...";
 
    # Затем возвращаем необходимую
    if type == "shout":
        # Заметьте, что мы НЕ используем "()", нам нужно не вызвать функцию,
        # а вернуть объект функции
        return shout
    else:
        return whisper
 
# Как использовать это непонятное нечто?
# Возьмём функцию и свяжем её с переменной
talk = getTalk()
 
# Как мы можем видеть, "talk" теперь - объект "function":
print(talk)
# выведет: <function shout at 0xb7ea817c>
 
# Который можно вызывать, как и функцию, определённую "обычным образом":
print( talk() )
 
# Если нам захочется - можно вызвать её напрямую из возвращаемого значения:
print( getTalk("whisper")() )
# выведет: да...
```

Раз мы можем возвращать функцию, значит, мы можем и передавать её другой функции, как параметр:

```py
def doSomethingBefore(func):
    print("Я делаю что-то ещё, перед тем как вызвать функцию, которую ты мне передал")
    print(func())
 
doSomethingBefore(scream)
# Я делаю что-то ещё, перед тем как вызвать функцию, которую ты мне передал
# Да!
```

Ну что, теперь у нас есть все необходимые знания для того, чтобы понять, как работают декораторы.

Как вы могли догадаться, декораторы — это, по сути, просто своеобразные «обёртки», которые дают нам возможность делать что-либо до и после того, что сделает декорируемая функция, не изменяя её.

Создадим свой декоратор «вручную»

```py
# Декоратор - это функция, ожидающая ДРУГУЮ функцию в качестве параметра
def my_shiny_new_decorator(a_function_to_decorate):
    # Внутри себя декоратор определяет функцию-"обёртку".
    # Она будет (что бы вы думали?..) обёрнута вокруг декорируемой,
    # получая возможность исполнять произвольный код до и после неё.

    def the_wrapper_around_the_original_function():
        # Поместим здесь код, который мы хотим запускать ДО вызова
        # оригинальной функции
        print("Я - код, который отработает до вызова функции")
 
        # ВЫЗОВЕМ саму декорируемую функцию
        a_function_to_decorate()

        # А здесь поместим код, который мы хотим запускать ПОСЛЕ вызова
        # оригинальной функции
        print("А я - код, срабатывающий после")

    # На данный момент функция "a_function_to_decorate" НЕ ВЫЗЫВАЛАСЬ НИ РАЗУ

    # Теперь, вернём функцию-обёртку, которая содержит в себе
    # декорируемую функцию, и код, который необходимо выполнить до и после.
    # Всё просто!
    return the_wrapper_around_the_original_function

# Представим теперь, что у нас есть функция, которую мы не планируем больше трогать.
def a_stand_alone_function():
    print("Я простая одинокая функция, ты ведь не посмеешь меня изменять?..")
 
a_stand_alone_function()
# выведет: Я простая одинокая функция, ты ведь не посмеешь меня изменять?..
 
# Однако, чтобы изменить её поведение, мы можем декорировать её, то есть
# Просто передать декоратору, который обернет исходную функцию в любой код,
# который нам потребуется, и вернёт новую, готовую к использованию функцию:
 
a_stand_alone_function_decorated = my_shiny_new_decorator(a_stand_alone_function)

a_stand_alone_function_decorated()
#выведет:
# Я - код, который отработает до вызова функции
# Я простая одинокая функция, ты ведь не посмеешь меня изменять?..
# А я - код, срабатывающий после
```

Наверное, теперь мы бы хотели, чтобы каждый раз, во время вызова ``a_stand_alone_function``, вместо неё вызывалась ``a_stand_alone_function_decorated``. Нет ничего проще, просто перезапишем ``a_stand_alone_function`` функцией, которую нам вернул ``my_shiny_new_decorator``:

```py
a_stand_alone_function = my_shiny_new_decorator(a_stand_alone_function)
a_stand_alone_function()
#выведет:
# Я - код, который отработает до вызова функции
# Я простая одинокая функция, ты ведь не посмеешь меня изменять?..
# А я - код, срабатывающий после
```

Вы ведь уже догадались, что это ровно тоже самое, что делают @декораторы.

### Разрушаем ореол таинственности вокруг декораторов

Вот так можно было записать предыдущий пример, используя синтаксис декораторов:

```py
@my_shiny_new_decorator
def another_stand_alone_function():
    print "Оставь меня в покое"
 
another_stand_alone_function()
#выведет:
# Я - код, который отработает до вызова функции
# Оставь меня в покое
# А я - код, срабатывающий после
```

Да, всё действительно так просто! decorator — просто синтаксический сахар для конструкций вида:

``another_stand_alone_function = my_shiny_new_decorator(another_stand_alone_function)``

Декораторы — это просто pythonic-реализация паттерна проектирования «Декоратор». В Python включены некоторые классические паттерны проектирования, такие как рассматриваемые в этой статье декораторы, или привычные любому питонисту итераторы.

Конечно, можно вкладывать декораторы друг в друга, например так:

```py
def bread(func):
    def wrapper():
        print "</------\>"
        func()
        print "<\______/>"
    return wrapper
 
def ingredients(func):
    def wrapper():
        print "#помидоры#"
        func()
        print "~салат~"
    return wrapper
 
def sandwich(food="--ветчина--"):
    print food
 
sandwich()
#выведет: --ветчина--
sandwich = bread(ingredients(sandwich))
sandwich()
#выведет:
# </------\>
# #помидоры#
# --ветчина--
# ~салат~
# <\______/>
```

И используя синтаксис декораторов:

```py
@bread
@ingredients
def sandwich(food="--ветчина--"):
    print food
 
sandwich()
#выведет:
# </------\>
# #помидоры#
# --ветчина--
# ~салат~
# <\______/>
```

Следует помнить о том, что порядок декорирования ВАЖЕН:

```py
@ingredients
@bread
def sandwich(food="--ветчина--"):
    print food
 
sandwich()
#выведет:
# #помидоры#
# </------\>
# --ветчина--
# <\______/>
# ~салат~
```

### Передача («проброс») аргументов в декорируемую функцию
Никакой чёрной магии, всё, что нам необходимо — собственно, передать аргументы дальше!

```py
def a_decorator_passing_arguments(function_to_decorate):
    def a_wrapper_accepting_arguments(arg1, arg2): # аргументы прибывают отсюда
        print("Смотри, что я получил:", arg1, arg2)
        function_to_decorate(arg1, arg2)
    return a_wrapper_accepting_arguments
 
# Теперь, когда мы вызываем функцию, которую возвращает декоратор,
# мы вызываем её "обёртку", передаём ей аргументы и уже в свою очередь
# она передаёт их декорируемой функции
 
@a_decorator_passing_arguments
def print_full_name(first_name, last_name):
    print "Меня зовут", first_name, last_name
 
print_full_name("Питер", "Венкман")
# выведет:
# Смотри, что я получил: Питер Венкман
# Меня зовут Питер Венкман
```

Для чего мы изучали декораторы именно в теме про исключения? Дело в том что с их помощью можно реализовать несколько приятных плюшек:

### Логгирование исключений
Декоратор реализующий логгирование исключений. Чтобы не писать в каждой своей функции перехват исключений, можно реализовать декоратор:

```py
def log_error(fun_to_decorate):
  def wrapped(*args, **kwargs):
    try:
      return fun_to_decorate(*args, **kwargs)
    except Exception as e:
      print(e)
      raise
  return wrapped    


@log_error
def some_function():
  raise Exception('что-то случилось')

some_function()
```

Так как мы заранее не знаем сколько параметров будет у декорируемой функции, то используем стандартную фишку питона: ``*args, **kwargs``, распаковываем список и словарь аргументов.

### Работа с временной ошибкой
Некоторые ошибки являются временными, в частности при работе с распределенными системами. Система, которая начинает ругаться при первом признаке ошибки не очень полезна.

Следующий декоратор делает несколько попыток получить результат, и только при превышении заложенного количества попыток выдает исключение (декорируемя функция должна возвращать True или False, чтобы декоратор знал когда функция успешно завершилась):

```py
import time
import math
 
# обёртка над декоратором, которая принимает параметры для декоратора
def retry(tries, delay=3, backoff=2):
  '''Повторяет вызов декорируемой функции пока та не вернет "True".

  tries - количество попыток, должно быть > 0
  delay - начальная задержка в секундах между повторами
  backoff - множитель для задержки, должен быть >= 1'''
 
  if backoff <= 1:
    raise ValueError("backoff болжен быть больше 1")
 
  # округляет в большую сторону, если вдруг передали float
  tries = math.floor(tries)
 
  if tries < 1:
    raise ValueError("tries должен быть больше 0")
 
  if delay < 1:
     raise ValueError("delay должен быть больше 0")
  
  # собственно декоратор
  def deco_retry(fun_to_decorate):
    def f_retry(*args, **kwargs):
      mtries, mdelay = tries, delay # make mutable
 
      # пока не исчерпали количество попыток
      while mtries > 0:
        print('осталось попыток {}, задержка {}'.format(mtries, mdelay))  
        rv = fun_to_decorate(*args, **kwargs) 
        # если все нормально - выходим
        if rv is True: 
          return True

        # декрементируем количество попыток
        mtries -= 1
        # приостанавливаем выполнение
        time.sleep(mdelay)
        # следующая задержка будет больше
        mdelay *= backoff
 
      #раз досюда дошли, значит так и не достучались до ресурса 
      return False
 
    return f_retry
 
  return deco_retry


@retry(3, 1, 2)
def some_fun():
    return False

some_fun()
```

в результате получим:

```
осталось попыток 3, задержка 1
осталось попыток 2, задержка 2
осталось попыток 1, задержка 4
```

[содержание](/readme.md)  