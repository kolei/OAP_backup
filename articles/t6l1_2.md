# Тема 6. Основные принципы объектно-ориентированного программирования</br>Лекции 1 и 2

## История развития ООП
Термины «объектно-» и «ориентированный» в современном смысле этих слов появились в MIT в конце 1950 начале 1960 годов. В среде специалистов по искусственному интеллекту термин «объект» мог относиться к идентифицированным элементам (атомы Lisp) со свойствами (атрибутами). Алан Кэй позже писал, что понимание внутреннего устройства Лиспа оказало серьезное влияние на его мышление в 1966 г. Другим ранним примером ООП в MIT был Sketchpad созданный Иваном Сазерлендом в 1960-61. В глоссарии подготовленного в 1963 г. технического отчета, основанного на его диссертации о Sketchpad, Сазерленд определяет понятия «объект» и «экземпляр» с концепцией классов на основе «мастера» или «определения», хотя все эти термины относились к графическому представлению объектов [вкратце, в Sketchpad было основное изображение, на основе которого строились копии. При изменении основного – копии тоже менялись. Прим. пер.].

В ранней MIT-версии ALGOL AED-0 структуры данных («плексы» на диалекте Алгола) напрямую были связаны с процедурами, которые впоследствии были названы сообщениями, методами или функциями-членами.

Объекты, как формализованный концепт появились в программировании в 1960-х в Simula 67, модернизированной версии Simula I, языка программирования, ориентированного на дискретно-событийное моделирование. Авторы Simula — Оле-Йохан Даль и Кристен Нюгорд из Норвежского компьютерного центра в Осло. Simula разрабатывалась под влиянием SIMSCRIPT и предложенной Чарльзом Хоаром концепцией записей-классов. Simula включала в себя понятие классов и экземпляров (или объектов), а также подклассов, виртуальных методов, сопрограмм и дискретно-событийное моделирование как часть собственной парадигмы программирования. В языке использовался автоматический сборщик мусора, который был изобретен ранее для функционального языка Lisp. Simula использовалась тогда преимущественно для физического моделирования. Идеи Simula оказали серьезное влияние на более поздние языки, такие как Smalltalk, варианты Lisp (CLOS), Object Pascal, и C++.

Язык Smalltalk, который был изобретен в компании Xerox PARC Аланом Кэем (Alan Kay) и некоторыми другими учеными, фактически навязывал использование «объектов» и «сообщений» как базиса для вычислений. Создателей Smalltalk вдохновляли некоторые идеи Simula, но Smalltalk разрабатывался как полностью динамичная система, в которой классы могут создаваться и изменяться динамически, а не только статически как в Simula. Smalltalk и ООП с его помощью были представлены широкой аудитории в журнале Byte magazine в августе 1981.

В 1970-х Smalltalk Кэя сподвиг сообщество Lisp внедрить в язык объектно-ориентированные техники, которые были представлены разработчикам с помощью Lisp машины.

Эксперименты с различными расширениями Lisp в конечном итоге привели к созданию Common Lisp Object System (CLOS, части первого стандартизованного объектно-ориентированного языка, ANSI Common Lisp), который органично включал в себя как функциональное, так и объектно-ориентированное программирование и позволял расширять себя с помощью протокола Meta-object protocol. В 1980 было несколько попыток дизайна архитектур процессоров, которые включали бы в себя аппаратную поддержку работы с объектами в памяти, но все они были безуспешны. В качестве примеров можно привести Intel iAPX 432 и Linn Smart Rekursiv.

Объектно-ориентированное программирование развилось в доминирующую методологию программирования в начале и середине 1990 годов, когда стали широко доступны поддерживающие ее языки программирования, такие как Visual FoxPro 3.0, C++, и Delphi. Доминирование этой системы поддерживалось ростом популярности графических интерфейсов пользователя, которые основывались на техниках ООП. Пример тесной связи между динамической библиотекой GUI и объектно-ориентированного языка программирования можно найти посмотрев на фреймворк Cocoa на Mac OS X, который был написан на Objective-C, объектно-ориентированом расширении к С, основанном на Smalltalk с поддержкой динамических сообщений. Инструментарии ООП повлияли на популярность событийно-ориентированного программирования (хотя, эта концепция не ограничивается одним ООП). Некоторые даже думали, что кажущаяся или реальная связь с графическими интерфейсами – это то, что вынесло ООП на передний план технологий.

В ETH Zürich, Никлаус Вирт и его коллеги тоже исследовали такие предметы, как абстрация данных и модульное программирование, хотя эти подходы широко использовались и в 60-х и ранее. Modula-2 вышедшая в 1978 включала оба эти подхода, а ее последователь Oberon имел собственный подход к объктно-ориентированности, классам и прочему, непохожий на подход Smalltalk и совсем не похожий на подход C++.

Возможности ООП добавлялись во многие языки того времени, включая Ada, BASIC, Fortran, Pascal и другие. Их добавление в языки, изначально не разрабатывавшиеся для поддержки ООП часто приводило к проблемам с совместимостью и поддержкой кода.

Позднее стали появляться языки, поддерживающие как объектно-ориентированный подход, так и процедурный вроде Python и Ruby. Пожалуй, самыми коммерчески успешными объектно-ориентированными языками можно назвать Visual Basic.NET, C# и Java. И .NET и Java демонстрируют превосходство ООП.

## Базовые понятия: объект, его свойства и методы, класс, интерфейс. 

### Класс
Представьте себе, что вы проектируете автомобиль. Вы знаете, что автомобиль должен содержать двигатель, подвеску, две передних фары, 4 колеса, и т.д. Ещё вы знаете, что ваш автомобиль должен иметь возможность набирать и сбавлять скорость, совершать поворот и двигаться задним ходом. И, что самое главное, вы точно знаете, как взаимодействует двигатель и колёса, согласно каким законам движется распредвал и коленвал, а также как устроены дифференциалы. Вы уверены в своих знаниях и начинаете проектирование. 

Вы описываете все запчасти, из которых состоит ваш автомобиль, а также то, каким образом эти запчасти взаимодействуют между собой. Кроме того, вы описываете, что должен сделать пользователь, чтобы машина затормозила, или включился дальний свет фар. Результатом вашей работы будет некоторый эскиз. Вы только что разработали то, что в ООП называется класс.

**Класс** – это способ описания сущности, определяющий состояние и поведение, зависящее от этого состояния, а также правила для взаимодействия с данной сущностью (контракт). 

С точки зрения программирования класс можно рассматривать как набор данных (полей, атрибутов, членов класса) и функций для работы с ними (методов).

С точки зрения структуры программы, класс является сложным типом данных.

В нашем случае, класс будет отображать сущность – автомобиль. **Атрибутами** класса будут являться двигатель, подвеска, кузов, четыре колеса и т.д. **Методами** класса будет «открыть дверь», «нажать на педаль газа», а также «закачать порцию бензина из бензобака в двигатель». Первые два метода доступны для выполнения другим классам (в частности, классу «Водитель»). Последний описывает взаимодействия внутри класса и не доступен пользователю.

В дальнейшем мы будем называть пользователями тех программистов, которые используют ваш класс, включая вас самих. Человека, который является автором класса, мы будем называть разработчиком.

## Объект
Вы отлично потрудились и машины, разработанные по вашим чертежам, сходят с конвейера. Вот они, стоят ровными рядами на заводском дворе. Каждая из них точно повторяет ваши чертежи. Все системы взаимодействуют именно так, как вы спроектировали. Но каждая машина уникальна. Они все имеют номер кузова и двигателя, но все эти номера разные, автомобили различаются цветом, а некоторые даже имеют литьё вместо штампованных дисков. Эти автомобили, по сути, являются объектами вашего класса.

**Объект** (экземпляр) – это отдельный представитель класса, имеющий конкретное состояние и поведение, полностью определяемое классом.

Говоря простым языком, объект имеет конкретные значения атрибутов и методы, работающие с этими значениями на основе правил, заданных в классе. В данном примере, если класс – это некоторый абстрактный автомобиль из «мира идей», то объект – это конкретный автомобиль, стоящий у вас под окнами.

## Интерфейс
Когда мы подходим к автомату с кофе или садимся за руль, мы начинаем взаимодействие с ними. Обычно, взаимодействие происходит с помощью некоторого набора элементов: щель для приёмки монеток, кнопка выбора напитка и отсек выдачи стакана в кофейном автомате; руль, педали, рычаг коробки переключения передач в автомобиле. Всегда существует некоторый ограниченный набор элементов управления, с которыми мы можем взаимодействовать.

**Интерфейс** – это набор методов класса, доступных для использования другими классами. 

Очевидно, что интерфейсом класса будет являться набор всех его публичных методов в совокупности с набором публичных атрибутов. По сути, интерфейс специфицирует класс, чётко определяя все возможные действия над ним. 

Хорошим примером интерфейса может служить приборная панель автомобиля, которая позволяет вызвать такие методы, как увеличение скорости, торможение, поворот, переключение передач, включение фар, и т.п. То есть все действия, которые может осуществить другой класс (в нашем случае – водитель) при взаимодействии с автомобилем.

При описании интерфейса класса очень важно соблюсти баланс между гибкостью и простотой. Класс с простым интерфейсом будет легко использовать, но будут существовать задачи, которые с помощью него решить будет не под силу. В то же время, если интерфейс будет гибким, то, скорее всего, он будет состоять из достаточно сложных методов с большим количеством параметров, которые будут позволять делать очень многое, но использование его будет сопряжено с большими сложностями и риском совершить ошибку, что-то перепутав.

Примером простого интерфейса может служить машина с коробкой-автоматом. Освоить её управление очень быстро сможет любая блондинка, окончившая двухнедельные курсы вождения. С другой стороны, чтобы освоить управление современным пассажирским самолётом, необходимо несколько месяцев, а то и лет упорных тренировок.

## Основные принципы ООП: инкапсуляция, наследование, полиморфизм.

### Инкапсуляция
Представим на минутку, что мы оказались в конце позапрошлого века, когда Генри Форд ещё не придумал конвейер, а первые попытки создать автомобиль сталкивались с критикой властей по поводу того, что эти коптящие монстры загрязняют воздух и пугают лошадей. Представим, что для управления первым паровым автомобилем необходимо было знать, как устроен паровой котёл, постоянно подбрасывать уголь, следить за температурой, уровнем воды. При этом для поворота колёс использовать два рычага, каждый из которых поворачивает одно колесо в отдельности. Думаю, можно согласиться с тем, что вождение автомобиля того времени было весьма неудобным и трудным занятием.

Теперь вернёмся в сегодняшний день к современным чудесам автопрома с коробкой-автоматом. На самом деле, по сути, ничего не изменилось. Бензонасос всё так же поставляет бензин в двигатель, дифференциалы обеспечивают поворот колёс на различающиеся углы, коленвал превращает поступательное движение поршня во вращательное движение колёс. Прогресс в другом. Сейчас все эти действия скрыты от пользователя и позволяют ему крутить руль и нажимать на педаль газа, не задумываясь, что в это время происходит с инжектором, дроссельной заслонкой и распредвалом. Именно сокрытие внутренних процессов, происходящих в автомобиле, позволяет эффективно его использовать даже тем, кто не является профессионалом-автомехаником с двадцатилетним стажем. Это сокрытие в ООП носит название **инкапсуляции**.

**Инкапсуляция** – это свойство системы, позволяющее объединить **данные** и **методы**, работающие с ними, в классе и скрыть детали 
реализации от пользователя.

Инкапсуляция неразрывно связана с понятием интерфейса класса. По сути, всё то, что не входит в интерфейс, инкапсулируется в классе.

**Абстракция**

Представьте, что водитель едет в автомобиле по оживлённому участку движения. Понятно, что в этот момент он не будет задумываться о химическом составе краски автомобиля, особенностях взаимодействия шестерён в коробке передач или влияния формы кузова на скорость (разве что, автомобиль стоит в глухой пробке и водителю абсолютно нечем заняться). Однако, руль, педали, указатель поворота (ну и, возможно, пепельницу) он будет использовать регулярно.

Абстрагирование – это способ выделить набор значимых характеристик объекта, исключая из рассмотрения незначимые. Соответственно, абстракция – это набор всех таких характеристик.

Если бы для моделирования поведения автомобиля приходилось учитывать химический состав краски кузова и удельную теплоёмкость лампочки подсветки номеров, мы никогда бы не узнали, что такое NFS.

### Полиморфизм
Любое обучение вождению не имело бы смысла, если бы человек, научившийся водить, скажем, ВАЗ 2106 не мог потом водить ВАЗ 2110 или BMW X3. С другой стороны, трудно представить человека, который смог бы нормально управлять автомобилем, в котором педаль газа находится левее педали тормоза, а вместо руля – джойстик. 

Всё дело в том, что основные элементы управления автомобиля имеют одну и ту же конструкцию и принцип действия. Водитель точно знает, что для того, чтобы повернуть налево, он должен повернуть руль, независимо от того, есть там гидроусилитель или нет. 

Если человеку надо доехать с работы до дома, то он сядет за руль автомобиля и будет выполнять одни и те же действия, независимо от того, какой именно тип автомобиля он использует. По сути, можно сказать, что все автомобили имеют один и тот же интерфейс, а водитель, абстрагируясь от сущности автомобиля, работает именно с этим интерфейсом. Если водителю предстоит ехать по немецкому автобану, он, вероятно выберет быстрый автомобиль с низкой посадкой, а если предстоит возвращаться из отдалённого маральника в Горном Алтае после дождя, скорее всего, будет выбран УАЗ с армейскими мостами. Но, независимо от того, каким образом будет реализовываться движение и внутреннее функционирование машины, интерфейс останется прежним.

**Полиморфизм** – это свойство системы использовать объекты с одинаковым интерфейсом без информации о типе и внутренней структуре объекта.

Например, если вы читаете данные из файла, то, очевидно, в классе, реализующем файловый поток, будет присутствовать метод похожий на следующий: 
``fh.read(n: int)->bytes``
Предположим теперь, что вам необходимо считывать те же данные из сокета. В классе, реализующем сокет, также будет присутствовать метод read. Достаточно заменить в вашей системе объект одного класса на объект другого класса, и результат будет достигнут.

При этом логика системы может быть реализована независимо от того, будут ли данные прочитаны из файла или получены по сети. Таким образом, мы абстрагируемся от конкретной специализации получения данных и работаем на уровне интерфейса. Единственное требование при этом – чтобы каждый используемый объект имел метод read.

### Наследование
Представим себя, на минуту, инженерами автомобильного завода. Нашей задачей является разработка современного автомобиля. У нас уже есть предыдущая модель, которая отлично зарекомендовала себя в течение многолетнего использования. Всё бы хорошо, но времена и технологии меняются, а наш современный завод должен стремиться повышать удобство и комфорт выпускаемой продукции и соответствовать современным стандартам.

Нам необходимо выпустить целый модельный ряд автомобилей: седан, универсал и малолитражный хэтч-бэк. Очевидно, что мы не собираемся проектировать новый автомобиль с нуля, а, взяв за основу предыдущее поколение, внесём ряд конструктивных изменений. Например, добавим гидроусилитель руля и уменьшим зазоры между крыльями и крышкой капота, поставим противотуманные фонари. Кроме того, в каждой модели будет изменена форма кузова.

Очевидно, что все три модификации будут иметь большинство свойств прежней модели (старый добрый двигатель 1970 года, непробиваемая ходовая часть, зарекомендовавшая себя отличным образом на отечественных дорогах, коробку передач и т.д.). При этом каждая из моделей будет реализовать некоторую новую функциональность или конструктивную особенность. В данном случае, мы имеем дело с наследованием.

**Наследование** – это свойство системы, позволяющее описать новый класс на основе уже существующего с частично или полностью заимствующейся функциональностью. Класс, от которого производится наследование, называется базовым или родительским. Новый класс – потомком, наследником или производным классом.

Необходимо отметить, что производный класс полностью удовлетворяет спецификации родительского, однако может иметь дополнительную функциональность. С точки зрения интерфейсов, каждый производный класс полностью реализует интерфейс родительского класса. Обратное не верно.

Действительно, в нашем примере мы могли бы произвести с новыми автомобилями все те же действия, что и со старым: увеличить или уменьшить скорость, повернуть, включить сигнал поворота. Однако, дополнительно у нас бы появилась возможность, например, включить противотуманные фонари.

Отсутствие обратной совместимости означает, что мы не должны ожидать от старой модели корректной реакции на такие действия, как включения противотуманок (которых просто нет в данной модели).

### От теории к практике
Язык Python – типичный представитель ООП-семейства, обладающий элегантной и мощной объектной моделью. В этом языке от объектов никуда не спрятаться (ведь даже числа являются ими), поэтому давайте разбираться, как это все реализовано.

#### Создавать классы в Python очень просто:

```py
class SomeClass(object):
  # поля и методы класса SomeClass
```

Классы-родители перечисляются в скобках через запятую:
```py
class SomeClass(ParentClass1, ParentClass2, …):
  # поля и методы класса SomeClass
```

*С реализацией наследования разберемся чуть позже.*

Свойства классов устанавливаются с помощью простого присваивания:
```py
class SomeClass(object):
  attr1 = 42
  attr2 = "Hello, World"
```

Методы объявляются как простые функции:

```py
class SomeClass(object):
  def method1(self, x):
    # код метода
```

Обратите внимание на первый аргумент – self – общепринятое имя для ссылки на объект, в контексте которого вызывается метод. Этот параметр обязателен и отличает метод класса от обычной функции.

Все пользовательские атрибуты сохраняются в атрибуте \_\_dict\_\_, который является словарем.

#### Экземпляры классов

Создать экземпляр класса в Python тоже очень просто:

```py
class SomeClass(object):
  attr1 = 42

  def method1(self, x):
    return 2*x

obj = SomeClass() # создание экземпляра класса
obj.method1(6) # 12
obj.attr1 # 42
```

Можно создавать разные экземпляры одного класса с заранее заданными параметрами с помощью инициализатора (специальный метод \_\_init\_\_). Для примера возьмем класс Point (точка пространства), объекты которого должны иметь определенные координаты:

```py
class Point(object):
  def __init__(self, x, y, z):
    self.coord = (x, y, z)

p = Point(13, 14, 15) # экземпляру класса передали переметры для инициализации
p.coord # (13, 14, 15)
```

*Подробнее о других специальных методах жизненного цикла объектов поговорим чуть ниже.*

#### Динамическое изменение
Можно обойтись даже без определения атрибутов и методов:

```py
class SomeClass(object):
  pass
```

Кажется, этот класс совершенно бесполезен? Отнюдь. Классы в Python могут динамически изменяться после определения:

```py
class SomeClass(object):
  pass

# это пока обычная функция
def squareMethod(self, x):
  return x*x

# а тут мы ее назначили методом класса
SomeClass.square = squareMethod
obj = SomeClass()
obj.square(5) # 25
```

#### Статические и классовые методы
Статическим называется метод, который может быть вызван без создания класса, т.е. он не использует других аттрибутов и методов класса, обычно в таких методах хранят константы или с их помощью реализуют некоторые шаблоны проектирования (о них поговорим позднее)

Для создания статических методов в Python предназначен декоратор @staticmethod. У них нет обязательных параметров-ссылок вроде self. Доступ к таким методам можно получить как из экземпляра класса, так и из самого  класса:

```py
class SomeClass(object):
  @staticmethod
  def hello():
    print("Hello, world")

SomeClass.hello() # Hello, world - вызвали метод не создавая экземпляра класса
obj = SomeClass()
obj.hello() # Hello, world - обычный вызов
```

Еще есть так называемые методы классов. Они аналогичны методам экземпляров, но выполняются не в контексте объекта, а в контексте самого класса  (классы – это тоже объекты). Такие методы создаются с помощью декоратора @classmethod и требуют обязательную ссылку на класс (cls).

```py
class SomeClass(object):
  @classmethod
  def hello(cls):
    print('Hello, класс {}'.format(cls.__name__))

SomeClass.hello() # Hello, класс SomeClass
```

Как уже отмечалось, статические и классовые методы доступны без создания экземпляра класса.

#### Специальные методы
Жизненный цикл объекта

С инициализатором объектов \_\_init\_\_ вы уже знакомы. Кроме него есть еще и метод \_\_new\_\_, который непосредственно создает новый экземпляр класса. Первым параметром он принимает ссылку на сам класс:

```py
class SomeClass(object):
  def __new__(cls):
    print("new")
    return super(SomeClass, cls).__new__(cls)

  def __init__(self):
    print("init")

obj = SomeClass()
# new
# init
```

Хотя метод \_\_new\_\_ написан без декоратора @classmethod, но по параметру cls, мы можем сами об этом догадаться.

Метод \_\_new\_\_ может быть очень полезен для решения ряда задач, например, создания иммутабельных (неизменяемых) объектов или реализации паттерна Синглтон.

```py
class Singleton(object):
  obj = None # единственный экземпляр класса

  def __new__(cls, *args, **kwargs):
    # если экземпляр класса уже создан, то возвращается ссылка на него
    if cls.obj is None:
      cls.obj = object.__new__(cls, *args, **kwargs)
    return cls.obj

single = Singleton()
single.attr = 42

newSingle = Singleton()
newSingle.attr # 42

newSingle is single # true
```

В Python вы можете поучаствовать не только в создании объекта, но и в его удалении. Специально для этого предназначен метод-деструктор \_\_del\_\_.

```py
class SomeClass(object):
  def __init__(self, name):
    self.name = name

  def __del__(self):
    print('удаляется объект {} класса SomeClass'.format(self.name))

obj = SomeClass("John");
del obj # удаляется объект John класса SomeClass
```

На практике деструктор используется редко, в основном для тех ресурсов, которые требуют явного освобождения памяти при удалении объекта (например, закрытие файлов). Не следует совершать в нем сложные вычисления.

#### Объект как функция
Объект класса может имитировать стандартную функцию, то есть при желании его можно «вызвать» с параметрами. За эту возможность отвечает специальный метод \_\_call\_\_:

```py
class Multiplier:
  def __call__(self, x, y):
    return x*y

multiply = Multiplier()
# не вызываем метод, а сразу передаем параметры объекту
multiply(19, 19) # 361
# то же самое
multiply.__call__(19, 19) # 361
```

#### Имитация контейнеров
Мы уже знакомы с функцией len(), которая умеет вычислять длину списков значений.

```py
list = ['hello', 'world']
len(list) # 2
```

Но для объектов вашего пользовательского класса это не пройдет:

```py
class Collection:
  def __init__(self, list):
    self.list = list

collection = Collection(list)
len(collection)
```

Этот код выдаст ошибку ``object of type 'Collection' has no len()``. Интерпретатор просто не понимает, как ему посчитать длину collection.

Решить эту проблему поможет специальный метод \_\_len\_\_:

```py
class Collection:
  def __init__(self, list):
    self.list = list

  def __len__(self):
    return len(self.list)

collection = Collection([1, 2, 3])
len(collection) # 3
```

Можно работать с объектом как с коллекцией значений, определив для него интерфейс классического списка с помощью специальных методов:

* \_\_getItem\_\_ – реализация синтаксиса obj[key], получение значения по ключу;
* \_\_setItem\_\_ – установка значения для ключа;
* \_\_delItem\_\_ – удаление значения;
* \_\_contains\_\_ – проверка наличия значения.

#### Имитация числовых типов
Ваши объекты могут участвовать в математических операциях, если у них определены  специальные методы. Например, __mul__ позволяет умножать объект на число по определенной программистом логике:

```py
class SomeClass:
  def __init__(self, value):
    self.value = value

  def __mul__(self, number):
    return self.value*number

obj = SomeClass(42)
print(obj * 100) # 4200
```

#### Другие специальные методы
В Python существует огромное количество специальных методов, расширяющих возможности пользовательских классов. Например, можно определить вид объекта на печати, его «официальное» строковое представление или поведение при сравнениях. Узнать о них подробнее вы можете в официальной документации языка.

Эти методы могут эмулировать поведение встроенных классов, но при этом они необязательно существуют у самих встроенных классов. Например, у объектов int при сложении не вызывается метод __add__. Таким образом, их нельзя переопределить.

***
Рассмотрим «большую тройку» объектно-ориентированной концепции: инкапсуляцию, полиморфизм и наследование на примере Питона.

#### Инкапсуляция
Все объекты в Python инкапсулируют внутри себя данные и методы работы с ними, предоставляя публичные интерфейсы для взаимодействия.

Атрибут может быть объявлен приватным (внутренним) с помощью нижнего подчеркивания перед именем, но настоящего скрытия на самом деле не происходит – все на уровне соглашений.

```py
class SomeClass:
  def _private(self):
    print("Это внутренний метод объекта")

obj = SomeClass()
obj._private() # это внутренний метод объекта
```

Если поставить перед именем атрибута два подчеркивания, к нему нельзя будет обратиться напрямую. Но все равно остается обходной путь:

```py
class SomeClass():
  def __init__(self):
    self.__param = 42 # защищенный атрибут

obj = SomeClass()
obj.__param # AttributeError: 'SomeClass' object has no attribute '__param'
# а если к имени защищенного атрибута добавить _ИмяКласса, то можно
obj._SomeClass__param # 42 
```

Специальные свойства и методы класса, некоторые из которых вам уже знакомы, имеют двойные подчеркивания до и после имени.

Кроме прямого доступа к атрибутам (obj.attrName), могут быть использованы специальные методы доступа (геттеры, сеттеры и деструкторы) (property в синтаксисе pascal):

```py
class SomeClass():
  def __init__(self, value):
    self._value = value

  def getvalue(self): # получение значения атрибута
    return self._value

  def setvalue(self, value): # установка значения атрибута
    self._value = value

  def delvalue(self): # удаление атрибута
    del self._value

  value = property(getvalue, setvalue, delvalue, "Свойство value")

obj = SomeClass(42)
print(obj.value)
obj.value = 43
```

Такой подход очень удобен, если получение или установка значения атрибута требует сложной логики.

Вместо того чтобы вручную создавать геттеры и сеттеры для каждого атрибута, можно перегрузить встроенные методы __getattr__, __setattr__ и __delattr__. Например, так можно перехватить обращение к свойствам и методам, которых в объекте не существует:

```py
class SomeClass():
  attr1 = 42

  def __getattr__(self, attr):
    return attr.upper()

obj = SomeClass()
obj.attr1 # 42 - тут вернуло аттрибут класса
obj.attr2 # ATTR2 - а тут обращение к несуществующему аттрибуту перехвачено и название "атрибута" перевели в верхний регистр
```

__getattribute__ перехватывает все обращения (в том числе и к существующим атрибутам):

```py
class SomeClass():
  attr1 = 42

  def __getattribute__(self, attr):
    return attr.upper()

obj = SomeClass()
obj.attr1 # ATTR1
obj.attr2 # ATTR2
```

Таким образом, можно организовать динамический доступ к методам и свойствам объекта, как действуют, например,  RPC-системы.

#### Наследование
Язык программирования Python реализует как стандартное **одиночное** наследование:

```ya
class Mammal():
  className = 'Mammal'

class Dog(Mammal):
  species = 'Canis lupus'

dog = Dog()
dog.className # Mammal
```

так и **множественное**:

```py
Python
class Horse():
  isHorse = True

class Donkey():
  def isDonkey = True

class Mule(Horse, Donkey):
  pass

mule = Mule()
mule.isHorse # True
mule.isDonkey # True
```

Используя множественное наследования можно создавать классы-миксины (примеси), представляющие собой определенную особенность поведения. Такой микси можно «примешать» к любому классу. Но в большинстве ЯП отказались от множественного наследования.

#### Ассоциация
Кроме наследования, существует и другой способ организации межклассового взаимодействия – ассоциация (агрегация или композиция), при которой один класс является полем другого.

Пример композиции:

```py
class Зарплата:
  def __init__(self,pay):
    self.pay = pay

  def getTotal(self):
    return (self.pay*12)

class Работник:
  def __init__(self,pay,bonus):
    self.pay = pay
    self.bonus = bonus
    self.salary = Зарплата(self.pay)

  def кВыплате(self):
    return "Total: " + str(self.salary.getTotal() + self.bonus)

работник = Работник(100, 10)
print(работник.кВыплате())
```

Пример агрегации:

```py
class Зарплата(object):
  def __init__(self, pay):
    self.pay = pay

  def getTotal(self):
    return (self.pay * 12)

class Работник(object):
  def __init__(self, pay, bonus):
    self.pay = pay
    self.bonus = bonus

  def кВыплате(self):
    return "Total: " + str(self.pay.getTotal() + self.bonus)

зарплата = Зарплата(100)
работник = Работник(зарплата, 10)
print(работник.кВыплате())
```

>Ассоциированные объекты могут циклически ссылаться друг на друга, что ломает стандартный механизм сборки мусора. Избежать подобных проблем при ассоциации помогают слабые ссылки (модуль weakref).

#### Полиморфизм
Концепция полиморфизма – важная часть ООП на Python. Все методы в языке изначально виртуальные. Это значит, что дочерние классы могут их переопределять и решать одну и ту же задачу разными путями, а конкретная реализация будет выбрана только во время исполнения программы. Такие классы называют полиморфными.

```py
class Млекопитающее:
  def move(self):
    print('Двигается')

class Заяц(Млекопитающее):
  def move(self):
    print('Прыгает')

animal = Млекопитающее()
animal.move() # Двигается

hare = Заяц()
hare.move() # Прыгает
```

Впрочем, можно получить и доступ к методам класса-предка либо по прямому обращению, либо с помощью функции super:

```py
class Родитель():
  def __init__(self):
    print('Parent init')

  def method(self):
    print('Parent method')

class Потомок(Родитель):
  def __init__(self):
    Родитель.__init__(self)

  def method(self):
    super(Потомок, self).method()

child = Потомок() # init Родител-я
child.method() # method Родител-я
```

Одинаковый интерфейс с разной реализацией могут иметь и классы, не связанные родственными узами. В следующем примере код может одинаково удобно работать с классами English и French, так как они обладают одинаковым интерфейсом:

```py
class English:
  def greeting(self):
    print ("Hello")

class French:
  def greeting(self):
    print ("Bonjour")

def intro(language):
  language.greeting()

john = English()
gerard = French()
intro(john) # Hello
intro(gerard) # Bonjour
```

Это возможно благодаря утиной типизации. Утиная типизация - факт реализации определённого интерфейса объектом без явного указания или наследования этого интерфейса, а просто по реализации полного набора его методов (Выглядит как утка, крякает как утка, значит это утка. А внутренний мир охотничей приманки селезню не интересен).

#### Множественная диспетчеризация
Виртуальные методы обеспечивают одиночную диспетчеризацию, при которой выбор конкретного метода зависит от объекта, в контексте которого произошел вызов. Мультиметоды позволяют выбирать нужную функциональность в зависимости от количества, типов или значений аргументов.

Программирование на Python не поддерживает мультиметоды из коробки, поэтому для их реализации необходимо подключать сторонние Python библиотеки, например, multimethods.py.

Подробнее о множественной диспетчеризации читайте в [этой статье](https://www.ibm.com/developerworks/ru/library/l-pydisp/) из серии «Очаровательный Python».

#### Порядок разрешения доступа к атрибутам
Складывается достаточно интересная картина: у одного объекта может быть несколько родительских классов, а также специальные методы вроде \_\_getattribute\_\_, которые перехватывают запросы к атрибутам.

Каким же образом интерпретатор разрешает сложные запросы к свойствам и методам? Рассмотрим последовательность поиска на примере запроса obj.field:

* Вызов ``obj.__getattribute__('field')``, если он определен. При установке или удалении атрибута проверяется соответственно наличие ``__setattr__`` или ``__delattr__``.
* Поиск в ``obj.__dict__`` (пользовательские атрибуты).
* Поиск в ``object.__class__.__slots__`` (про слоты мы еще не знаем).
* Рекурсивный поиск в поле ``__dict__`` всех родительских классов. Если класс имеет несколько предков, порядок проверки соответствует порядку их перечисления в определении.
* Если определен метод ``__getattr__``, то происходит вызов ``obj.__getattr__('field')``
* Выбрасывается исключение несуществующего атрибута – AttributeError.

Наконец, когда атрибут нашелся, проверяется наличие метода ``__get__`` (при установке – ``__set__``, при удалении – ``__delete__``).

Все эти проверки совершаются только для пользовательских атрибутов.

#### Метаклассы
Метаклассы – это классы, экземпляры которых тоже являются классами.

```py
class MetaClass(type):
  # выделение памяти для класса
  def __new__(cls, name, bases, dict):
    print("Создание нового класса {}".format(name))
    return type.__new__(cls, name, bases, dict)

  # инициализация класса
  def __init__(cls, name, bases, dict):
    print("Инициализация нового класса {}".format(name))
    return super(MetaClass, cls).__init__(name, bases, dict)

# порождение класса на основе метакласса
SomeClass = MetaClass("SomeClass", (), {})

# обычное наследование
class Child(SomeClass):
  def __init__(self, param):
    print(param)

# получение экземпляра класса
obj = Child("Hello")
```

Больше о метаклассах в Python можно почитать [тут](https://proglib.io/p/metaclasses-in-python/) 

#### ООП на Python
Подведем краткий итог всему вышесказанному и выделим основные особенности реализации ООП на Python:

* Классы в Python – это тоже объекты.
* Допустимо динамическое изменение и добавление атрибутов классов.
* Жизненным циклом объекта можно управлять.
* Многие операторы могут быть перезагружены.
* Многие методы встроенных объектов можно эмулировать.
* Для скрытия внутренних данных используются синтаксические соглашения.
* Поддерживается наследование.
* Полиморфизм обеспечивается виртуальностью всех методов.
* Доступно метапрограммирование.

# Лекция 2

## Событийно-управляемая модель программирования. 
Событийно-ориентированное программирование (event-driven programming) - это парадигма программирования, в которой выполнение программы определяется событиями — действиями пользователя (клавиатура, мышь), сообщениями других программ и потоков, событиями операционной системы (например, поступлением сетевого пакета).

Событийно-ориентированное программирование можно также определить как способ построения компьютерной программы, при котором в коде (как правило, в головной функции программы) явным образом выделяется главный цикл приложения, тело которого состоит из двух частей: выборки события и обработки события.

Событийно-ориентированное программирование, как правило, применяется в трех случаях:
* при построении пользовательских интерфейсов (в том числе графических);
* при создании серверных приложений в случае, если по тем или иным причинам нежелательно порождение обслуживающих процессов;
* при программировании игр, в которых осуществляется управление множеством объектов.

### Применение в серверных приложениях
Событийно-ориентированное программирование применяется в серверных приложениях для решения проблемы масштабирования на 10000 одновременных соединений и более.

В серверах, построенных по модели «один поток на соединение», проблемы с масштабируемостью возникают по следующим причинам:
* слишком велики накладные расходы на структуры данных операционной системы, необходимые для описания одной задачи (сегмент состояния задачи, стек);
* слишком велики накладные расходы на переключение контекстов.

## Прежде чем изучить эту парадигму в Питоне, познакомимся с генераторами (yield)
Для понимания что делает **yield**, вы должны понимать что такое генераторы. Для понимания что такое генераторы — должны знать об итераторах и итерируемых объектах.

### Итерируемые объекты (iterables)
Хочется назвать их неправильным, с точки зрения русского языка, словом «итерабельные» — т.е. те, по которым может происходить итерация. Но, правильнее будет назвать их «итерируемые».

Когда вы создаёте список (list) вы можете считывать его элементы по одному — это называется итерацией.

```py
lst = [1, 2, 3]
for i in lst:
  print(i)
>1
>2
>3
```

Lst — итерируемый объект (iterable). Когда вы используете списковые выражения (list comprehensions), вы создаёте список — итерируемый объект:

```py
lst = [x*x for x in xrange(3)]
for i in lst:
  print(i)
>0
>1
>4
```

Любое объект который вы можете использовать в конструкции «for … in …» является итерирумым: списки, строки, файловые объекты и т.п.. Итерирумые объекты достаточно удобны потому что вы можете считывать из них столько данных, сколько вам необходимо, но при этом вы храните все значения последовательности в памяти и это не всегда приемлемо, особенно если вы имеете достаточно большие последовательности.

### Генераторы
Генераторы — итерируемые объекты, но, в общем случае, вы можете их использовать только один раз. Это связано с тем, что они не хранят все значения в памяти, а генерируют значения «на лету» — по мере запроса:

```py
generator = (x*x for x in xrange(3))
for i in generator:
  print(i)
>0
>1
>4
```

Код выглядит почти так же, как и в предыдущем примере, только вместо квадратных скобочек («[<…>]») были использованы круглые («(<…>)»). Заметьте, что вы не можете выполнить цикл по generator во второй раз, поскольку ничего в памяти не хранится, попытка пройтись второй раз будет просто проигнорирована, т.к. generator выбросит при первом запросе на получение следующего значения StopIterationError, однако, вы это не заметите, если будете использовать цикл for, это исключение будет перехвачено и интерпретировано как конец цикла). Но вручную это можно проверить:

```py
generator.next()
---------------------------------------------------------------------------
StopIteration Traceback (most recent call last)
<ipython-input-6-4d83b5efa530> in <module>()
----> 1 generator.next()
StopIteration:
```

**next** — это метод для получения следующего значения генератора, если вы его используете не в цикле for.

### Yield
Yield — это ключевое слово которое используется так же, как и слово return. Разница в том, что функция при этом начинает возвращать генератор вместо значения.

```py
def generator():
  for i in (1, 2, 3):
    yield i

g = generator() # create a generator
print(g)
><generator object generator at 0x2e58870>

for i in g:
  print(i)
>1
>2
>3
```

В данном случае, с практической точки зрения, это бесполезный пример. Ощутимую пользу вы получите в ситуации, когда ваша функция должна будет возвращать достаточно большой объём данных, но использовать их надо будет только один раз.

Для того чтобы до конца освоить оператор yield, вы должны знать, что когда вы вызываете функцию, в теле которой находится yield, выполнение этой функции не происходит. Вместо выполнения, функция вернёт объект-генератор. Выглядит это несколько странно на первый взгляд — функция вызвана, но код не выполнен, но, просто запомните этот факт. Код будет выполнятся при каждой итерации — будь то цикл «for <…> in <generator>» или вызов метода <generator>.next().

При первом исполнении кода тела функции код будет выполнен с начала и до первого встретившегося оператора yield. После этого будет возвращено первое значение и выполнение тела функции опять приостановлено. Запрос следующего значения у генератора во время итерации заставит код тела функции выполняться дальше (с предыдущего yield’а), пока не встретится следующий yield. Генератор считается «закончившимся» в случае если при очередном исполнении кода тела функции не было встречено ни одного оператора yield.

### Управление исполнением генератора

```py
class Bank(object): # создадим банк, который строит банкоматы (ATM)
    crisis = False

    def create_atm(self):
        while not self.crisis:
            yield "$100"

bank = Bank() # когда всё в порядке, банкоматы выдают деньги
atm = bank.create_atm()
print(atm.next())
>$100

print(atm.next())
>$100

print([atm.next() for cash in range(5)])
>['$100', '$100', '$100', '$100', '$100']

bank.crisis = True # пришёл кризис, денег больше нет
>print(atm.next())

<type 'exceptions.StopIteration'>

wall_street_atm = bank.create_atm() # это справедливо даже для новых банкоматов
print(wall_street_atm.next())

<type 'exceptions.StopIteration'>

bank.crisis = False # проблема в том, что даже после кризиса в банкоматах нет денег

print(atm.next())

<type 'exceptions.StopIteration'>

new_atm = bank.create_atm() # построим новый банкомат с деньгами

for cash in new_atm:
  print(cash)

>$100
>$100
>$100
...
```

В некоторых случаях такая логика может быть полезна, например, для контроля доступа к ресурсам.

### Модуль стандартной библиотеки python — itertools
Модуль стандартной библиотеки python itertools содержит специальные функции для создания и работы с итераторами. С помощью этого модуля вы можете: клонировать итератор, объединить в цепочку несколько итераторов, сгруппировать значения вложенных списков в один, использовать версию map/zip на генераторах — imap/izip, на этом список не заканчивается.

Например, давайте вычислим все возможные варианты прихода лошадей в скачках (задача из комбинаторики — перестановки без повторов элементов):

```py
horses = [1, 2, 3]
races = itertools.permutations(horses)
print( list( itertools.permutations(horses) ) )
>[(1, 2, 3), (1, 3, 2), (2, 1, 3), (2, 3, 1), (3, 1, 2), (3, 2, 1)]
```

Заметьте, что применение list к генератору вычислит все его значения и создаст из них список.

### Понимание внутренней механики итерации
Итерация — это процесс подразумевающий итерируемые объекты («итерабельные», т.е. реализующие метод «__iter__()») и итераторы (реализующие метод «__next__()»). 

**Итерируемые объекты** — любые объекты, по которым может проходить итерация. 

**Итераторы** — объекты, которые позволяют вам производить итерацию по итерируемым объектам. 







## Python реализация парадигмы event-driven с помощью сопрограмм (стянуто с хабра)
Статья про то, как с помощью расширенных генераторов Python сделать собственную реализацию сопрограмм, переключающихся по получению событий. Простота кода получившегося модуля вас приятно удивит и прояснит новые и мало используемые возможности языка, которые можно получить, используя такие генераторы. Статья поможет разобраться и с тем, как это устроено в серьезных реализациях: asyncio, tornado, etc.

### Теоретические моменты и disclaimer
Понятие сопрограмма имеет очень широкое толкование, поэтому следует определиться, какими характеристиками они будут обладать в нашей реализации:
* Выполняются совместно в одном потоке;
* Выполнение может прерываться для ожидания определенного события;
* Выполнение может возобновиться после получения ожидаемого события;
* Может вернуть результат по завершению.

Как следствие получаем: событийно-ориентированное программирование без функций обратного вызова и кооперативную многозадачность. Эффект от использования такой парадигмы программирования будет существенным только для задач, реагирующих на неравномерно поступающие события. В первую очередь это задачи обработки I/O: сетевые сервера, пользовательские интерфейсы, и т.п. Другой возможный вариант применения — это задачи расчета состояния персонажей в игровом мире. Но категорически не подойдет для задач, которые производят долгие расчеты. 
Следует четко понимать, что пока выполняющаяся сопрограмма не прервалась на ожидание события, все остальные находятся в состоянии останова, даже если ожидаемое ими событие уже произошло.

### Основа всего
В Python хорошей основой для всего этого являются генераторы, если их правильно приготовить в прямом и переносном смысле. Точнее расширенные генераторы, API которых окончательно сформировался в версии Python 3.3. В предыдущих версиях не было реализовано возвращение значения (результата) по завершению работы генератора и не было удобного механизма вызова одного генератора из другого. Тем не менее, реализации сопрограмм были и раньше, но из-за ограничений обычных генераторов они были не так «красивы» как то, что получится у нас. Очень хорошая статья на эту тему «A Curious Course on Coroutines and Concurrency» единственный её недостаток, так это то, что нет обновленной версии. Такой где реализация coroutine в python использует последние новшества в языке, в частности в API Enhanced Python Generators. Ниже рассмотрены возможности расширенных генераторов, которые нам понадобятся. 

Передача сообщений в сопрограмму у нас будет построена на возможности задать генератору его состояние.

```py
def gen_factory():
    state = None
    while True:
        print("state:", state)
        state = yield state

gen = gen_factory()
```

Генератор создан, его надо запустить. 

```py
next(gen)
>state: None
```

Получено исходное состояние. Изменим состояние:

```py
gen.send("OK")
>state: OK
'OK'
```

Видим что состояние изменилось и возвращено в результате. Следующие вызовы send будут возвращать уже передаваемое ими состояние. 

Зачем нам все это?

Представьте задачу: передавать привет Петрову раз в две секунды, Иванову раз в три секунды, а всему миру раз в пять секунд. В виде Python кода можно представить как-то так:

```py
def hello(name, timeout):
    while True:
        sleep(timeout)
        print("Привет, {}!".format(name))

hello("Петров", 2.0)
hello("Иванов", 3.0)
hello("Мир", 5.0)
```

Смотрится хорошо, но приветы будет получать только Петров. Однако! Небольшая модификация не влияющая на ясность кода, а даже наоборот — уточняющая нашу мысль, и это уже может заработать как положено.

```py
@coroutine
def hello(name, timeout):
    while True:
        yield from sleep(timeout)
        print("Привет, {}!".format(name))

hello("Петров", 2.0)
hello("Иванов", 3.0)
hello("Мир", 5.0)
run()
```

Код получился в стиле pythonic way — наглядно иллюстрирует задачу, линейный без калбэков, без лишних наворотов с объектами, любые комментарии в нем излишни. Осталось только реализовать декоратор coroutine, свою версию функции sleep и функцию run. В реализации, конечно, без наворотов не обойдется. Но это тоже pythonic way, прятать за фасадом библиотечных модулей всю магию.

### Самое интересное
Назовем модуль с реализацией незатейливо — concurrency, со смыслом и отражает тот факт, что это фактически, будет реализация кооперативной многозадачности. Понятно, что декоратор должен будет сделать из обычной функции генератор и запустить его (сделать первый вызов next). Конструкция языка yield from пробрасывает вызов в следующий генератор. То есть функция sleep должна создать генератор, в котором можно спрятать всю магию. В генератор, ее вызвавший, вернется только код полученного события. Здесь возвращаемый результат не обрабатывается, код тут может получить по сути только один результат, означающий что тайм-аут истек. Ожидание же ввода-вывода может возвращать разные виды событий, например (чтение/запись/тайм аут). Более того, генераторы порождаемые функциями типа sleep могут вернуть по yield from любой тип данных и соответственно их функционал может быть не ограничен ожиданием событий. Функция run запустит диспетчер событий, его задача — получить событие извне и/или сгенерировать внутри, определить его получателя и собственно отправить.

Начнем с декоратора:

```py
class coroutine(object):
    """Делает из функции сопрограмму на базе расширенного генератора."""
    _current = None

    def __init__(self, callable):
        self._callable = callable

    def __call__(self, *args, **kwargs):
        corogen = self._callable(*args, **kwargs)
        cls = self.__class__
        if cls._current is None:
            try:
                cls._current = corogen
                next(corogen)
            finally:
                cls._current = None
        return corogen
```

Он выполнен в виде класса, типичный прием, как и обещал, он создает и запускает генератор. Конструкция с _current добавлена для того, чтобы избежать запуска генератора, если декорированная функция, его создающая вызывается внутри тела другого генератора. В этом случае первый вызов будет и так сделан. Так же это поможет разобраться, в какой генератор должно быть передано событие, чтобы оно попало по цепочке в генератор, созданный функцией sleep.

```py
def sleep(timeout):
    """Приостанавливает выполнение до получения события "таймаут истек"."""
    corogen = coroutine._current
    dispatcher.setup_timeout(corogen, timeout)
    revent = yield
    return revent
```

Здесь видим вызов dispatcher.setup_sleep, это сообщает диспетчеру событий, что генератор такой-то ожидает событие «тайм-аут» по истечению заданного параметром timeout количества секунд. 


```py
from collections import deque
from time import time, sleep as sys_sleep

class Dispatcher(object):
    """Объект реализующий диспечер событий."""
    def __init__(self):
        self._pending = deque()
        self._deadline = time() + 3600.0

    def setup_timeout(self, corogen, timeout):
        deadline = time() + timeout
        self._deadline = min([self._deadline, deadline])
        self._pending.append([corogen, deadline])
        self._pending = deque(sorted(self._pending, key=lambda a: a[1]))

    def run(self):
        """Запускает цикл обработки событий."""
        while len(self._pending) > 0:
            timeout = self._deadline - time()
            self._deadline = time() + 3600.0
            if timeout > 0:
                sys_sleep(timeout)
            while len(self._pending) > 0:
                if self._pending[0][1] <= time():
                    corogen, _ = self._pending.popleft()
                    try:
                        coroutine._current = corogen
                        corogen.send("timeout")
                    except StopIteration:
                        pass
                    finally:
                        coroutine._current = None
                else:
                    break

dispatcher = Dispatcher()
run = lambda: dispatcher.run()
```

В коде диспетчера событий тоже нет ничего необычного. Куда передавать события определяется с помощью переменной класса coroutine._current. При загрузке модуля создается экземпляр класса, в рабочей реализации это конечно же должен быть синглетон. Класс collections.deque задействован вместо списка, так как побыстрее и полезен своим методом popleft. Ну вот собственно и все, и нет какой-то особой магии. Вся она на поверку спрятана еще глубже, в реализации расширенных генераторов Python. Их остается только правильно приготовить.


## Компонентно-ориентированный подход.

ООП-подход в разработке ПО хорошо себя зарекомендовал. Инкапсуляция, наследование и полиморфизм помогают программисту повторно использовать функциональность базового класса и скрыть детали реализации. Но при разработке сложных систем, особенно систем, моделирующих процессы окружающего мира, ООП-программист сталкивается с рядом новых проблем, для решения которых необходим принципиально иной подход.

### Недостатки ООП и трудности, возникающие при моделировании сложных систем
*Недостаточный контроль за безопасностью*. Опасность утечек памяти. Если в языке программирования нет автоматической сборки мусора, то программист может забыть освободить память, выделенную под объект, или освободить память несколько раз.

*Взаимозависимость объектов и проблема хрупкого базового класса*. В изменчивых средах или в средах с непредсказуемым поведением становится сложно обеспечить надлежащее функционирование системы с помощью ограниченного набора специализированных классов. Ради небольшого изменения функциональности подчас приходится перестраивать архитектуру всей системы. При изменении базового класса могут возникнуть ошибки в работе унаследованных классов (т.н. проблема хрупкого базового класса).

*Зависимость от языка программирования и платформы*. Функциональность объекта записывается в виде кода шаблона объекта – класса — на некотором языке программирования. Объекты, написанные на разных языках, могут иметь свою специфику и оказаться в конечном итоге несовместимы между собой.

*Высокие требования к квалификации ООП-программиста*. В сложных системах, состоящих из большого числа взаимодействующих объектов, от программиста требуются высокая квалификация и большой опыт. 

*Сложность контроля жизненного цикла объекта*. Жизненный цикл объекта начинается с вызова конструктора и заканчивается вызовом деструктора. После уничтожения объекта вся информация о его состоянии теряется. В случае необходимости сохранять состояние объекта, программисту необходимо самому реализовывать часть функциональности CRUD и контролировать жизненный цикл объекта.

### Основные особенности компонентно-ориентированного программирования и отличие компонента от объекта

Эта парадигма программирования направлена прежде всего на повышение надёжности коммерческих бизнес-систем. Суть компонентно-ориентированного программирования (далее КОП) сводится к возможности контролировать взаимодействие проектируемых и выполняемых модулей на предмет согласованности информационных структур. Идея является относительно новой. Частично идеи КОП воплощены в такие языки как Java, Ada, C#, прямым применением идей КОП являются языки программирования Modula-2, Oberon, Oberon-2, и наиболее известный из семейства КОП — Компонентный Паскаль.

**Компонент как объект, функционирующий в рамках сложной системы с непредсказуемым поведением и большим временем жизни**

Главное отличие компонента от объекта заключается в том, что компонент функционирует в среде как часть единой системы – «фреймворка». Фреймворк предоставляет унифицированный способ доступа к ресурсам среды в рамках компонентной модели. Под средой (или окружением) обычно понимается среда выполнения — вычислительное окружение, необходимое для выполнения программы. В конечном итоге компонент взаимодействует как с операционной системой/виртуальной машиной, так и с пользователем, БД, периферийными устройствами и прочими объектами реального мира, используя возможности фреймворка. В контексте жизненного цикла разработки ПО, под средой также может пониматься среда разработки, среда выполнения и т.п.

Компонент может рассматриваться как объект, к которому предъявлен ряд дополнительных требований для функционирования в сложных средах с элементами неопределенности. Базовый класс компонента должен содержать всю необходимую функциональность, которая позволяет называть компонент компонентом.

Если жизненный цикл объекта в ООП, как правило, известен заранее вплоть до мельчайших деталей еще на этапе разработки архитектуры системы, то компоненты, являющиеся частью сложной системы, могут инициировать взаимодействие друг с другом в различное время «по требованию». При этом они изначально могут ничего не знать друг о друге — на этапе написания компонента программист ограничен возможностями компонентной модели. Поэтому компоненты должны уметь динамически «обрабатывать» события и обмениваться информацией о своих свойствах и умениях с другими компонентами.

Вот некоторые особенности, в той или иной мере присущие компонентно-ориентированному программированию: интроспективность (способность компонентов к самоописанию), модульность и разграничение уровней доступа, автоматическая обработка исключительных ситуаций, автоматическое управление памятью, позднее связывание и динамический контроль типов, обработка событий, персистентность (способность компонентов сохранять и восстанавливать состояние), простота повторного использования.

Компоненты могут представлять сущности моделируемой системы, ресурсы среды (предоставлять доступ к файловой системе, базам данных), управлять рабочим потоком, предназначаться для выполнения определенных задач.

### Различные жизненные циклы и среды

С точки зрения аспекта разработки ПО, жизненный цикл компонента обычно начинается после того, как код на некотором языке программирования скомпилирован в виде модуля (сборки) и установлен в среду проектирования.

После этого компонент готов к взаимодействию со средой проектирования и используется разработчиком на этапе проектирования целевой информационной системы.

После развертывания целевой системы компонент взаимодействует с исполняемой средой и обычно с пользователем, для которого, как правило, и предназначена спроектированная система.

### Способность компонента к описанию собственных свойств и умений

Компоненты в КОП-мире функционируют не сами по себе, а в рамках системы («фреймворка»). Поэтому им необходимо иметь способ предоставлять информацию о себе, например, с помощью метаданных, и получать информацию от других компонентов системы. Метаданные могут содержать описание возможностей компонента, их доступности в каждой поддерживаемой среде и особенностей работы с ними.

В дополнение к привычным сущностям ООП мира – полям и методам, КОП предлагает новые концептуальные понятия – свойства, события, команды, модули и т.д.

Изменение внутреннего состояния компонента производится с помощью изменения соответствующих свойств.

Для реакции на события внешней среды в КОП используются обработчики событий. Могут потребоваться дополнительные способы контроля поведения компонента, реализованные в виде правил и ограничений.

Полный набор правил, описывающих взаимодействие компонентов друг с другом в рамках фреймворка, образует компонентную модель.

### Способность компонента сохранять и восстанавливать свое состояние

При переходе из одной среды в другую между жизненными циклами, компоненты должны иметь возможность где-то хранить свое состояние. Для этого от разработчика компонента может потребоваться реализация определенных интерфейсов или применение паттернов проектирования. Обычно это достигается за счет сериализуемости компонента (Serializable).

### Способность к взаимодействию, при этом независимость компонентов друг от друга

Архитектура КОП-системы построена таким образом, что компоненты не зависят друг от друга и являются взаимозаменяемыми. Архитектор может собирать требуемую систему из компонентов как из кубиков детского конструктора. В случае изменения функциональности компонента, от программиста может потребоваться перекомпилировать отдельный компонент, но не все приложение.

При этом компонент не автономен – он находится в тесном взаимодействии со средой. О среде компонент знает ровно столько, сколько ему необходимо для реализации заявленной функциональности.

### Миграция компонентов между средами вместо компиляции

В КОП принято говорить об установке компонентов, когда скомпилированные сборки, или пакеты, содержащие компоненты, устанавливаются в среду проектирования. Компоненты готовы к использованию сразу после попадания в среду.

Теоретически в КОП может и вовсе отсутствовать привычный этап компиляции. Функциональность компонента может «виртуально» существовать в базе данных или в файловой системе и загружаться или даже меняться по мере необходимости.

### Дизайн вместо программирования

При сборке системы из компонентов становится возможным создавать сложные информационные системы без единой строки кода!

### Безопасное управление памятью

Управление памятью, в том числе сборка мусора, может осуществляться внутри среды автоматически или другим способом (например, благодаря иерархической организации структуры компонентов фреймворка).

