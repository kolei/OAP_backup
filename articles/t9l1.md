[содержание](/readme.md)  

# Тема 9. Стандартная библиотека Python. [Шаблоны проектирования](#шаблоны-проектирования).
Стандартная библиотека Питона весьма обширна и включает в себя множество инструментов. Она содержит как встроенные модули (написанные на Си), предоставляющие доступ к системным функциям, таким как операции ввода-вывода, так и модули, написанные на Питоне, предлагающие стандартные решения для множества задач, возникающих в программировании.

В библиотеке содержится несколько видов компонентов.

В ней определены типы данных, которые часто принято считать частью «ядра» языка, например числа и списки. Для таких типов форма литералов и некоторые ограничения употребления задаются ядром (например, орфография и приоритет операций).

Библиотека также содержит встроенные функции и исключения — эти объекты не нужно импортировать откуда-либо, чтобы ими воспользоваться.

Однако, основная часть библиотеки состоит из набора модулей. Этот набор можно классифицировать по-разному. Некоторые модули написаны на Си и являются частью интерпретатора; другие написан на Питоне и импортируются в исходном коде. Некоторые модули предоставляют интерфейсы, специфичные для Питона (например, вывод трассировки стека); другие — интерфейсы для взаимодействия с конкретными операционными системами (например, обращение к аппаратному обеспечению); третьи — интерфейсы для конкретной предметной области (например, веб). Одни модули доступны во всех версиях и дистрибутивах Питона; другие — только тогда, когда ОС поддерживает их; помимо этого, существуют и такие, доступность которых определяется конфигурацией при компиляции интерпретатора.

## Встроенные функции
Для использования перечисленных ниже функций не требуется импортировать какие-либо модули. Это функции, доступные в Питоне «из коробки».

Полный список встроенных объектов можно получить следующим образом:
```py
    names = globals()['__builtins__'].__dict__.keys()
    builtins = sorted([name for name in names if not name.startswith('_')])
```
Обратите внимание, что кроме имён функций код, приведенный выше, возвращает имена и других встроенных объектов (типов данных, исключений и пр.).

функция | параметры | результат | краткое описание
:------:|:---------:|:---------:|-----------------
abs     |	int, float|int, float | Возвращает абсолютную величину.
all     | iterable  | bool      |	Проверяет, все ли указанные элементы принимают значение «истина».
any	    | iterable  | bool      | Проверяет, есть ли среди указанных элементов хотя бы один, принимающий значение «истина»
ascii	  | object    | str       | Возвращает строковое представление объекта с экранированными не-ASCII символами
bin	    | int       | str       | Преобразует целое число в двоичную строку.
callable|	obj       | bool      | Возвращает True для объекта, поддерживающего вызов.
chr	    | int       | str       | Возвращает символ по его числовому представлению.
classmethod | function |        |	Представляет указанную функцию методом класса.
cmp	    | obj, obj     | int       | Сравнивает два объекта, по итогу возвращает целое.
compile	| str       | obj \| АСД| Компилирует исходный код в объект кода, либо объект АСД.
delattr	| obj, name:&nbsp;str|       | Удаляет из объекта указанный атрибут.
dir	    | [obj] | list | Возвращает имена переменных, доступные в локальной области, либо атрибуты указанного объекта в алфавитном порядке
divmod	| obj, obj | tuple (частное,&nbsp;остаток) | Для целочисленного деления возвращает пару частное-остаток от деления аргументов
enumerate	| iterable [,start=0] | generator | Возвращает генератор, отдающий пары счётчик-элемент для элементов указанной последовательности<br/>``for idx, item in enumerate(iterable):``
eval | expression, globals=None, locals=None | any | Разбирает и исполняет указанное выражение.
exec | obj[, globals[, locals]] | any |	Динамически исполняет указанный код.
filter | func, iterable | list, tuple, string | При помощи указанной функции фильтрует элементы переданного объекта.
format | value \[,&nbsp;format_spec\] | str |	Форматирует указанное значение.
getattr | obj, name \[,&nbsp;default\] | any | Возвращает значение атрибута объекта.
globals	| | dict | Возвращает словарь с глобальной таблицей символов, определённых в модуле
hasattr	| obj, name | bool | Возвращает флаг, указывающий на то, содержит ли объект указанный атрибут
hash | obj | int | Возвращает хеш указанного объекта.
help | \[obj\] | stdout |	Вызывает встроенную справочную систему.
hex	| int | str | Возвращает строку с шестнадцатеричным представлением указанного целого
id | obj | int | Возвращает идентификатор указанного объекта.
input | \[prompt\] | str |	Считывает и возвращает строку входных данных.
isinstance | obj, classinfo | bool | Возвращает флаг, указывающий на то, является ли указанный объект экземпляром указанного класса (классов)
issubclass | cls, classinfo | bool |	Возвращает флаг, указывающий на то, является ли указанный класс подклассом указанного класса (классов)
iter | obj[, sentinel] | iterator |	Возвращает объект итератора.
len | obj | in | Возвращает число элементов в указанном объекте-контейнере.
locals | | dict |	Возвращает словарь, представляющий текущую локальную таблицу символов.
map | func, iterable, ... | iterator \| list | Применяет указанную функцию к каждому элементу указанной последовательности/последовательностей
max | iterable, *args[, key, default] | any |	Возвращает элемент с наибольшим значением из переданных в функцию.
min	| iterable, *args[, key, default] | any | Возвращает элемент с наименьшим значением из переданных в функцию.
next | iter[, default] | any | Возвращает следующий элемент итератора.
oct | int | str |	Возвращает строку с восмеричным представлением указанного целого.
open | file, mode='r', buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None | file	| Открывает файл и возвращает представляющий его объект.
ord	| str | int | Возвращает числовое представление для указанного символа.
pow	| x, y\[,&nbsp;z\] | число | Возвращает результат возведения числа в степень, с опциональным делением по модулю
print | *objs, sep=' ', end='\n', file=sys.stdout, flush=False | stdout \| file |	Отправляет указанные объекты текстовым потоком в файл.
repr | obj | str |	Возвращает формальное строковое представление указанного объекта.
reversed | iterable | iterator | Возвращает обратный итератор по указанной последовательности.
round	| float, ndigits=0 | float | Возвращает число с плавающей запятой, округлённое до указанного количества цифр после запятой
setattr	| obj, name, value | | Добавляет объекту указанный атрибут.
sorted | iterable [,&nbsp;key \[,&nbsp;reverse\]] | list | Возвращает новый отсортированный список, составленный из элементов итерирующегося объекта
staticmethod | function | |	Представляет указанную функцию статичным методом.
sum	| iterable[, start] | any | Суммирует элементы указанного объекта и возвращает результат.
super	| [type[, object-or-type]] | any | Возвращает объект-посредник (прокси), делегирующий вызовы методов родителю или собрату класса указанного типа
vars | \[obj\] | dict | Возвращает словарь из атрибута __dict__ указанного объекта.
zip | *iterables | iterator \| list |	Возвращает итератор по кортежам, где i-тый кортеж содержит i-тый элемент каждой из указанных последовательностей

Что-то из этого мы уже знаем, с остальным детально ознакомимся на практических занятиях

## Стандартная библиотека Питона
Для того чтобы перечислить все функции библиотеки у нас не хватит ни времени ни памяти. Полный список всегда можно посмотреть [тут](https://docs.python.org/3.7/library/index.html), а мы пройдемся по верхушкам, останавливаясь только на самых интересных модулях.


### Модуль sys
В этом модуле содержатся функции и константы для взаимодействия с интерпретатором Python. В этом модуле, в том числе, содержатся следующие переменные:

argv — аргументы командной строки,
byteorder — порядок байтов платформы, 'little' или 'big',
flags — объект, предоставляющий в виде атрибутов информацию о флагах, данных интерпретатору. Например, sys.flags.debug говорит о режиме отладки,
maxint — максимальное целое,
platform — идентификатор платформы, например, 'linux-i386',
stdin, stdout, stderr — стандартные потоки ввода, вывода и вывода ошибок,
version — строка с версией,
и другие.

### Модуль contextlib
Модуль содержит вспомогательные функции для поддержки оператора with.

Пример использования менеджера контекста, при котором открытый файл автоматически закрывается:

```py
with open('myfile.dat', 'wb') as fh:
    fh.write('Мои данные')
```

В примере выше был использован встроенный в Python менеджер контекста. API менеджера контекста состоит из двух методов:

Метод __enter__ вызывается при входе в блок with. Возвращает объект, который получает параметр, заданный as,
Метод __exit__ вызывается при выходе управления за пределы блока with.
Модуль contextlib предлагает декоратор для создания контекстного менеджера на базе генератора:

```py
from contextlib import contextmanager
@contextmanager
def my_context():
    try:
        yield myvalue  # значение для as
    except MyError, e:
        # обработка исключения
    finally:
        # выполняется при любом исходе
```

### Модуль abc
Модуль определяет метакласс ABCMeta и декораторы abstractmethod и abstractproperty для определения новых абстрактных базовых классов (англ. abstract base class). Следует отметить, что абстрактный базовый класс понимается здесь в ином смысле, нежели в C++.

### Типы данных
Стандартная библиотека расширяет набор доступных Python типов данных. Имеются отдельные типы данных для даты и времени, массива, кучи, очереди, слабые ссылки, а также так называемые абстрактные базовые типы из модуля collections.

### Модуль datetime
Модуль datetime предоставляет пять классов: дата (date), время (time), комбинация даты и времени (datetime), разность дат и времени (timedelta) и временная зона (tzinfo).

В следующем примере печатается экземпляр datetime, фиксирующий дату и время в момент вызова метода now():

```py
import datetime
datetime.datetime.now()
datetime.datetime(2013, 5, 11, 19, 47, 25, 375511)
```

### Модуль collections
Данный модуль включает в себя набор специальных типов данных — контейнеров, которые дополняют стандартные встроенные типы dict, list, set и tuple. Например для Python 2.7: OrderedDict — упорядоченный (в порядке добавления элементов) словарь, defaultdict — словарь, вызывающий заданную функцию для отсутствующего в нём элемента, Counter — словарь, который удобно использовать для подсчёта слов, Deque — двусвязный список, namedtuple — кортеж с возможностью доступа к элементам по именам атрибутов. Также имеются абстрактные базовые классы Container, Sequence, Set, Mapping и другие.

Пример, демонстрирующий работу с дэком:

```py
from collections import deque
d = deque('123')
d[1]
>'2'
d.pop()
>'3'
d.appendleft('0')
list(d)
>['0', '1', '2']
```

### Взаимодействие с ОС
### Модуль os
Модуль предоставляет функции переносимого интерфейса к основным сервисам операционной системы, определяет некоторые переменные (например, environ для доступа к переменным окружения).

### Модуль os.path
Модуль служит для манипуляций с путями к файлам в независимом от вида платформы. Пример иллюстрирует использование некоторых функций модуля:

```py
import os.path
os.path.join("/tmp/1", "temp.file")  # конкатенация путей
>'/tmp/1/temp.file'
os.path.dirname("/tmp/1/temp.file")  # имя каталога по заданному полному пути
>'/tmp/1'
os.path.basename("/tmp/1/temp.file")  # имя файла по заданному полному пути
>'temp.file'
os.path.normpath("/tmp//2/../1/temp.file")  # нормализация пути 
>'/tmp/1/temp.file'
os.path.exists("/tmp/1/temp.file")  # существует ли путь?
>False
```

### Обработка текстов
Стандартная библиотека содержит несколько модулей для работы со строками и обработки текстов, включает в себя следующие возможности.

### Полезные константы и функции из модуля string
Модуль содержит различные константы, которые можно использовать при обработке текстов, например: ascii_letters (строка, содержащая все буквы из набора ASCII), ascii_lowercase, digits (строка с цифрами от 0 до 9), letters (буквы, зависят от установки локали) и т. п.

```py
from string import ascii_letters, ascii_lowercase, ascii_uppercase, digits
ascii_letters
>'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'
ascii_lowercase
>'abcdefghijklmnopqrstuvwxyz'
ascii_uppercase
>'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
digits
>'0123456789'
```

Сгенерировать пароль:

```py
chars = ascii_letters + digits
from random import choice
n = 8                            # длина пароля
''.join(choice(chars) for _ in range(n))
>'ia1KGm2t'
```

Для упрощения подстановки в строки по ключевым словам могут использоваться экземпляры класса Template. Пример иллюстрирует методы substitute и safe_substitute:

```py
from string import Template
tpl = Template("""${name} has ${amount}$$. {oh}""")
tpl.substitute({"amount": 100, "name": "John"})
>'John has 100$. {oh}'
tpl.safe_substitute({"amount": 100})
>'${name} has 100$. {oh}'
# Для сравнения синтаксиса, метод format для строки: 
"""{name} has {amount}$. {{oh}}""".format(**{"amount": 100, "name": "John"})
>'John has 100$. {oh}'
```

### Поддержка регулярных выражений: модуль re
Регулярные выражения являются мощным средством обработки текста. Модуль **re** содержит функции для замены (sub), разбиения строки (split), сравнения строки с шаблоном (match, search), поиска (finditer, findall) и определяет классы для скомпилированного регулярного выражения и результата сравнения. 

Регулярное выражение (re, regexp) позволяет описать некоторое множество строк при помощи шаблона для дальнейшего определения того, входит ли какая-либо строка в этом множество. Данный модуль предоставляет инструменты для работы с регулярными выражениями, подобные тем, которые можно обнаружить в языке Perl.

Как шаблоны так и строки, по которым производится поиск, могут являться и строками Юникод (str) и 8-битными строками (bytes)

В регулярных выражениях обратный слеш (``\``) используется для обозначения специальных форм или спецсимволов, что конфликтует со сценариями использования его в Питоне. Например, для обозначения регулярного выражения ``\\`` потребуется указать строковый литерал шаблона ``\\\\``, потому что обратный слеш в литерале потребует экранирования.

Дабы избежать необходимости экранирования, в качестве шаблонов регулярных выражений можно использовать сырые строки Питона (строки с префиксом r). Например: r'\n' — это строка из двух символов (\ и n), а '\n' — это строка из одного символа, обозначающего переход на новую строку. Шаблоны регулярных выражений в Питоне часто используют сырые строки.

Многие инструменты, предлагаемые модулем, доступны как в виде функций, так и в виде методов объектов скомпилированных регулярных выражений. Функции предлагают короткий путь (при их использовании нет необходимости компилировать объект регулярного выражения), жертвуя при этом параметрами для более тонкой настройки.

```py
import re
compiled_re = re.compile(r"[a-b][0-9]*")
[m.group(0) for m in compiled_re.finditer("A1 c123 a12, b abc (b987).")]
>['a12', 'b', 'a', 'b', 'b987']
```

### Работа с байтовыми структурами в модуле struct
Модуль struct служит для конвертирования данных из строк байтов и типами данных языка Python и может применяться при работе с форматами бинарных файлов и коммуникационными протоколами. Функции pack и unpack позволяют «упаковывать» и «распаковывать» данные на основе строки формата, состоящей их кодов форматирования.

### array
Модуль предоставляет инструменты для работы с массивами.
В этом модуле определён тип array, позволяющий компактно размещать в памяти массивы, состоящие из объектов базовых типов: символы, целые, числа с плавающей запятой

>Если требуется максимально эффективная работа с массивами, следует воспользоваться типом array из пакета NumPy

Массивы, являясь последовательностью, очень похожи на списки, однако налагают ограничения на типы хранящихся в них объектов. Тип задаётся на этапе создания массива при помощи буквенного обозначения.

### Форматы данных
#### CSV
Для чтения и записи файла в формате CSV предназначен модуль csv. Этот модуль предназначен для работы с различными диалектами: разделитель-запятая, разделитель — точка с запятой, разделитель — табуляция (Excel).

#### Работа с файловыми архивами
В стандартной библиотеке имеется поддержка для нескольких форматов архивов в виде следующих модулей: bz2 (bzip2), gzip (gzip), tarfile (tar), zipfile (zip), а также привязки к библиотеке zlib в виде модуля zlib.

В следующем примере в файле archive.zip будет заархивирован файл file.txt, содержащий текст «text in the file». Это ещё один пример использования менеджера контекста.

```py
from zipfile import ZipFile
with ZipFile('archive.zip', 'w') as ziparc:
     ziparc.writestr('file.txt', 'text in the file')
```

Чтение архива происходит аналогично. В следующем примере будут напечатаны имена файлов, содержащиеся в архиве:

```py
from zipfile import ZipFile
with ZipFile('archive.zip', 'r') as ziparc:
     for fileinfo in ziparc.filelist:
         print(fileinfo.filename)
```

#### Конфигурационные файлы
Для чтения и записи конфигурационных файлов предназначен модуль ConfigParser. Этот модуль написан на чистом Python и, следовательно, платформонезависим. Синтаксис конфигурационных файлов похож на тот, что используется в INI-файлах Windows.

#### Модуль shutil 
Cодержит набор функций для обработки файлов, групп файлов, и папок. В частности, копировать, перемещать и удалять файлы и папки.

### Криптографические модули
В силу различных причин (в том числе политических — во многих странах запрещена разработка и распространение криптографического программного обеспечения без разрешения соответствующих государственных структур) поддержка криптографии в стандартной библиотеке Python ограничена и сводится к хеш-функциям.

В версии 2.5 структура криптобиблиотеки была унифицирована — все хеш-функции собраны в модуль hashlib и удалены бесполезные модули некриптостойкого шифрования. Ранние модули md5, hmac, sha объявлены устаревшими и будут удалены в одном из последующих релизов.

Как и в некоторых других случаях (DB-API, Python Web Server Gateway Interface), при невозможности (или нецелесообразности) включить полноценную поддержку технологии в стандартную библиотеку, были приняты стандарты на интерфейсы, предоставляемые внешними библиотеками, — API для хеш-функций, API для блочных шифров. Однако, далеко не все библиотеки соответствуют этим требованиям (либо в силу старости — созданы до написания CryptoAPI, либо из-за того, что являются автоматически сгенерированными обёртками поверх соответствующих библиотек C).

Использовать CryptoAPI-совместимые библиотеки достаточно просто:

```py
import hashlib
m = hashlib.new('md5')      # создаем новый хеширующий объект с MD5 функцией
m = hashlib.md5()           # либо так
m.update("test data")       # добавляем данные
m.digest()
>'\xebs:\x00\xc0\xc9\xd36\xe6V\x91\xa3z\xb5B\x93'
m.hexdigest()
>'eb733a00c0c9d336e65691a37ab54293'
```

hashlib обеспечивает поддержку следующих хеш-функций: MD5, SHA-1, SHA224, SHA256, SHA384, SHA512 (в сборках Python со включённой библиотекой OpenSSL этот список шире). Следует отметить, что одно только присутствие алгоритма в стандартной библиотеке не гарантирует его криптографическую надёжность. Так, алгоритмы MD5 и SHA-1 не являются криптостойкими.

Для шифрования приходится использовать сторонние библиотеки, например, pycrypto (соответствует CryptoAPI) или M2Crypto (не соответствует CryptoAPI). Достаточно полный список представлен в PyPI.

### Сетевые протоколы
В стандартной библиотеке присутствуют модули для работы с сетевыми протоколами HTTP (и клиент, и простейший сервер), FTP, XML-RPC, SMTP, IMAP, NNTP и другие.

### html, http
эти модули работают в одной и той же области. Модуль http позволяет работать с интернет ресурсами по протоколу HTTP, отправлять запросы GET/POST, принимать запросы, обрабатывать Cookie и фактически реализовать свой клиент или сервер на Python. Библиотека html, в свою очередь, позволяет выполнять разбор html страниц.

### email
python поддерживает обработку email сообщений на уровне языка. Модуль не реализует никаких методов для отправки сообщений через SMTP или NNTP, этим занимаются другие протоколы. Здесь есть функции для разбора структуры email сообщений, проверки списка почты, преобразования и много другого.

### Модуль smtplib
Модуль предназначен для отправки сообщений электронной почты посредством протокола SMTP.

```py
import smtplib

def send_email(text):
    server = smtplib.SMTP("smtp.server", 587)  # подключение к серверу
    server.ehlo()
    server.starttls()
    server.login("login", "password")  # логинимся на сервер
    message = "\r\n".join([   # формируем сообщение Email с полями
        "From: от кого", 
        "To: кому", 
        "Subject: тема", 
        "", 
        text,
        ])
    server.sendmail("login@server", "адрес почты получателя", message)  # отправляем
    server.quit()  # разлогиниваемся с сервера

send_email('Hello, World!')
```

### Базы данных
#### Простые базы данных
Python поддерживает доступ к файлам в DBM-формате: Unix (n)dbm (модуль dbm в Python 2.x или dbm.ndbm в Python 3), GNU DBM (модуль gdbm), модуль, написанный на чистом Python, dumbdbm.

Работа с объектом базы данных происходит аналогично работе со словарём Python (на примере dumbdbm):

```py
import dumbdbm
d = dumbdbm.open('my.db', 'w')  # открыть файл базы данных
d['key'] = 'value'              # присвоить значение по ключу
v = d['key']                    # получить значение по ключу
d.sync()                        # записать изменения
d.close()                       # закрыть базу данных
```

Для долговременного хранения объектов Python можно использовать модуль shelve (рус. "поставить на полку").

#### SQLite
SQLite — это встраиваемая кроссплатформенная БД, которая поддерживает достаточно полный набор команд SQL и доступна в исходных кодах (на языке C). Начиная с Python 2.5, библиотека sqlite3 поставляется вместе с интерпретатором языка Python.

Для работы с библиотекой нужно создать объект Connection , который выступает в роли базы данных:

```py
import sqlite3
conn = sqlite3.connect('example.db')
c = conn.cursor()

# Создаем таблицу
c.execute('''CREATE TABLE stocks
             (date text, trans text, symbol text, qty real, price real)''')

# Вставляем строку
c.execute("INSERT INTO stocks VALUES ('2006-01-05','BUY','RHAT',100,35.14)")

# Сохраняем (и записываем) изменения
conn.commit()

# После окончания работы мы можем закрыть соединение с ДБ
conn.close()
```

### Многопоточные вычисления
Модуль threading предоставляет класс Thread, соответствующий потоку, а также классы для объектов синхронизации, такие как: блокировки Lock и RLock, Timer, семафоры Semaphore и BoundedSemaphore, условная переменная Condition, событие Event. Кроме этого, для организации очередей — FIFO, LIFO, очередь с приоритетом — применяется модуль queue (Queue в Python 2).

В Python нет средств для завершения или приостановки потоков, а также для освобождения всех блокировок.

Наличие в основной реализации Python глобальной блокировки интерпретатора (англ. Global Interpreter Lock, GIL) сильно ограничивает полезность многопоточных вычислений в счётных задачах.

### Графический интерфейс
В стандартную поставку Python входит графическая библиотека Tkinter.

### Модуль unittest
В Python встроен модуль unittest, который поддерживает автоматизацию тестов, использование общего кода для настройки и завершения тестов, объединение тестов в группы, а также позволяет отделять тесты от фреймворка для вывода информации.

Для автоматизации тестов, unittest поддерживает некоторые важные концепции:

* **Испытательный стенд** (test fixture) - выполняется подготовка, необходимая для выполнения тестов и все необходимые действия для очистки после выполнения тестов. Это может включать, например, создание временных баз данных или запуск серверного процесса.
* **Тестовый случай** (test case) - минимальный блок тестирования. Он проверяет ответы для разных наборов данных. Модуль unittest предоставляет базовый класс TestCase, который можно использовать для создания новых тестовых случаев.
* **Набор тестов** (test suite) - несколько тестовых случаев, наборов тестов или и того и другого. Он используется для объединения тестов, которые должны быть выполнены вместе.
* **Исполнитель тестов** (test runner) - компонент, который управляет выполнением тестов и предоставляет пользователю результат. Исполнитель может использовать графический или текстовый интерфейс или возвращать специальное значение, которое сообщает о результатах выполнения тестов.

Модуль unittest предоставляет богатый набор инструментов для написания и запуска тестов. Однако достаточно лишь некоторых из них, чтобы удовлетворить потребности большинства пользователей.

### Модуль subprocess 
Отвечает за порождение новых процессов, соединение c потоками стандартного ввода, стандартного вывода, стандартного вывода сообщений об ошибках и получение кодов возврата от этих процессов.

### Модуль copy - поверхностное и глубокое копирование объектов
Операция присваивания не копирует объект, он лишь создаёт ссылку на объект. Для изменяемых коллекций, или для коллекций, содержащих изменяемые элементы, часто необходима такая копия, чтобы её можно было изменить, не изменяя оригинал. Данный модуль предоставляет общие (поверхностная и глубокая) операции копирования.

### base64 
Шифрование base64 стало очень популярным в последнее время. Эта библиотека позволяет шифровать бинарные данные в читаемые ASCII символы, а затем обратно раскодировать в бинарные данные. Можно кодировать не только последовательности байт, но и обычные строки.

### difflib
эта библиотека содержит набор функций для сравнения различных последовательностей. Например, можно сравнивать файлы, строки, различную информацию в HTML и многое другое.

### logging
модуль для логирования в программах Python. Библиотека реализует удобную систему логирования, которая используется в стандартных модулях. Ее преимущество в том, что вы можете отключить ведение лога в любой момент одной строчкой или изменить его подробность.

### xml
библиотека, которая помогает анализировать структуры XML, а также добавлять в структуру новые теги, менять значения существующих.

### Мультимедийные модули

# Шаблоны проектирования

>содрано [отсюда](https://tproger.ru/translations/design-patterns-simple-words-1/
), только примеры на Питон перевел

Шаблоны проектирования — это руководства по решению повторяющихся проблем. Это не классы, пакеты или библиотеки, которые можно было бы подключить к вашему приложению и сидеть в ожидании чуда. Они скорее являются методиками, как решать определенные проблемы в определенных ситуациях.

Википедия описывает их следующим образом:

Шаблон проектирования, или паттерн, в разработке программного обеспечения — повторяемая архитектурная конструкция, представляющая собой решение проблемы проектирования, в рамках некоторого часто возникающего контекста.

Будьте осторожны
* шаблоны проектирования не являются решением всех ваших проблем;
* не пытайтесь использовать их в обязательном порядке — это может привести к негативным последствиям. Шаблоны — это подходы к решению проблем, а не решения для поиска проблем;
* если их правильно использовать в нужных местах, то они могут стать спасением, а иначе могут привести к ужасному беспорядку.

## Типы шаблонов
Шаблоны бывают следующих трех видов:

* Порождающие
* [Структурные](#структурные-шаблоны)
* [Поведенческие](#поведенческие-шаблоны)

Многие шаблоны проектирования встроены в Python из коробки, а другие очень просто реализовать, используя базовые возможности языка.

## Порождающие шаблоны
Этот тип особенно важен, когда система зависит не столько от наследования классов, сколько от [композиции](https://habr.com/ru/post/325478/) (композиция — это когда один объект предоставляет другому свою функциональность частично или полностью). Порождающие паттерны отвечают за создание объектов и позволяют системе быть независимой от типов этих самых объектов и от процесса порождения.

В свою очередь, порождающие паттерны делятся на:

* Simple Factory
* Factory Method
* Abstract Factory
* Builder
* Prototype
* Singleton

>Примеры написаны на Python 3, он поддерживает UTF-8. Названия методов и классов на русском языке, чтобы студенты не пугались незнакомых слов, а сосредоточились на логике.

### Паттерн Simple Factory (Простая Фабрика)
В объектно-ориентированном программировании (ООП), фабрика — это объект для создания других объектов. Формально фабрика — это функция или метод, который возвращает объекты изменяющегося прототипа или класса из некоторого вызова метода, который считается «новым».

**Пример из жизни**: Представьте, что вам надо построить дом, и вам нужны двери. Было бы глупо каждый раз, когда вам нужны двери, надевать вашу столярную форму и начинать делать дверь. Вместо этого вы заказываете её на фабрике.

**Простыми словами**: Простая фабрика генерирует экземпляр для клиента, не раскрывая никакой логики.

Паттерн предназначен для инкапсуляции процесса образования объектов с помощью отдельного класса. «Простая Фабрика» удобна, но за простоту приходится платить: привязка к конкретной реализации исключает гибкость системы. Simple Factory следует использовать только там, где архитектура не будет изменяться.

Допустим, у нас есть интерфейс двери (пример переведен с java; в Питоне нет интерфейсов, вместо них можно использовать абстрактные классы, хотя в этом примере абстрактный класс и не нужен, срабоало бы и так из-за утиной типизации Питона):

```py
# в чистом питоне нет абстрактных методов - подключаем модуль abc (Abstract Base Class)
from abc import ABC, abstractmethod

class Дверь(ABC):
    @abstractmethod
    def Ширина(self)->float: pass
    @abstractmethod
    def Высота(self)->float: pass

class ДеревяннаяДверь(Дверь):
    """Класс реализует интерфейс `дверь`"""
    _width=None
    _height=None

    def __init__(self, width: float, height: float):
        self._width = width
        self._height = height

    def Ширина(self)->float:
        return self._width

    def Высота(self)->float:
        return self._height
```

Далее появляется завод, который изготавливает дверь и возвращает ее нам:

```py
class ЗаводДверей():
    @staticmethod
    def СделатьДверь(width: float, height: float):
        return ДеревяннаяДверь(width, height)
```

И только после этого мы можем воспользоваться нашей дверью:

```py
    дверь = ЗаводДверей.СделатьДверь(100, 200)
    print('Ширина:', дверь.Ширина())
    print('Высота:', дверь.Высота())
```

Как видно из кода, вызвав статический метод ``ЗаводДверей.СделатьДверь(100, 200)`` мы получили не экземпляр завода, а экземпляр двери, т.е. получили простую фабрику.

**Когда использовать**: Когда создание объекта — это не просто несколько присвоений, а какая-то логика, тогда имеет смысл создать отдельную фабрику вместо повторения одного и того же кода повсюду.

### Паттерн Fabric Method (Фабричный метод)
**Фабричный метод** — порождающий шаблон проектирования, предоставляющий подклассам интерфейс для создания экземпляров некоторого класса. В момент создания наследники могут определить, какой класс создавать. Иными словами, данный шаблон делегирует создание объектов наследникам родительского класса. Это позволяет использовать в коде программы не специфические классы, а манипулировать абстрактными объектами на более высоком уровне.

**Пример из жизни**: Рассмотрим пример с менеджером по найму. Невозможно одному человеку провести собеседования со всеми кандидатами на все вакансии. В зависимости от вакансии он должен распределить этапы собеседования между разными людьми.

**Простыми словами**: Менеджер предоставляет способ делегирования логики создания экземпляра дочерним классам.

Допустим, у нас есть интерфейс соискателя (метод ``задатьВопрос``):

```py
class Соискатель(ABC):
    @abstractmethod
    def задатьВопрос(self)->str: pass

class Разработчик(Соискатель):
    # перекрываем метод абстрактного класса
    def задатьВопрос(self)->str:
        return 'Спросить о шаблонах проектирования'

class АдминистраторБаз(Соискатель):
    # перекрываем метод абстрактного класса
    def задатьВопрос(self)->str:
        return 'Спросить о MySQL'
```

Теперь создаем менеджера по подбору персонала:

```py
class Менеджер(ABC):
    """Абстрактный класс менеджера"""
    @abstractmethod
    def сделатьСоискателя(self)->Соискатель: 
        """
        абстракный метод, декорирован @abstractmethod
        
        если не декорировать, то линтер будет ругаться на метод получитьОтвет (нет результата)
        плюс при обращении к абстактному методу декоратор выбросит исключение
        """
        pass

    def получитьОтвет(self):
        cоискатель = self.сделатьСоискателя()
        return cоискатель.задатьВопрос()
```

Предоставляем соискателей и реализуем в них метод "сделатьСоискателя" (полиморфизм в действии):

```py
class МенеджерРазработчиков(Менеджер):
    def сделатьСоискателя()->Соискатель:
        return Разработчик()

class МенеджерБаз(Менеджер):
    def сделатьСоискателя()->Соискатель:
        return АдминистраторБаз()
```

После чего можно использовать:

```py
менеджерРазработчиков = МенеджерРазработчиков()
print(менеджерРазработчиков.получитьОтвет())

менеджерБаз = МенеджерБаз()
print(менеджерБазanager.получитьОтвет())

чайник = Менеджер()
print(чайник.получитьОтвет()) # выдаст исключение
```

Обратите внимание: абстрактный класс ``class Менеджер(ABC):`` мы сделали потомком класса ABC, в этом случае и линтер предупредит, что нельзя получать экземпляр абстрактного класса и исключение выбросит что не реализован абстракный метод, а если сделать без родителя (``class Менеджер():``), то линтер предупреждений не выдаст, а при вызове метода ``чайник.получитьОтвет()`` получим исключение "у типа ``None`` нет метода получитьОтвет", т.к. абстрактный метод ``сделатьСоискателя()`` неявно возвращает как раз ``None``

**Когда использовать**: Полезен, когда есть некоторая общая обработка в классе, но необходимый подкласс динамически определяется во время выполнения. Иными словами, когда клиент не знает, какой именно подкласс ему может понадобиться.

### Абстрактная фабрика (Abstract Factory)
**Абстрактная фабрика** — порождающий шаблон проектирования, предоставляет интерфейс для создания семейств взаимосвязанных или взаимозависимых объектов, не специфицируя их конкретных классов. Шаблон реализуется созданием абстрактного класса Factory, который представляет собой интерфейс для создания компонентов системы (например, для оконного интерфейса он может создавать окна и кнопки). Затем пишутся классы, реализующие этот интерфейс.

Пример из жизни: Расширим наш пример про двери из простой фабрики. В зависимости от ваших нужд вам понадобится деревянная дверь из одного магазина, железная дверь — из другого или пластиковая — из третьего. Кроме того, вам понадобится соответствующий специалист: столяр для деревянной двери, сварщик для железной двери и так далее. Как вы можете заметить, тут есть зависимость между дверьми.

Простыми словами: Фабрика фабрик. Фабрика, которая группирует индивидуальные, но связанные/зависимые фабрики без указания их конкретных классов.

Обратимся к коду. Используем пример про двери. Сначала у нас есть интерфейс Door и несколько его реализаций:

```py
class Дверь(ABC):
    @abstractmethod
    def Описание(self)->str: pass

class ДеревяннаяДверь(Дверь):
    def Описание(self)->str:
        return 'Я деревянная дверь'

class ЖелезнаяДверь(Дверь):
    def Описание(self)->str:
        return 'Я железная дверь'
```

Затем у нас есть несколько мастеров по установке для каждого типа дверей:

```py
class УстановщикДверей(ABC):
    @abstractmethod
    def Описание(self)->str: pass

class Слесарь(УстановщикДверей):
    def Описание(self)->str:
        return 'Я работаю только с железными дверьми'

class Столяр(УстановщикДверей):
    def Описание(self)->str:
        return 'Я работаю только с деревянными дверьми'
```

Теперь нам нужна фабрика дверей, которая позволит нам создать семейство связанных объектов. То есть фабрика деревянных дверей предоставит нам деревянную дверь и эксперта по деревянным дверям. Аналогично для железных дверей:

```py
class ФабрикаДверей(ABC):
    @abstractmethod
    def СделатьДверь(self)->Дверь: pass
    @abstractmethod
    def ПредоставитьУстановщика(self)->УстановщикДверей: pass

# Деревянная фабрика вернет деревянную дверь и столяра
class ФабрикаДеревянныхДверей(ФабрикаДверей):
    def СделатьДверь(self)->Дверь:
        return ДеревяннаяДверь()
    def ПредоставитьУстановщика(self)->УстановщикДверей:
        return Столяр()

# Железная фабрика вернет железную дверь и слесаря
class ФабрикаЖелезныхДверей(ФабрикаДверей):
    def СделатьДверь(self)->Дверь:
        return ЖелезнаяДверь()
    def ПредоставитьУстановщика(self)->УстановщикДверей:
        return Слесарь()
```

Пример использования:

```py
фабрикаДеревянныхДверей = ФабрикаДеревянныхДверей()

дверь = фабрикаДеревянныхДверей.СделатьДверь()
установщик = фабрикаДеревянныхДверей.ПредоставитьУстановщика()

print( дверь.Описание() )       # Вывод: Я деревянная дверь
print( установщик.Описание() )  # Вывод: Я работаю только с деревянными дверями

# Аналогично для железной двери
```

Как вы можете заметить, фабрика деревянных дверей инкапсулирует столяра и деревянную дверь, а фабрика железных дверей инкапсулирует железную дверь и слесаря. Это позволило нам убедиться, что для каждой двери мы получим нужного нам установщика.

**Когда использовать**: Когда есть взаимосвязанные зависимости с не очень простой логикой создания.

### Строитель (Builder)
**Строитель** — порождающий шаблон проектирования, который предоставляет способ создания составного объекта. Предназначен для решения проблемы антипаттерна «Телескопический конструктор».

**Пример из жизни**: Представьте, что вы пришли в McDonalds и заказали конкретный продукт, например, БигМак, и вам готовят его без лишних вопросов. Это пример простой фабрики. Но есть случаи, когда логика создания может включать в себя больше шагов. Например, вы хотите индивидуальный сэндвич в Subway: у вас есть несколько вариантов того, как он будет сделан. Какой хлеб вы хотите? Какие соусы использовать? Какой сыр? В таких случаях на помощь приходит шаблон «Строитель».

**Простыми словами**: Шаблон позволяет вам создавать различные виды объекта, избегая засорения конструктора. Он полезен, когда может быть несколько видов объекта или когда необходимо множество шагов, связанных с его созданием.

Давайте я покажу на примере, что такое «Телескопический конструктор». 

```py
def __init__(size, cheese = True, pepperoni = True, tomato = False, lettuce = True):
    pass
```    

Как вы можете заметить, количество параметров конструктора может резко увеличиться, и станет сложно понимать расположение параметров. Кроме того, этот список параметров будет продолжать расти, если вы захотите добавить новые варианты. Это и есть «Телескопический конструктор».

Перейдем к примеру в коде. Адекватной альтернативой будет использование шаблона «Строитель». Сначала у нас есть Бутерброд, который мы хотим создать:

```py
class Бутерброд():
    _размер=None
    _сыр = False
    _колбаса = False
    _салат = False
    _помидор = False

    def __init__(self, бутерброд):
        self._размер = бутерброд.размер
        self._сыр = бутерброд.сыр
        self._колбаса = бутерброд.колбаса
        self._салат = бутерброд.салат
        self._помидор = бутерброд.помидор

    # реализуем приведение к базовому типу, чтобы при печати печаталось не название класса, а вкусняшка    
    def __str__(self):
        res = 'размер {}'.format(self._размер) 
        if self._сыр: res += ', сыр'
        if self._колбаса: res += ', колбаса'
        if self._салат: res += ', салат'
        if self._помидор: res += ', помидор'
        return res
```

Аттрибуты бутерброда приватные, мы не будем его разбирать - употребим целиком.

Затем мы берём «Строителя»:

```py
class СтроительБутербродов():
    размер=None
    сыр = False
    колбаса = False
    салат = False
    помидор = False

    def __init__(self, размер: int):
        self.размер = размер

    def добавитьКолбасу(self):
        self.колбаса = True
        return self

    def добавитьСалат(self):
        self.салат = True
        return self

    def добавитьСыр(self):
        self.сыр = True
        return self

    def добавитьПомидор(self):
        self.помидор = True
        return self

    def создать(self):
        return Бутерброд(self)
```

А вот у строителя аттрибуты публичные, т.к. используются при постронении бутерброда

Пример использования:

```py
бутерброд = СтроительБутербродов(14).\
                добавитьКолбасу().\
                добавитьСалат().\
                добавитьПомидор().\
                создать()
print(бутерброд)

>размер 14, колбаса, салат, помидор
```

**Когда использовать**: Когда может быть несколько видов объекта и надо избежать «телескопического конструктора». Главное отличие от «фабрики» — это то, что она используется, когда создание занимает один шаг, а «строитель» применяется при множестве шагов.

### Прототип (Prototype)
Задаёт виды создаваемых объектов с помощью экземпляра-прототипа и создаёт новые объекты путём копирования этого прототипа. Он позволяет уйти от реализации и позволяет следовать принципу «программирование через интерфейсы». В качестве возвращающего типа указывается интерфейс / абстрактный класс на вершине иерархии, а классы-наследники могут подставить туда наследника, реализующего этот тип.

**Пример из жизни**: Помните Долли? Овечка, которая была клонирована. Не будем углубляться, главное — это то, что здесь все вращается вокруг клонирования.

**Простыми словами**: Прототип создает объект, основанный на существующем объекте при помощи клонирования.

То есть он позволяет вам создавать копию существующего объекта и модернизировать его согласно вашим нуждам, вместо того, чтобы создавать объект заново.

Паттерн Прототип реализован в базовой библиотеке Python посредством интерфейса Cloneable. 
А непосредственно скопировать можно функцией copy из стандартной библиотеки

```py
import copy

class Какойто():
    аттрибут = 1

какойто = Какойто()

сякой = copy.copy(какойто)
сякой.аттрибут = 2
```

### Одиночка (Singleton)
**Одиночка** — порождающий шаблон проектирования, гарантирующий, что в однопроцессном приложении будет единственный экземпляр некоторого класса, и предоставляющий глобальную точку доступа к этому экземпляру.

**Пример из жизни**: В семье всего одна пара тапочек, одеть их может только один человек.

**Простыми словами**: Обеспечивает тот факт, что создаваемый объект является единственным объектом своего класса.

Вообще шаблон одиночка признан антипаттерном, необходимо избегать его чрезмерного использования. Он необязательно плох и может иметь полезные применения, но использовать его надо с осторожностью, потому что он вводит глобальное состояние в ваше приложение и его изменение в одном месте может повлиять на другие части приложения, что вызовет трудности при отладке. Другой минус — это то, что он делает ваш код связанным.

В Питоне паттерн реализуется простым добавлением метода \_\_new\_\_ (мы уже рассматривали этот пример в теме про ООП)

Напишем класс ЧьиТапки :)

```py
class ЧьиТапки():
  obj = None
  имя = None
  def __new__(cls, имя):
    # если экземпляр класса уже создан, то возвращается ссылка на него
    if cls.obj is None:
      cls.obj = object.__new__(cls)
      cls.имя = имя    
    return cls.obj

первый = ЧьиТапки('Елена Прекрасная')
второй = ЧьиТапки('Иван Дурак')

print('чьи тапки: ', второй.имя)
>чьи тапки: Елена Прекрасная
```

## Структурные шаблоны
**Простыми словами**: Структурные шаблоны в основном связаны с композицией объектов, другими словами, с тем, как сущности могут использовать друг друга. Ещё одним объяснением было бы то, что они помогают ответить на вопрос «Как создать программный компонент?».

Список структурных шаблонов проектирования:

* адаптер (Adapter);
* мост (Bridge);
* компоновщик (Composite);
* декоратор (Decorator);
* фасад (Facade);
* приспособленец (Flyweight);
* заместитель (Proxy).

### Адаптер (Adapter)
**Адаптер** — структурный шаблон проектирования, предназначенный для организации использования функций объекта, недоступного для модификации, через специально созданный интерфейс.

**Пример из жизни**: Представим, что у вас на карте памяти есть какие-то изображения и вам надо перенести их на ваш компьютер. Чтобы это сделать, вам нужен какой-то адаптер, который совместим с портами вашего компьютера. В этом случае карт-ридер — это адаптер. Другим примером будет блок питания. Вилку с тремя ножками нельзя вставить в розетку с двумя отверстиями. Для того, чтобы она подошла, надо использовать адаптер. Ещё одним примером будет переводчик, переводящий слова одного человека для другого.

**Простыми словами**: Шаблон позволяет обернуть несовместимые объекты в адаптер, чтобы сделать их совместимыми с другим классом.

Обратимся к коду. Представим гипотетичекий миномет, стреляющий обычными минами.
 
```py
class Мина():
    _калибр = 10

class Миномет():
    _калибр = 10

    def Зарядить(self, мина):
        # чтобы влезло, нужно,чтобы калибр совпал
        if self._калибр == мина._калибр:
            return True
        else:
            return False
```

Все было хорошо, но яйцеголовые умники изобрели супер-пупер взрывчатку и новые мины стали размером с карандаш (на вес внимания не обращаем). А на складах минобороны этих минометов как у дурака махорки. Те-же умники быстро родили адаптер для выстрела, чтобы совпадало со старым калибром.

```py
class СуперМина():
    _калибр = 1

# Адаптер, чтобы калибры совпадали
class АдаптерДляСуперМины(Мина):
    ОБМОТАТЬ_ИЗОЛЕНТОЙ = 9
    def __init__(self, супер_мина):
        self._калибр = супер_мина._калибр+self.ОБМОТАТЬ_ИЗОЛЕНТОЙ
```

Способ применения:

```py
мина = Мина()
суперМина = СуперМина()
миномет = Миномет()

if миномет.Зарядить(мина):
    print('обычная мина заряжена')    

if not миномет.Зарядить(суперМина):
    print('гранаты не той системы')    

адаптер = АдаптерДляСуперМины(суперМина)

if миномет.Зарядить(адаптер):
    print('супер-мина заряжена')    
```

### Мост (Bridge)
**Мост** — структурный шаблон проектирования, используемый в проектировании программного обеспечения чтобы разделять абстракцию и реализацию так, чтобы они могли изменяться независимо. Шаблон мост использует инкапсуляцию, агрегирование и может использовать наследование для того, чтобы разделить ответственность между классами.

**Пример из жизни**: Представим, что у вас есть сайт с разными страницами, и вам надо разрешить пользователям менять их тему. Что вы будете делать? Создавать множественные копии каждой страницы для каждой темы или просто отдельную тему, которую пользователь сможет выбрать сам? Шаблон мост позволяет вам сделать второе.

**Простыми словами**: Шаблон мост — это предпочтение композиции над наследованием. Детали реализации передаются из одной иерархии в другой объект с отдельной иерархией.

Обратимся к примеру в коде. Возьмем пример с нашими страницами. У нас есть иерархия ВебСтраничка:

```py
class ВебСтраничка(ABC):
    @abstractmethod
    def __init__(self, тема): pass
    @abstractmethod
    def получитьСодержимое(self): pass

class ОНас(ВебСтраничка):
    _тема=None

    def __init__(self, тема):
        self._тема = тема

    def получитьСодержимое(self):
        return "Страница с информацией в " + self._тема.цвет()

class Новости(ВебСтраничка):
    _тема=None

    def __init__(self, тема):
        self._тема = тема

    def получитьСодержимое(self):
        return "Страница с новостями в " + self._тема.цвет()
```

И отдельная иерархия Тема:

```py
class Тема(ABC):
    @abstractmethod
    def цвет(self): pass

class ТёмнаяТема(Тема):
    def цвет(self):
        return 'темной теме'

class СветлаяТема(Тема):
    def цвет(self):
        return 'светлой теме'
```

Применение в коде:

```py
тёмнаяТема = ТёмнаяТема()
светлаяТема = СветлаяТема()

новости = Новости(тёмнаяТема)
оНас = ОНас(светлаяТема)

print(новости.получитьСодержимое()) # "Страница с новостями в темной теме"
print(оНас.получитьСодержимое()) # "Страница с информацией в светлой теме"
```

### Компоновщик (Composite)
**Компоновщик** — структурный шаблон проектирования, объединяющий объекты в древовидную структуру для представления иерархии от частного к целому. Компоновщик позволяет клиентам обращаться к отдельным объектам и к группам объектов одинаково. Паттерн определяет иерархию классов, которые одновременно могут состоять из примитивных и сложных объектов, упрощает архитектуру клиента, делает процесс добавления новых видов объекта более простым.

**Пример из жизни**: Каждая организация скомпонована из сотрудников. У каждого сотрудника есть одинаковые свойства, такие как зарплата, обязанности, отчётность и т.д.

**Простыми словами**: Шаблон компоновщик позволяет клиентам работать с индивидуальными объектами в едином стиле.

Обратимся к коду. Возьмем наш пример с рабочими. У нас есть Работники разных типов:

```py
from abc import ABC, abstractmethod

class Исполнитель(ABC):
    @abstractmethod
    def можетВыполнить(self, задача)->bool: pass
    @abstractmethod
    def получитьЗадание(self, задача): pass

class Работник(Исполнитель):
    def __init__(self, имя):
        self.имя = имя
    def можетВыполнить(self, задача)->bool:
        return True
    def получитьЗадание(self, задача):
        print('{} получил задачу {}'.format(self.имя, задача))

class Команда(Исполнитель):
    _исполнители=set()

    # вспомогательные методы для управления композитом:
    def добавить(self, исполнитель):
        self._исполнители.add(исполнитель)
        return self
    def удалить(self, исполнитель):
        self._исполнители.discard(исполнитель)
        return self

    # методы интерфейса Уполномоченный
    def можетВыполнить(self, задача)->bool:
        for исполнитель in self._исполнители:
            if исполнитель.можетВыполнить(задача): return True
        return False
  
    def получитьЗадание(self, задача):
        # может быть разная реализация - допустим, некоторые задания требуют нескольких человек из команды одновременно
        # или работники могут быть заняты...
        # в простейшем случае берем первого работника (и удяляем его из команды)
        исполнитель = self._исполнители.pop()
        исполнитель.получитьЗадание(задача)
```

Еще у нас есть Начальник:

```py
class Начальник():
    _исполнители = set()
    def __init__(self, исполнители):
        self._исполнители.update(исполнители)
    def датьЗадание(self, задача):
        for исполнитель in  self._исполнители:
            if исполнитель.можетВыполнить(задача):
                исполнитель.получитьЗадание(задача)
                # из команды сами рассосуться
                if type(исполнитель) == Работник:
                    self._исполнители.discard(исполнитель)
                return
        raise Exception('не нашел исполнителя для задачи')
```

Способ применения (в моей реализации работники удаляются, но можно просто добавить флаг занятости, зависящий от задачи):

```py
трус = Работник('трус')
балбес = Работник('балбес')
бывалый = Работник('бывалый')

собутыльники = Команда().добавить(трус).добавить(балбес)

степан_степаныч = Начальник({собутыльники, бывалый})

try:
    степан_степаныч.датьЗадание('вскопать грядку')
    степан_степаныч.датьЗадание('наколоть дров')
    степан_степаныч.датьЗадание('наносить воды')
    степан_степаныч.датьЗадание('написать отчет')
except Exception as e:
    print('что-то случилось: ', e)
```

На выходе получим что-то подобное:

```
балбес получил задачу вскопать грядку
трус получил задачу наколоть дров
бывалый получил задачу наносить воды
что-то случилось:  не нашел исполнителя для задачи    
```

остановился тут

## Поведенческие шаблоны
Поведенческие паттерны отвечают за эффективное взаимодействие объектов. В отличие от структурных, они также затрагивают шаблоны для обмена сообщениями.

Эта группа решений объясняет, как организовывать связи между объектами. Банда четырех определила 11 моделей поведения. Среди них Итератор, Цепочка обязанностей и Команда.

### Итератор
Итераторы встроены в Python. Это одна из самых мощных возможностей языка. Во многом именно итераторы делают его таким удобным. Чтобы разобраться в паттерне Итератор, следует просто изучить механизм работы итераторов и генераторов языка.

[содержание](/readme.md)  
