[содержание](/readme.md)  

# Тема 9. Стандартная библиотека Python.
Стандартная библиотека Питона весьма обширна и включает в себя множество инструментов. Она содержит как встроенные модули (написанные на Си), предоставляющие доступ к системным функциям, таким как операции ввода-вывода, так и модули, написанные на Питоне, предлагающие стандартные решения для множества задач, возникающих в программировании.

В библиотеке содержится несколько видов компонентов.

В ней определены типы данных, которые часто принято считать частью «ядра» языка, например числа и списки. Для таких типов форма литералов и некоторые ограничения употребления задаются ядром (например, орфография и приоритет операций).

Библиотека также содержит встроенные функции и исключения — эти объекты не нужно импортировать откуда-либо, чтобы ими воспользоваться.

Однако, основная часть библиотеки состоит из набора модулей. Этот набор можно классифицировать по-разному. Некоторые модули написаны на Си и являются частью интерпретатора; другие написан на Питоне и импортируются в исходном коде. Некоторые модули предоставляют интерфейсы, специфичные для Питона (например, вывод трассировки стека); другие — интерфейсы для взаимодействия с конкретными операционными системами (например, обращение к аппаратному обеспечению); третьи — интерфейсы для конкретной предметной области (например, веб). Одни модули доступны во всех версиях и дистрибутивах Питона; другие — только тогда, когда ОС поддерживает их; помимо этого, существуют и такие, доступность которых определяется конфигурацией при компиляции интерпретатора.

## Встроенные функции
Для использования перечисленных ниже функций не требуется импортировать какие-либо модули. Это функции, доступные в Питоне «из коробки».

Полный список встроенных объектов можно получить следующим образом:
```py
    names = globals()['__builtins__'].__dict__.keys()
    builtins = sorted([name for name in names if not name.startswith('_')])
```
Обратите внимание, что кроме имён функций код, приведенный выше, возвращает имена и других встроенных объектов (типов данных, исключений и пр.).

функция | параметры | результат | краткое описание
:------:|:---------:|:---------:|-----------------
abs     |	int, float|int, float | Возвращает абсолютную величину.
all     | iterable  | bool      |	Проверяет, все ли указанные элементы принимают значение «истина».
any	    | iterable  | bool      | Проверяет, есть ли среди указанных элементов хотя бы один, принимающий значение «истина»
ascii	  | object    | str       | Возвращает строковое представление объекта с экранированными не-ASCII символами
bin	    | int       | str       | Преобразует целое число в двоичную строку.
callable|	obj       | bool      | Возвращает True для объекта, поддерживающего вызов.
chr	    | int       | str       | Возвращает символ по его числовому представлению.
classmethod | function |        |	Представляет указанную функцию методом класса.
cmp	    | obj, obj     | int       | Сравнивает два объекта, по итогу возвращает целое.
compile	| str       | obj \| АСД| Компилирует исходный код в объект кода, либо объект АСД.
delattr	| obj, name:&nbsp;str|       | Удаляет из объекта указанный атрибут.
dir	    | [obj] | list | Возвращает имена переменных, доступные в локальной области, либо атрибуты указанного объекта в алфавитном порядке
divmod	| obj, obj | tuple (частное,&nbsp;остаток) | Для целочисленного деления возвращает пару частное-остаток от деления аргументов
enumerate	| iterable [,start=0] | generator | Возвращает генератор, отдающий пары счётчик-элемент для элементов указанной последовательности<br/>``for idx, item in enumerate(iterable):``
eval | expression, globals=None, locals=None | any | Разбирает и исполняет указанное выражение.
exec | obj[, globals[, locals]] | any |	Динамически исполняет указанный код.
filter | func, iterable | list, tuple, string | При помощи указанной функции фильтрует элементы переданного объекта.
format | value \[,&nbsp;format_spec\] | str |	Форматирует указанное значение.
getattr | obj, name \[,&nbsp;default\] | any | Возвращает значение атрибута объекта.
globals	| | dict | Возвращает словарь с глобальной таблицей символов, определённых в модуле
hasattr	| obj, name | bool | Возвращает флаг, указывающий на то, содержит ли объект указанный атрибут
hash | obj | int | Возвращает хеш указанного объекта.
help | \[obj\] | stdout |	Вызывает встроенную справочную систему.
hex	| int | str | Возвращает строку с шестнадцатеричным представлением указанного целого
id | obj | int | Возвращает идентификатор указанного объекта.
input | \[prompt\] | str |	Считывает и возвращает строку входных данных.
isinstance | obj, classinfo | bool | Возвращает флаг, указывающий на то, является ли указанный объект экземпляром указанного класса (классов)
issubclass | cls, classinfo | bool |	Возвращает флаг, указывающий на то, является ли указанный класс подклассом указанного класса (классов)
iter | obj[, sentinel] | iterator |	Возвращает объект итератора.
len | obj | in | Возвращает число элементов в указанном объекте-контейнере.
locals | | dict |	Возвращает словарь, представляющий текущую локальную таблицу символов.
map | func, iterable, ... | iterator \| list | Применяет указанную функцию к каждому элементу указанной последовательности/последовательностей
max | iterable, *args[, key, default] | any |	Возвращает элемент с наибольшим значением из переданных в функцию.
min	| iterable, *args[, key, default] | any | Возвращает элемент с наименьшим значением из переданных в функцию.
next | iter[, default] | any | Возвращает следующий элемент итератора.
oct | int | str |	Возвращает строку с восмеричным представлением указанного целого.
open | file, mode='r', buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None | file	| Открывает файл и возвращает представляющий его объект.
ord	| str | int | Возвращает числовое представление для указанного символа.
pow	| x, y\[,&nbsp;z\] | число | Возвращает результат возведения числа в степень, с опциональным делением по модулю
print | *objs, sep=' ', end='\n', file=sys.stdout, flush=False | stdout \| file |	Отправляет указанные объекты текстовым потоком в файл.
repr | obj | str |	Возвращает формальное строковое представление указанного объекта.
reversed | iterable | iterator | Возвращает обратный итератор по указанной последовательности.
round	| float, ndigits=0 | float | Возвращает число с плавающей запятой, округлённое до указанного количества цифр после запятой
setattr	| obj, name, value | | Добавляет объекту указанный атрибут.
sorted | iterable [,&nbsp;key \[,&nbsp;reverse\]] | list | Возвращает новый отсортированный список, составленный из элементов итерирующегося объекта
staticmethod | function | |	Представляет указанную функцию статичным методом.
sum	| iterable[, start] | any | Суммирует элементы указанного объекта и возвращает результат.
super	| [type[, object-or-type]] | any | Возвращает объект-посредник (прокси), делегирующий вызовы методов родителю или собрату класса указанного типа
vars | \[obj\] | dict | Возвращает словарь из атрибута __dict__ указанного объекта.
zip | *iterables | iterator \| list |	Возвращает итератор по кортежам, где i-тый кортеж содержит i-тый элемент каждой из указанных последовательностей

Что-то из этого мы уже знаем, с остальным детально ознакомимся на практических занятиях

## Стандартная библиотека Питона
Для того чтобы перечислить все функции библиотеки у нас не хватит ни времени ни памяти. Полный список всегда можно посмотреть [тут](https://docs.python.org/3.7/library/index.html), а мы пройдемся по верхушкам, останавливаясь только на самых интересных модулях.


### Модуль sys
В этом модуле содержатся функции и константы для взаимодействия с интерпретатором Python. В этом модуле, в том числе, содержатся следующие переменные:

argv — аргументы командной строки,
byteorder — порядок байтов платформы, 'little' или 'big',
flags — объект, предоставляющий в виде атрибутов информацию о флагах, данных интерпретатору. Например, sys.flags.debug говорит о режиме отладки,
maxint — максимальное целое,
platform — идентификатор платформы, например, 'linux-i386',
stdin, stdout, stderr — стандартные потоки ввода, вывода и вывода ошибок,
version — строка с версией,
и другие.

### Модуль contextlib
Модуль содержит вспомогательные функции для поддержки оператора with.

Пример использования менеджера контекста, при котором открытый файл автоматически закрывается:

```py
with open('myfile.dat', 'wb') as fh:
    fh.write('Мои данные')
```

В примере выше был использован встроенный в Python менеджер контекста. API менеджера контекста состоит из двух методов:

Метод __enter__ вызывается при входе в блок with. Возвращает объект, который получает параметр, заданный as,
Метод __exit__ вызывается при выходе управления за пределы блока with.
Модуль contextlib предлагает декоратор для создания контекстного менеджера на базе генератора:

```py
from contextlib import contextmanager
@contextmanager
def my_context():
    try:
        yield myvalue  # значение для as
    except MyError, e:
        # обработка исключения
    finally:
        # выполняется при любом исходе
```

### Модуль abc
Модуль определяет метакласс ABCMeta и декораторы abstractmethod и abstractproperty для определения новых абстрактных базовых классов (англ. abstract base class). Следует отметить, что абстрактный базовый класс понимается здесь в ином смысле, нежели в C++.

### Типы данных
Стандартная библиотека расширяет набор доступных Python типов данных. Имеются отдельные типы данных для даты и времени, массива, кучи, очереди, слабые ссылки, а также так называемые абстрактные базовые типы из модуля collections.

### Модуль datetime
Модуль datetime предоставляет пять классов: дата (date), время (time), комбинация даты и времени (datetime), разность дат и времени (timedelta) и временная зона (tzinfo).

В следующем примере печатается экземпляр datetime, фиксирующий дату и время в момент вызова метода now():

```py
import datetime
datetime.datetime.now()
datetime.datetime(2013, 5, 11, 19, 47, 25, 375511)
```

### Модуль collections
Данный модуль включает в себя набор специальных типов данных — контейнеров, которые дополняют стандартные встроенные типы dict, list, set и tuple. Например для Python 2.7: OrderedDict — упорядоченный (в порядке добавления элементов) словарь, defaultdict — словарь, вызывающий заданную функцию для отсутствующего в нём элемента, Counter — словарь, который удобно использовать для подсчёта слов, Deque — двусвязный список, namedtuple — кортеж с возможностью доступа к элементам по именам атрибутов. Также имеются абстрактные базовые классы Container, Sequence, Set, Mapping и другие.

Пример, демонстрирующий работу с дэком:

```py
from collections import deque
d = deque('123')
d[1]
>'2'
d.pop()
>'3'
d.appendleft('0')
list(d)
>['0', '1', '2']
```

### Взаимодействие с ОС
### Модуль os
Модуль предоставляет функции переносимого интерфейса к основным сервисам операционной системы, определяет некоторые переменные (например, environ для доступа к переменным окружения).

### Модуль os.path
Модуль служит для манипуляций с путями к файлам в независимом от вида платформы. Пример иллюстрирует использование некоторых функций модуля:

```py
import os.path
os.path.join("/tmp/1", "temp.file")  # конкатенация путей
>'/tmp/1/temp.file'
os.path.dirname("/tmp/1/temp.file")  # имя каталога по заданному полному пути
>'/tmp/1'
os.path.basename("/tmp/1/temp.file")  # имя файла по заданному полному пути
>'temp.file'
os.path.normpath("/tmp//2/../1/temp.file")  # нормализация пути 
>'/tmp/1/temp.file'
os.path.exists("/tmp/1/temp.file")  # существует ли путь?
>False
```

### Обработка текстов
Стандартная библиотека содержит несколько модулей для работы со строками и обработки текстов, включает в себя следующие возможности.

### Полезные константы и функции из модуля string
Модуль содержит различные константы, которые можно использовать при обработке текстов, например: ascii_letters (строка, содержащая все буквы из набора ASCII), ascii_lowercase, digits (строка с цифрами от 0 до 9), letters (буквы, зависят от установки локали) и т. п.

```py
from string import ascii_letters, ascii_lowercase, ascii_uppercase, digits
ascii_letters
>'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'
ascii_lowercase
>'abcdefghijklmnopqrstuvwxyz'
ascii_uppercase
>'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
digits
>'0123456789'
```

Сгенерировать пароль:

```py
chars = ascii_letters + digits
from random import choice
n = 8                            # длина пароля
''.join(choice(chars) for _ in range(n))
>'ia1KGm2t'
```

Для упрощения подстановки в строки по ключевым словам могут использоваться экземпляры класса Template. Пример иллюстрирует методы substitute и safe_substitute:

```py
from string import Template
tpl = Template("""${name} has ${amount}$$. {oh}""")
tpl.substitute({"amount": 100, "name": "John"})
>'John has 100$. {oh}'
tpl.safe_substitute({"amount": 100})
>'${name} has 100$. {oh}'
# Для сравнения синтаксиса, метод format для строки: 
"""{name} has {amount}$. {{oh}}""".format(**{"amount": 100, "name": "John"})
>'John has 100$. {oh}'
```

### Поддержка регулярных выражений: модуль re
Регулярные выражения являются мощным средством обработки текста. Модуль **re** содержит функции для замены (sub), разбиения строки (split), сравнения строки с шаблоном (match, search), поиска (finditer, findall) и определяет классы для скомпилированного регулярного выражения и результата сравнения. 

Регулярное выражение (re, regexp) позволяет описать некоторое множество строк при помощи шаблона для дальнейшего определения того, входит ли какая-либо строка в этом множество. Данный модуль предоставляет инструменты для работы с регулярными выражениями, подобные тем, которые можно обнаружить в языке Perl.

Как шаблоны так и строки, по которым производится поиск, могут являться и строками Юникод (str) и 8-битными строками (bytes)

В регулярных выражениях обратный слеш (``\``) используется для обозначения специальных форм или спецсимволов, что конфликтует со сценариями использования его в Питоне. Например, для обозначения регулярного выражения ``\\`` потребуется указать строковый литерал шаблона ``\\\\``, потому что обратный слеш в литерале потребует экранирования.

Дабы избежать необходимости экранирования, в качестве шаблонов регулярных выражений можно использовать сырые строки Питона (строки с префиксом r). Например: r'\n' — это строка из двух символов (\ и n), а '\n' — это строка из одного символа, обозначающего переход на новую строку. Шаблоны регулярных выражений в Питоне часто используют сырые строки.

Многие инструменты, предлагаемые модулем, доступны как в виде функций, так и в виде методов объектов скомпилированных регулярных выражений. Функции предлагают короткий путь (при их использовании нет необходимости компилировать объект регулярного выражения), жертвуя при этом параметрами для более тонкой настройки.

```py
import re
compiled_re = re.compile(r"[a-b][0-9]*")
[m.group(0) for m in compiled_re.finditer("A1 c123 a12, b abc (b987).")]
>['a12', 'b', 'a', 'b', 'b987']
```

### Работа с байтовыми структурами в модуле struct
Модуль struct служит для конвертирования данных из строк байтов и типами данных языка Python и может применяться при работе с форматами бинарных файлов и коммуникационными протоколами. Функции pack и unpack позволяют «упаковывать» и «распаковывать» данные на основе строки формата, состоящей их кодов форматирования.

### array
Модуль предоставляет инструменты для работы с массивами.
В этом модуле определён тип array, позволяющий компактно размещать в памяти массивы, состоящие из объектов базовых типов: символы, целые, числа с плавающей запятой

>Если требуется максимально эффективная работа с массивами, следует воспользоваться типом array из пакета NumPy

Массивы, являясь последовательностью, очень похожи на списки, однако налагают ограничения на типы хранящихся в них объектов. Тип задаётся на этапе создания массива при помощи буквенного обозначения.

### Форматы данных
#### CSV
Для чтения и записи файла в формате CSV предназначен модуль csv. Этот модуль предназначен для работы с различными диалектами: разделитель-запятая, разделитель — точка с запятой, разделитель — табуляция (Excel).

#### Работа с файловыми архивами
В стандартной библиотеке имеется поддержка для нескольких форматов архивов в виде следующих модулей: bz2 (bzip2), gzip (gzip), tarfile (tar), zipfile (zip), а также привязки к библиотеке zlib в виде модуля zlib.

В следующем примере в файле archive.zip будет заархивирован файл file.txt, содержащий текст «text in the file». Это ещё один пример использования менеджера контекста.

```py
from zipfile import ZipFile
with ZipFile('archive.zip', 'w') as ziparc:
     ziparc.writestr('file.txt', 'text in the file')
```

Чтение архива происходит аналогично. В следующем примере будут напечатаны имена файлов, содержащиеся в архиве:

```py
from zipfile import ZipFile
with ZipFile('archive.zip', 'r') as ziparc:
     for fileinfo in ziparc.filelist:
         print(fileinfo.filename)
```

#### Конфигурационные файлы
Для чтения и записи конфигурационных файлов предназначен модуль ConfigParser. Этот модуль написан на чистом Python и, следовательно, платформонезависим. Синтаксис конфигурационных файлов похож на тот, что используется в INI-файлах Windows.

#### Модуль shutil 
Cодержит набор функций для обработки файлов, групп файлов, и папок. В частности, копировать, перемещать и удалять файлы и папки.

### Криптографические модули
В силу различных причин (в том числе политических — во многих странах запрещена разработка и распространение криптографического программного обеспечения без разрешения соответствующих государственных структур) поддержка криптографии в стандартной библиотеке Python ограничена и сводится к хеш-функциям.

В версии 2.5 структура криптобиблиотеки была унифицирована — все хеш-функции собраны в модуль hashlib и удалены бесполезные модули некриптостойкого шифрования. Ранние модули md5, hmac, sha объявлены устаревшими и будут удалены в одном из последующих релизов.

Как и в некоторых других случаях (DB-API, Python Web Server Gateway Interface), при невозможности (или нецелесообразности) включить полноценную поддержку технологии в стандартную библиотеку, были приняты стандарты на интерфейсы, предоставляемые внешними библиотеками, — API для хеш-функций, API для блочных шифров. Однако, далеко не все библиотеки соответствуют этим требованиям (либо в силу старости — созданы до написания CryptoAPI, либо из-за того, что являются автоматически сгенерированными обёртками поверх соответствующих библиотек C).

Использовать CryptoAPI-совместимые библиотеки достаточно просто:

```py
import hashlib
m = hashlib.new('md5')      # создаем новый хеширующий объект с MD5 функцией
m = hashlib.md5()           # либо так
m.update("test data")       # добавляем данные
m.digest()
>'\xebs:\x00\xc0\xc9\xd36\xe6V\x91\xa3z\xb5B\x93'
m.hexdigest()
>'eb733a00c0c9d336e65691a37ab54293'
```

hashlib обеспечивает поддержку следующих хеш-функций: MD5, SHA-1, SHA224, SHA256, SHA384, SHA512 (в сборках Python со включённой библиотекой OpenSSL этот список шире). Следует отметить, что одно только присутствие алгоритма в стандартной библиотеке не гарантирует его криптографическую надёжность. Так, алгоритмы MD5 и SHA-1 не являются криптостойкими.

Для шифрования приходится использовать сторонние библиотеки, например, pycrypto (соответствует CryptoAPI) или M2Crypto (не соответствует CryptoAPI). Достаточно полный список представлен в PyPI.

### Сетевые протоколы
В стандартной библиотеке присутствуют модули для работы с сетевыми протоколами HTTP (и клиент, и простейший сервер), FTP, XML-RPC, SMTP, IMAP, NNTP и другие.

### html, http
эти модули работают в одной и той же области. Модуль http позволяет работать с интернет ресурсами по протоколу HTTP, отправлять запросы GET/POST, принимать запросы, обрабатывать Cookie и фактически реализовать свой клиент или сервер на Python. Библиотека html, в свою очередь, позволяет выполнять разбор html страниц.

### email
python поддерживает обработку email сообщений на уровне языка. Модуль не реализует никаких методов для отправки сообщений через SMTP или NNTP, этим занимаются другие протоколы. Здесь есть функции для разбора структуры email сообщений, проверки списка почты, преобразования и много другого.

### Модуль smtplib
Модуль предназначен для отправки сообщений электронной почты посредством протокола SMTP.

```py
import smtplib

def send_email(text):
    server = smtplib.SMTP("smtp.server", 587)  # подключение к серверу
    server.ehlo()
    server.starttls()
    server.login("login", "password")  # логинимся на сервер
    message = "\r\n".join([   # формируем сообщение Email с полями
        "From: от кого", 
        "To: кому", 
        "Subject: тема", 
        "", 
        text,
        ])
    server.sendmail("login@server", "адрес почты получателя", message)  # отправляем
    server.quit()  # разлогиниваемся с сервера

send_email('Hello, World!')
```

### Базы данных
#### Простые базы данных
Python поддерживает доступ к файлам в DBM-формате: Unix (n)dbm (модуль dbm в Python 2.x или dbm.ndbm в Python 3), GNU DBM (модуль gdbm), модуль, написанный на чистом Python, dumbdbm.

Работа с объектом базы данных происходит аналогично работе со словарём Python (на примере dumbdbm):

```py
import dumbdbm
d = dumbdbm.open('my.db', 'w')  # открыть файл базы данных
d['key'] = 'value'              # присвоить значение по ключу
v = d['key']                    # получить значение по ключу
d.sync()                        # записать изменения
d.close()                       # закрыть базу данных
```

Для долговременного хранения объектов Python можно использовать модуль shelve (рус. "поставить на полку").

#### SQLite
SQLite — это встраиваемая кроссплатформенная БД, которая поддерживает достаточно полный набор команд SQL и доступна в исходных кодах (на языке C). Начиная с Python 2.5, библиотека sqlite3 поставляется вместе с интерпретатором языка Python.

Для работы с библиотекой нужно создать объект Connection , который выступает в роли базы данных:

```py
import sqlite3
conn = sqlite3.connect('example.db')
c = conn.cursor()

# Создаем таблицу
c.execute('''CREATE TABLE stocks
             (date text, trans text, symbol text, qty real, price real)''')

# Вставляем строку
c.execute("INSERT INTO stocks VALUES ('2006-01-05','BUY','RHAT',100,35.14)")

# Сохраняем (и записываем) изменения
conn.commit()

# После окончания работы мы можем закрыть соединение с ДБ
conn.close()
```

### Многопоточные вычисления
Модуль threading предоставляет класс Thread, соответствующий потоку, а также классы для объектов синхронизации, такие как: блокировки Lock и RLock, Timer, семафоры Semaphore и BoundedSemaphore, условная переменная Condition, событие Event. Кроме этого, для организации очередей — FIFO, LIFO, очередь с приоритетом — применяется модуль queue (Queue в Python 2).

В Python нет средств для завершения или приостановки потоков, а также для освобождения всех блокировок.

Наличие в основной реализации Python глобальной блокировки интерпретатора (англ. Global Interpreter Lock, GIL) сильно ограничивает полезность многопоточных вычислений в счётных задачах.

### Графический интерфейс
В стандартную поставку Python входит графическая библиотека Tkinter.

### Модуль unittest
В Python встроен модуль unittest, который поддерживает автоматизацию тестов, использование общего кода для настройки и завершения тестов, объединение тестов в группы, а также позволяет отделять тесты от фреймворка для вывода информации.

Для автоматизации тестов, unittest поддерживает некоторые важные концепции:

* **Испытательный стенд** (test fixture) - выполняется подготовка, необходимая для выполнения тестов и все необходимые действия для очистки после выполнения тестов. Это может включать, например, создание временных баз данных или запуск серверного процесса.
* **Тестовый случай** (test case) - минимальный блок тестирования. Он проверяет ответы для разных наборов данных. Модуль unittest предоставляет базовый класс TestCase, который можно использовать для создания новых тестовых случаев.
* **Набор тестов** (test suite) - несколько тестовых случаев, наборов тестов или и того и другого. Он используется для объединения тестов, которые должны быть выполнены вместе.
* **Исполнитель тестов** (test runner) - компонент, который управляет выполнением тестов и предоставляет пользователю результат. Исполнитель может использовать графический или текстовый интерфейс или возвращать специальное значение, которое сообщает о результатах выполнения тестов.

Модуль unittest предоставляет богатый набор инструментов для написания и запуска тестов. Однако достаточно лишь некоторых из них, чтобы удовлетворить потребности большинства пользователей.

### Модуль subprocess 
Отвечает за порождение новых процессов, соединение c потоками стандартного ввода, стандартного вывода, стандартного вывода сообщений об ошибках и получение кодов возврата от этих процессов.

### Модуль copy - поверхностное и глубокое копирование объектов
Операция присваивания не копирует объект, он лишь создаёт ссылку на объект. Для изменяемых коллекций, или для коллекций, содержащих изменяемые элементы, часто необходима такая копия, чтобы её можно было изменить, не изменяя оригинал. Данный модуль предоставляет общие (поверхностная и глубокая) операции копирования.

### base64 
Шифрование base64 стало очень популярным в последнее время. Эта библиотека позволяет шифровать бинарные данные в читаемые ASCII символы, а затем обратно раскодировать в бинарные данные. Можно кодировать не только последовательности байт, но и обычные строки.

### difflib
эта библиотека содержит набор функций для сравнения различных последовательностей. Например, можно сравнивать файлы, строки, различную информацию в HTML и многое другое.

### logging
модуль для логирования в программах Python. Библиотека реализует удобную систему логирования, которая используется в стандартных модулях. Ее преимущество в том, что вы можете отключить ведение лога в любой момент одной строчкой или изменить его подробность.

### xml
библиотека, которая помогает анализировать структуры XML, а также добавлять в структуру новые теги, менять значения существующих.

### Мультимедийные модули


[содержание](/readme.md)  
