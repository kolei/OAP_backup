# Тема 4. Процедуры и функции. Работа с файлами. 
# Лекции 3 и 4

[К ini-файлам](#INI)

>Небольшой прыжок в сторону.</br>
Строки мы уже прошли мимо, но подробно на всех функциях не остановились, а следующая тема подразумевает плотную работу именно со строками. Восполним пробел.

<a name="str"></a>

# Операции над строками (окончание)
Ниже будут рассмотрены не все методы, а только самые, на мой взгляд, востребованные. Вы всегда можете посмотреть в справочнике описание незнакомого метода.

## str.capitalize() -> str
Возвращает копию строки, делая первую букву заглавной. Полезно при выводе форм с ФИО пользователя (в комбинации с методом lower()).
```py
'вася'.capitalize()
>Вася
```

## str.center(width[, fillchar=' ']) -> str
Позиционирует по центру указанную строку, дополняя её справа и слева до указанной длины указанным символом. Полезна при формировании отчетов.

**width** - Желаемая минимальная длина результирующей строки.</br>
**fillchar** - Символ, которым следует расширять строку. По умолчанию — пробел.

*Изначальная строка не обрезается, даже если в ней меньше символов, чем указано в параметре желаемой длины.*

```py
'1'.center(5,'*')
>**1**

'пупкин'.center(5,'*')
>пупкин #добавлять некуда, но и не образалась
```

## str.count(sub[, start=0[, end=None]]) -> int

Возвращает количество вхождений указанной подстроки.

**sub** - Подстрока, количество вхождений которой следует вычислить.</br>
**start** - Позиция в строке, с которой следует начать вычислять количество вхождений подстроки. По-умолчанию ищет с начала строки.</br>
**end** - Позиция в строке, на которой следует завершить вычислять количество вхождений подстроки.

Позиции начала и конца трактуются также как в срезах. Т.е. последний номер не считается.

## str.encode([encoding[, errors='strict']]) -> (bytes в Python 3 | str в Python 2)
Кодирует строку в байтстроку, используя зарегистрированный кодек.

**encoding** - Название кодировки. По умолчанию — системная кодировка, доступная из sys.getdefaultencoding().</br>
**errors** - Наименование схемы обработки ошибок. По умолчанию — strict.

>Имена доступных кодировок лучше всего узнавать из [документации к модулю codecs](https://docs.python.org/3.7/library/codecs.html#standard-encodings).

```py
from sys import getdefaultencoding
# Python 3 ====================
getdefaultencoding()  # utf-8
# Python 2 ====================
getdefaultencoding()  # ascii

my_string = 'кот cat'

my_string.encode() # b'\xd0\xba\xd0\xbe\xd1\x82 cat'

my_string.encode('ascii') # UnicodeDecodeError

my_string.encode('ascii', errors='ignore') # b' cat'

my_string.encode('ascii', errors='replace')  # b'??? cat'
```

Выше рассмотрены далеко не все варианты кодировок и схем обработки ошибок. Самостоятельно изучите [примеры](http://pythonz.net/references/named/str.encode/)


## str.find(sub[, start=0[, end=None]]) -> int
Возвращает наименьший индекс, по которому обнаруживается начало указанной подстроки в исходной (т.е. ищет начало подстроки в строке).

**sub** - Подстрока, начальный индекс размещения которой требуется определить.</br>
**start** - Индекс начала среза в исходной строке, в котором требуется отыскать подстроку.</br>
**end** - Индекс конца среза в исходной строке, в котором требуется отыскать подстроку.

Если подстрока не найдена, возвращает -1.

Необязательные параметры start и end могут принимать любые значения, поддерживаемые механизмом срезов, а значит и отрицательные.

```py
my_str = 'barbarian'
my_str.find('bar')  # 0
my_str.find('bar', 1)  # 3
my_str.find('bar', 1, 2)  # -1
```

Метод должен использоваться только в случае необходимости найти *индекс начала подстроки*. Для обычного определения вхождения подстроки используйте оператор in.

Имеет смысл для *быстрого* выделения подстроки, для последующей обработки медленным алгоритмом.

## str.format(*args, **kwargs) -> str
Возвращает копию строки, отформатированную указанным образом.

**args** - Позиционные аргументы.</br>
**kwargs** - Именованные аргументы.

Строка, для которой вызывается данный метод может содержать как обычный текст, так и маркеры в фигурных скобках {}, которые следует заменить. Обычный текст, вне скобок будет выведен как есть без именений.

Метод возвращает копию строки, в которой маркеры заменены текстовыми значениями из соответствуюих аргументов.

Общий вид маркера:</br>
``{'[наименование('.'аттр|'['индекс']')*] ['!'приведение] [':'формат] '}``

>Если требуется, чтобы результирующая строка содержала скобку, то этот спецсимвол можно экранировать при помощи его удвоения: {{ и }}.

* **Наименование** состоит из имени аргумента (либо его индекса). Числовой индекс при этом указывает на позиционный аргумент; имя же указывает на именованный аргумент.

Если используется числовой индекс и числа составляют последовательноть (0, 1, 2...), то индексы могут быть опущены разом (но не выборочно). Например, {}-{}-{} и {0}-{1}-{2} эквивалентны.

```py
"{} {} {}".format('пример','простого','заполнения') 
>пример простого заполнения


"{2} {3} {0} {1}".format('по','индексу','пример','заполнения')
>пример заполнения по индексу

"{one} {two} {three} {four}".format(one='заполнение',
                                    two='по',
                                    three='именованным',
                                    four='аргументам')
>заполнение по именованным аргументам

"{one}-{two}-{three}".format(**{'two': 2, 'one': 1, 'three': 3})
>1-2-3
```

* После наименования может следовать любое количество выражений доступа к **атрибуту** или адресации по индексу. 

Атрибут объекта адресуется при помощи . (точки). Задействуется getattr().</br>
Доступ к элементу контейнера при помощи [] (квадратных скобок). Задействуется __getitem__().

```py
# пример класса экземпляр которого по атрибуту attr получит данные
class Temp(object): 
    attr = 3
    
# пример словаря с разными типами параметров: словарь, список и объект  
obj = {'one': {'sub': 1}, 'two': [10, 2, 30], 'three': Temp()}

'{one[sub]}-{two[2]}-{three.attr}'.format(**obj)  
>1-30-3
```

* **Приведение** используется для приведения типов перед форматированием.</br> 
Обычно возврат отформатированого значения возлагается на метод __format__(), однако бывают случаи, что требуется произвести принудительное приведение, например,к строке, в обход имеющейся реализации. Логика форматирования по умолчанию обходится при помощи приведения значения к строке перед вызовом __format__().

Флаги приведения | Вызывает
:---:|--- 
!s | str()
!r | repr()
!a | ascii() (для Python 3)

```py
class Demo:  # Python 3
    
    def __str__(self):
        return 'str'
    
    def __repr__(self):
        return 'repr'
    
    def __ascii__(self):
        return 'ascii'
    
    def __format__(self, format_spec):
        return 'format'
    
demo = Demo()
"{!s}-{!r}-{!a}-{}".format(demo, demo ,demo, demo)
>str-repr-ascii-format
```

* **Формат** содержит определение того как должно быть представлено значение, включая информацию о длине, выравнивании, дополнении строки, точности для чисел итому подобное. Каждый тип может иметь свой мини-язык форматирования.

Большинство встроенных типов использует общий мини-язык.

Для поддержки динамического составления формата, его определение может содержать вложенные маркеры для замены. При этом допускается только один уровень вложенности. Вложенные маркеры заменяются значениями до того как будет интерпретирована строка формата. 
```py
"-{:{fill}{align}8}-".format('some', fill='+', align='^')
>-++some++-
```

**:** - признак того, что дальше содержится формат</br>
**align** = ^ - центрирование</br>
**8** - минимальный размер</br>

Итак, последовательность действий: строку *some* отцентрировали по ширине 8 с запонением символами '+', символы '-' добавились уже снаружи **формата**

>Дополнительная информация о формате доступна в разделе [Мини-язык форматирования](http://pythonz.net/references/named/mini-yazyk-formatirovaniya/).

## str.index(sub[, start[, end]]) -> int
Возвращает наименьший индекс, по которому обнаруживается начало указанной подстроки в исходной.

Работа данного метода аналогична работе str.find(), однако, если подстрока не найдена, возбуждается исключение ValueError.

## str.isalnum() -> bool
Возвращает логическое значение, указывающее на то, содержит ли строка только цифры и/или буквы.

>есть еще несколько методов, проверяющих принадлежит ли строка какому-нибудь признаку, все они начинаются с **is**. Подробно рассмаривать не будем, сложного в них ничего нет.

## str.join(iterable) -> str
Возвращает строку, собранную из элементов указанного объекта, поддерживающего итерирование.

В качестве соединительного элемента между указанными используется объект строки, предоставляющий данный метод. 

```py
dots = '..'
my_str = dots.join(['1', '2'])  # '1..2'
my_str = dots.join('ab')  # 'a..b'
```

Ожидается, что итерируемый объект выдаёт строки. Для массового приведения к строке можно воспользоваться функцией map():</br>
``dots.join( map(str, [100, 200]) ) # '100..200'``

## str.lower() -> str, str.upper() -> str
Возвращает копию исходной строки с символами приведёнными к нижнему (lower) или верхнему (upper) регистру.

## str.split(sep=None[, maxsplit=-1]) -> list
Разбивает строку на части, используя разделитель, и возвращает эти части списком. Направление разбиения: слева направо.

**sep** = Строка-разделитель, при помощи которой требуется разбить исходную строку. Может содержать как один, так и несколько символов. Если не указан, то используется специальный алгоритм разбиения, для которого разделителем считается последовательность пробельных символов.</br>
**maxsplit** - Максимальное количество разбиений, которое требуется выполнить. Если -1, то количество разбиений не ограничено.

```py
'1,2,,3,'.split(',')   
>['1', '2', '', '3', ''] 
```

## Форматирование при помощи %
Форматирование строк в стиле printf при помощи оператора интерполяции %. Оператор заменяет маркеры в строке значениями из форматируемого объекта.

Если формат требует лишь одного аргумента, то форматируемый объект может не заключаться в кортеж. В прочих случаях форматируемый объект должен являться кортежем с количеством элементов достаточным для форматирования, либо отображением,например, словарём.

```py
'%s %d' % ('number', 5)  # 'number 5'
'number %d' % 5  # 'number 5'
'%d%%' % 100  # '100%'
```

Общий вид маркера:</br> 
``%[(имя)][флаги][минразмер][.точность]тип``

Подробнее можно ознакомиться [здесь](http://pythonz.net/references/named/str-modulo/)


<a name="recursia"></a>

## Рекурсия. Программирование рекурсивных алгоритмов.
Рекурсивные функции делят на собственно *рекурсивные* и *косвенно рекурсивные*. Функция называется *косвенно рекурсивной* в том случае, если она содержит обращение к другой функции, содержащий вызов данной функции.

Например, функции A и B являются косвенно рекурсивными.
```py
def A():
  ...
  B()
  ...

def B():
  ...
  A()
  ...
```

Если же в теле функции имеется вызов самой этой функции, то речь идет о прямой рекурсии, а такую функцию называет рекурсивной.

Например, функция А является рекурсивной:
```py
def A():
  A()
```

Рекурсивные алгоритмы эффективны в тех задачах, где рекурсия используется в определении данных. Если у задачи есть очевидное итерационное решение, то рекурсии следует избегать. 

При разработке рекурсивной функции важно помнить, что в ней должен быть хотя бы один не рекурсивный выход, иначе получим бесконечный цикл с переполнением стека.

Классический пример рекурсивной функции – вычисление факториала:

```py
def factorial(k: int) -> int: 
  if k<0: return 0;  # нерекурсивный выход
  if k==0: return 1; # нерекурсивный выход
  return k*factorial(k-1)
```

**Сложность рекурсивных вычислений**. При относительной простоте написания, у рекурсивных подпрограмм часто встречается существенный недостаток – неэффективность. Так, сравнивая скорость вычисления чисел Фибоначчи с помощью итеративной и рекурсивной функции можно заметить, что итеративная функция выполняется почти «мгновенно», не зависимо от значения n. При использовании же рекурсивной функции уже при n=40 заметна задержка при вычислении, а при больших n результат появляется весьма не скоро.

Еще одним классическим применением рекурсии является поиск элемента в упорядоченном массиве (двоичный поиск).

Имеется упорядоченный массив и эталонный элемент. Требуется определить, содержится ли эталон в массиве. Если «да», то вернуть соответствующий номер позиции. Если «нет» - вывести сообщение.

Для решения задачи используется метод деления исходного массива пополам.

С эталоном сравнивается «средний» (расположенный по середине) элемент массива. Если он меньше эталона – поиск продолжается в правой половине массива. Если меньше – в левой.

Поиск ведется до тех пор, пока не будет обнаружено соответствие, или пока длина участков массива, в которых ведется поиск, не станет меньше 1.

**Деревья**. Изучение рекурсии неразрывно связано с изучением рекурсивно определяемых структур данных, называемых деревьями (trees). Деревья используются как для упрощения понимания и анализа рекурсивных программ, так и в качестве явных структур данных. В свою очередь, рекурсивные программы используются для построения деревьев. Глобальная связь между ними (и рекуррентными отношениями) используется при анализе алгоритмов.

<a name="file_types"></a>

## Типы файлов. 
В контексте изучения программирования файлы делятся на три типа:
* Текстовые файлы. У них нет постоянной длины записи. Текстовые данные записываются/читаются порциями - строками, где разделителем служит перевод строки (в MSDOS и Windows - это пара символов #13#10)
* Типизированные файлы - когда в файле хранятся одинаковые структуры данных, заранее определенные (либо программистом, либо форматом файла). В принципе любой файл можно рассматривать как типизированный со структурой данных равной одному байту.
* Нетипизированные файлы. Информация в них хранится разными блоками, обычно в начале фалйа есть заголовок, где описаны свойства и размеры блоков.

Скорость работы с текстовыми файлами ниже, потому что ядро (а мы понимаем, что для компьютера все файлы просто набор байтов) языка программирования вынуждено считывать промежуточный буфер, в котором искать конец строки, а если он не найден в этом буфере, то подгружать еще один (или несколько) и склеивать из них результирующую строку. Все эти накладные расходы и влияют на скорость.

В старой литературе пишут, что доступ к нетипизированным файлам быстрее, чем к остальным (видимо из-за того что в типизированных файлах структура может быть небольшой и постоянно приходится перечитывать одно и то же место, чтобы достать очередной блок), но на практике все операции с диском кэшируются и вряд ли вы заметите эту разницу.

## Организация доступа к файлам.
Для использования информации, хранимой в файлах, она должна быть считана в память компьютера. Есть несколько способов доступа к файлам.

Ранние ОС давали только один способ доступа – **последовательный** (перфолента, магнитная лента). Записи считывались в порядке поступления. Текущая позиция считывания могла быть возвращена к началу файла (rewind), но операция эта очень медленная. 

Вместе с магнитными барабанами и дисками появились файлы с **прямым** (random) доступом. Для специфицирования места, с которого надо начинать чтение используются два способа: с начала, или с текущей позиции, которую дает операция seek.

Помимо **прямого** и **последовательного** существуют и другие методы доступа. Обычно они включают конструирование **индекса** файла и базируются на прямом методе доступа. Для поиска записи вначале происходит обращение к индексу, где находится указатель на нужную запись.

## Файлы последовательного доступа
В питоне многие объекты являются файлами: стандартный ввод sys.stdin, стандартный вывод sys.stdout, каналы (pipes).

```py
import sys
text = sys.stdin.read() # аналог input()
sys.stdout.write(text)  # аналог print()
```

>Не нашел примеров функций работы с файлами последовательного доступа.

## Файловый объект в Python
В Python работа с файлами осуществляется через специальный абстрактный файловый объект. В зависимости от способа создания такого объекта, он может быть привязан как к физическому файлу на диске, так и другому устройству, поддерживающему схожие операции (стандартный ввод/вывод и пр.).

Стандартный способ создания файлового объекта - функция open():

``open(file, mode='r', buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None)``

Открывает файл и возвращает файловый объект. Если файл не может быть открыт, возбуждается исключение OSError и его потомки (FileNotFoundError и др.).

Некоторые из параметров:

* file – путь к файлу (например, строка) или файловый дескриптор;
* mode – режим открытия файла:

Символ | Описание
:-----:|---------
'r'	| Открыть для чтения (по умолчанию)
'w'	| Открыть для записи (если файл существует, то очищается)
'x'	| Открыть для создания с эксклюзивными правами (ошибка, если файл существует)
'a'	| Открыть для добавления (если файл существует)
'+'	| Открыть для чтения и записи
't'	| Текстовый режим (по умолчанию)
'b'	| Двоичный режим

Двоичный/текстовый режимы могут быть скомбинированы с другими: например, режим 'rb' позволит открыть на чтение бинарный файл;

* encoding – наименование кодировки, используемой при чтении/записи файла (например, 'utf-8'); параметр имеет смысл только для текстового режима.

>**Кодировка файла**
>
>При открытии файла Python по умолчанию использует кодировку, предпочитаемую операционной системой. Для определения кодировки по умолчанию выполните код:
>
>```py 
>import locale
>locale.getpreferredencoding(False)  # 'cp1251' на российской сборке ОС Windows``
>```
>Старайтесь указывать кодировку файла явно, например, encoding="utf-8", особенно если есть вероятность работы программы на различных ОС.

Открытие файлов связано с потреблением/резервированием ресурсов, поэтому после выполнения необходимых операций его следует закрыть.

``close()``

Закрывает файл. После этого работа с файлом невозможна (чтение, запись и др.).

Общий цикл работы с файлом может выглядеть следующим образом:

```py
# При работе с файлами всегда целесообразно использовать исключения

# 1. Стандартный способ открытия файла с обработкой исключений
fh = None
try:
    fh = open("data.txt", encoding="utf-8")
    #
    # Чтение и запись файла
    #
except Exception as e:
    print("Ошибка при работе с файлом:", e)
finally:
    if fh:  # Если файл не открылся, значит 'fh' == None и закрывать его не нужно
        fh.close()

# 2. Для упрощения кода по выделению и высвобождению ресурсов в Python
#    предусмотрены специальные объекты - менеджеры контекста,
#    которые могут самостоятельно следить за использованием ресурсов
#
#    Наиболее часто менеджеры контекста вызываются с использованием ключевого слова with

try:
    with open("data2.txt", encoding="utf-8") as fh:
        #
        # Чтение и запись файла
        #
except Exception as e:
    print("Ошибка при работе с файлом:", e)
```

>В большинстве примеров данной темы подробная обработка исключений опущена для того, чтобы сосредоточиться на демонстрации конкретных возможностей.
>
>При самостоятельном написании программ не следует забывать добавлять обработку исключений - программа должна адекватно реагировать на возможные нестандартные ситуации (используемые файлы может изменить пользователь или другая программа).

## Основные свойства и методы работа с файлами
Файловый объект предоставляет ряд свойств и методов для работы с файлами. Большинство методов универсально и предполагают работу (чтение/запись) со строками в указанной кодировке (str для текстовых файлов) или с набором байт (bytes для двоичных файлов).

* **name** - Имя файла (если имеется)
* **encoding** - Кодировка, используемая для *строковых* преобразований в файле.
* **closed** - Возвращает True, если файл закрыт.
* **close()** - Закрывает файл. После этого работа с файлом невозможна (чтение, запись и др.).
* **read(count)** - Читает до *count* байт из файлового объекта. Если значение *count* не определено, то читаются все байты, начиная от текущей позиции и до конца.</br>
Если ничего не было прочитано (конец файла), возвращается пустой объект str или bytes.
* **readline(count)** - Читает следующую строку (до count байт, если значение count определено и число прочитанных байтов было достигнуто раньше, чем встретился символ перевода строки '\n'), включая символ перевода строки '\n'.
* **readlines()** - Читает все строки до конца файла и возвращает их в виде списка.</br>
* **write(s)** - Записывает в файл объект s типа:</br>
str для текстового режима;</br>
bytes / bytearray для двоичного режима.
* **writelines(seg)** - Записывает в файл последовательность объектов типа:</br>
str для текстового режима;</br>
bytes / bytearray для двоичного режима.</br>
* **flush()** - При работе с файлами Python по умолчанию использует буфер определенного размера. Вызов методов записи приводит к записи в буфер, после чего в определенный момент производится очистка буфера и передача сигнала для записи данных на диск.</br>
Метод flush() вызывает принудительное очистку буфера. В большинстве случаев вызывать его напрямую не нужно.

Пример работы с двоичным файлом (пример на самом деле плохой, данные хранятся не структирированными и в текстовом виде)

```py
human = dict(name="Михаил Толстых", age=35, weight=90.5)
filename = "08_01_02_data.txt"

# 1. Запись в файл
#    При записи бинарных файлов все данные должны быть преобразованы в тип bytes
#    Удобно выполнить преобразование через метод str.encode()
fh = None
try:
    fh = open(filename, "wb")
    fh.write(bytes(human["name"].encode("utf-8")))
    fh.write(bytes(str(human["age"]).encode("utf-8")))
    fh.write(bytes(str(human["weight"]).encode("utf-8")))
finally:
    if fh:
        fh.close()

# 2. Чтение из файла
#    При чтении бинарных файлов необходимо точно знать, сколько байт
#    прочитать и как их декодировать, используя bytes.decode()
#    При редактировании файла в стороннем редакторе файл может быть не читаем
fh = None
try:
    fh = open(filename, "rb")
    name = fh.read(27).decode("utf-8")
    age = int(fh.read(2).decode("utf-8"))
    weight = float(fh.read(4).decode("utf-8"))
    print(name, age, weight)  # Михаил Толстых 35 90.5
finally:
    if fh:
        fh.close()
```

Пример работы с текстовым файлом

```py
human = dict(name="Михаил Толстых", age=35, weight=90.5)
filename = "08_01_03_data.txt"

# 1. Запись в файл
#    При записи текстовых файлов все данные должны быть преобразованы в тип str
#    По умолчанию, write() не добавляет перенос строки, однако его можно добавить самостоятельно
fh = None
try:
    fh = open(filename, "w", encoding="utf-8")
    # При добавлении переноса записываемые данные будут на отдельной строке
    fh.write(human["name"] + "\n")
    fh.write(str(human["age"]) + "\n")
    # Как альтернатива - print() позволяет не переводить в строку и не добавлять перенос вручную
    print(human["weight"], file=fh)
finally:
    if fh:
        fh.close()

# 2. Чтение из файла
#    Для чтения отдельной строки достаточно вызвать метод readline().
#    В конце полученной строки знак переноса - \n,
#    который можно убрать, например, методом str.strip()
fh = None
try:
    fh = open(filename, encoding="utf-8")
    # Читаем первые 3 строки и преобразуем при необходимости
    name = fh.readline().strip()
    age = int(fh.readline())
    weight = float(fh.readline())
    print(name, age, weight)  # Михаил Толстых 35 90.5
finally:
    if fh:
        fh.close()
```

## Чтение файла целиком
Чтение файла, приведенное выше не подразумевает, что содержимое файла может меняться.

Учитывать такие изменения можно, прочитав файл целиком:
* в одну строку;
* в список строк;
* построчно, пока не достигнут конец файла.

Различные способы чтения текстового файла целиком

```py
filename = "08_01_04_data.txt"

# 1. Чтение из файла (в одну строку)
with open(filename, encoding="utf-8") as fh:
    data = fh.read()
    print(data)

# 2. Чтение из файла (в список)
with open(filename, encoding="utf-8") as fh:
    data = fh.readlines()
    print(data)

# 3. Чтение из файла (построчно)
with open(filename, encoding="utf-8") as fh:
    for line in fh:
        print(line.strip())
```

## Сериализация и десериализация
Чтение/запись простых типов (например, чисел или строк) не представляет большого труда, однако с увеличением объема информации появляется необходимость эффективно сохранять/загружать более сложные структуры данных (например, словари). Кроме того,модульная архитектура современного программного обеспечения приводит к необходимости обмена данными между различными модулями, а также между приложениями в целом, для чего необходимо иметь возможность удобно обмениваться данными.

Сериализация — процесс перевода какой-либо структуры данных в последовательность битов. Десериализация — обратный процесс.

Чаще всего сериализация используется для сохранения объектов в файлы или передачи их по сети.

## Модуль pickle
Одним из способов, позволяющих сериализовать/десериализовать данные в Python, является использование стандартного модуля pickle, при помощи которого можно сохранять любой объект Python в двоичном файле, а затем извлекать его обратно.

Основные функции модуля:

``pickle.dump(obj, file, protocol=None, *, fix_imports=True)``</br>
Сериализует объект *obj* и записывает его в файл *file*.

Параметры:	
* obj – объект для записи;
* file – файловый объект;
* protocol – версия формата pickle.


``pickle.load(file, *, fix_imports=True, encoding="ASCII", errors="strict")``</br>
Читает и десериализует содержимое файла file, возвращая созданный объект (структуру).

Параметры:	
* file – файловый объект.

Вместо функций можно использовать классы Pickler и Unpickler, реализование в этом модуле.

Использование pickle для загрузки/сохранения объектов Python

```py
import pickle

filename = "data.txt"

# список покупок
shoplist = {"фрукты": ["яблоки", "манго"],
            "овощи": ["морковь"],
            "бюджет": 1000}

# Запись в файл
with open(filename, "wb") as fh:
    pickle.dump(shoplist, fh)  # помещаем объект в файл

# Считываем из хранилища
shoplist_2 = []
with open(filename, "rb") as fh:
    shoplist_2 = pickle.load(fh)  # загружаем объект из файла
print(shoplist_2)  # {'бюджет': 1000, 'овощи': ['морковь'], 'фрукты': ['яблоки', 'манго']}
```

Минусы формата pickle:
* специфичен для Python (не может быть использован, если файл будет читаться с использованием других языков программирования);
* небезопасен (десериализация готовых конструкций языка может привести к выполнению ненадежного кода).

## Популярные форматы файлов
Большое количество данных в совокупности с их разнородностью привело к появлению специальных форматов файлов, позволяющих хранить различные объемы связанной информации и не привязанных к конкретному языку программирования.

Среди них одними из наиболее популярных являются:

* CSV (англ. Comma-Separated Values - значения, разделенные запятыми);
* JSON (англ. JavaScript Object Notation) - текстовый формат обмена данными, основанный на JavaScript;
* XML (англ. eXtensible Markup Language - расширяемый язык разметки);
* YAML (англ. YAML Ain’t Markup Language - «YAML - Не язык разметки»);
* INI (англ. Initialization file - файл инициализации);

Подавляющее большинство форматов поддерживается Python (стандартными или сторонними модулями и пакетами).

## CSV
CSV (англ. Comma-Separated Values - значения, разделенные запятыми, 2005 г.) - текстовый формат, предназначенный для представления табличных данных. Каждая строка файла - это одна строка таблицы, где значения отдельных колонок разделяются разделительным символом (англ. delimiter) запятой ",". Значения содержащие запятую заключаются в кавычки: "запятая служебный символ, но в кавычках не считается" 

Несмотря на наличие стандарта (RFC 4180), на сегодняшний день под CSV, как правило,понимают набор значений, разделенных произвольными разделителями, в произвольной кодировке с произвольными окончаниями строк. Это значительно затрудняет перенос данных из одних программ в другие, несмотря на всю простоту реализации поддержки CSV (так, например, Microsoft Excel не всегда открывает стандартные разделенные запятыми данные).

В Python работа с CSV-файлами поддерживается стандартным модулем csv, предоставляющем следующие основные объекты и функции:

``csv.reader(csvfile, dialect='excel', **fmtparams)``</br>
Создает и возвращает объект для чтения последовательности из CSV-файла.

Параметры:	
* csvfile – итерируемый объект, возвращающий строку на каждой итерации (например, файловый объект в текстовом режиме доступа);
* dialect – диалект CSV (набор специальных параметров);
* fmtparams – дополнительные настройки (совокупность кавычек, разделителей и т.д.).

```py
import csv
 
csv_path = "data.csv"
with open(csv_path, "r") as f_obj:
    reader = csv.reader(f_obj)
    for row in reader:
        print(" ".join(row))
```

``csv.writer(csvfile, dialect='excel', **fmtparams)``</br>
Создает и возвращает объект для записи последовательности в CSV-файл.

Параметры:	
* csvfile – любой объект, поддерживающий метод записи write();
* dialect – аналогично csv.reader();
* fmtparams – аналогично csv.reader().

```py
import csv

data = ["first_name,last_name,city".split(","),
        "Tyrese,Hirthe,Strackeport".split(","),
        "Jules,Dicki,Lake Nickolasville".split(","),
        "Dedric,Medhurst,Stiedemannberg".split(",")
        ]

path = "output.csv"
with open(path, "w", newline='') as csv_file:
    writer = csv.writer(csv_file, delimiter=',')
    for line in data:
        writer.writerow(line)
```

``class csv.DictWriter(csvfile, fieldnames, restval='', extrasaction='raise', dialect='excel', *args, **kwds)``</br>
Создает и возвращает объект для записи данных как словаря значений в CSV-файл.

Параметры:	
* csvfile – любой объект, поддерживающий метод записи write();
* fieldnames – список наименований столбцов (если не задан, используется первая строка файла).

```py
import csv
 
data = ["first_name,last_name,city".split(","),
        "Tyrese,Hirthe,Strackeport".split(","),
        "Jules,Dicki,Lake Nickolasville".split(","),
        "Dedric,Medhurst,Stiedemannberg".split(",")
         ]
    
my_list = []
fieldnames = data[0]
for values in data[1:]:
    inner_dict = dict(zip(fieldnames, values))
    my_list.append(inner_dict)
    
path = "dict_output.csv"
with open(path, "w", newline='') as out_file:
    writer = csv.DictWriter(out_file, delimiter=',', fieldnames=fieldnames)
    writer.writeheader()
    for row in my_list:
        writer.writerow(row)
```

Мы начали со структуры вложенного списка. Теперь мы создаем пустой список (my_list)и список, который содержит имена полей, который будет первым списком во вложенном списке. Помните, списки начинаются с нуля, так что первый элемент в нем начинается с нуля. Далее мы используем цикл во вложенном списке, начиная со второго элемента.

Внутри цикла for мы используем встроенные инструменты Python, чтобы создать словарь. Метод zip будет использовать два итератора (списка, в нашем случае), и превратит их в список кортежей. Давайте взглянем на пример:

```py
zip(fieldnames, values)
[('first_name', 'Dedric'), ('last_name', 'Medhurst'), ('city', 'Stiedemannberg')]
```

Теперь, когда вы оборачиваете этот вызов в dict, этот список кортежей превращается в словарь. И наконец, мы добавляем словарь в список. Когда for завершит работу, вы получите структуру данных, которая будет выглядеть так:

```Python
[
  {'city': 'Strackeport', 'first_name': 'Tyrese', 'last_name': 'Hirthe'},
  {'city': 'Lake Nickolasville', 'first_name': 'Jules', 'last_name': 'Dicki'},
  {'city': 'Stiedemannberg', 'first_name': 'Dedric', 'last_name': 'Medhurst'}
]
```

Затем мы открываем файл, создаем экземпляр DictWriter и передаем ему объект файла, значение разделителя и наш список наименований полей. Далее, мы записываем наименования полей на наш диск, а затем в цикле записываем данные по одной строке. 

Класс DictWriter также поддерживает метод writerows, который мы можем использовать вместо цикла. Функция csv.writer также может делать это.

``class csv.DictReader(csvfile, fieldnames=None, restkey=None, restval=None, dialect='excel', *args, **kwds)``</br>
Создает и возвращает объект для чтения данных из CSV-файла как словаря значений.

Параметры:	
* csvfile – итерируемый объект, возвращающий строку на каждой итерации (например, файловый объект в текстовом режиме доступа);
* fieldnames – список наименований столбцов (если не задан, используется первая строка файла).

Файл data.csv у нас появился после выполнения предыдущего кода (DictWriter)

А теперь с помощью DictReader выведем интересующие нас данные

```py
import csv
 
with open("data.csv") as f_obj:
    reader = csv.DictReader(f_obj, delimiter=',')
    for line in reader:
        print(line["first_name"], line["last_name"])
```

## JSON
JSON (англ. JavaScript Object Notation, 1999 г.) - текстовый формат обмена данными,основанный на JavaScript. Одно из преимуществ - JSON легко читается людьми (англ. human-readable)

Пример JSON-файла
```json
{
	"ФИО": "Иванов Сергей Михайлович",
	"ЕГЭ": {
		"Математика": 90,
		"Физика": 70,
		"Информатика": 80
	},
	"Хобби": ["Рисование", "Плавание"],
	"Возраст": 25.5,
	"ДомЖивотные": null
}
```

JSON-текст представляет собой одну из двух структур:
* набор пар "ключ: значение" (словарь в терминологии Python), где ключ - строка, значение - любой тип;
* упорядоченный набор значений (список в терминологии Python).

Значением может являться:
* строка (в кавычках);
* число;
* логическое значение (true/false);
* null;
* одна из структур.

Одним из преимуществ JSON является близкое соответствие Python по типам данных. Работа с JSON-форматом поддерживается стандартным пакетом json, предоставляющем следующие основные функции:

``json.dumps(obj, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, cls=None, indent=None, separators=None, default=None, sort_keys=False, **kw)``</br>

Сериализует объект obj, возвращая строку в JSON-формате.

Параметры:	
* obj – сериализуемый объект;
* ensure_ascii – если равен False, запись не-ASCII значений происходит в файл «как есть», без преобразования в Unicode;
* indent – величина отступа для вложенных структур.

``json.loads(s, encoding=None, cls=None, object_hook=None, parse_float=None, parse_int=None, parse_constant=None, object_pairs_hook=None, **kw)``

Десериализует объект (в том числе файловый) s, возвращая структуру в Python.

При ошибке десериализации возбуждается исключение JSONDecodeError.

``exception json.JSONDecodeError(msg, doc, pos, end=None)``
Класс исключения, возбуждаемый при ошибке в работе некоторых функций пакета.

Работа с JSON-форматом в Python
```py
import json

filename = "data.json"

info = {
    "ФИО": "Иванов Сергей Михайлович",
    "ЕГЭ": {
        "Математика": 90,
        "Физика": 70,
        "Информатика": 80
    },
    "Хобби": ["Рисование", "Плавание"],
    "Возраст": 25.5,
    "ДомЖивотные": None
}

# Запись структуры в файл в JSON-формате
with open(filename, "w", encoding="utf-8") as fh:
    fh.write( json.dumps(info, ensure_ascii=False, indent=4) )
```

Пример содержимого файла:
```json
{
    "Хобби": [
        "Рисование",
        "Плавание"
    ],
    "ЕГЭ": {
        "Информатика": 80,
        "Математика": 90,
        "Физика": 70
    },
    "ФИО": "Иванов Сергей Михайлович",
    "ДомЖивотные": null,
    "Возраст": 25.5
}
```

Чтение из файла JSON-формата

```py
info_2 = []
with open(filename, encoding="utf-8") as fh:
    info_2 = json.loads(fh.read())

print(info_2)
# {'ФИО': 'Иванов Сергей Михайлович', 'ЕГЭ': {'Информатика': 80, 'Математика': 90, 'Физика': 70},
#  'Хобби': ['Рисование', 'Плавание'], 'Возраст': 25.5, 'ДомЖивотные': None}
```

>Примечание
>
>Валидация и оформление JSON-файлов
>
>При возникновении ошибки чтения файла JSON-формата рекомендуется проверить его синтаксис с использованием специальных онлайн-сервисов, например, https://jsonformatter.curiousconcept.com/, которые могут как указать место ошибки, так и оформить его по стандарту.

## INI
Очень часто программам нужно где-то хранить настройки, желательно в текстовом виде,чтобы пользователь мог их менять. CSV для этой цели не подходит, он "заточен" под базы данных. JSON всем хорош (и я его даже использую), но у него нет "защиты от дурака". Не поставленная запятая или кавычка приведут к тому, что программа не сможет преобразовать его в объект (в словарь в нашем случае).

Для хранения настроек в текстовом виде используют .ini файлы, они легко читаются и правятся человеком, хотя в них трудно сохранить сложную структуру данных.

Формат этот очень старый, в Windows он сейчас практически вытеснен реестром, но в Линуксах до сих пор повсеменно используется.

Библиотека в ядре Python включает в себя модуль, под названием configparser, который вы можете использовать для создания и работы с файлами конфигурации.

### Создание ini-файла
Создание ini-файла при помощи configparser невероятно просто. 

```py
import configparser
 
def createConfig(path):
    """
    Create a config file
    """
    config = configparser.ConfigParser()
    config.add_section("Settings")
    config.set("Settings", "font", "Courier")
    config.set("Settings", "font_size", "10")
    config.set("Settings", "font_style", "Normal")
    config.set("Settings", "font_info",
               "You are using %(font)s at %(font_size)s pt")
    
    with open(path, "w") as config_file:
        config.write(config_file)
 
 
if __name__ == "__main__":
    path = "settings.ini"
    createConfig(path)
```

Данный код создает файл settings.ini с одной секцией, под названием Settings, которая будет содержать наши опции: font, font_size, font_style и font_info.

```ini
[Settings]
font=Courier
font_size=10
font_style=Normal
font_info=You are using Courier at 10 pt
```

### Как читать, обновлять и удалять опции
Теперь мы готовы к тому, что бы научиться чтению ini-файла, обновлять его опции и даже удалять их. В нашем случае учиться будет намного проще, если мы попробуем на практике написать какой-нибудь код. Просто добавьте следующую функцию в код, который вы писали ранее.

```py
import configparser
import os
 
def crudConfig(path):
    """
    Create, read, update, delete config
    """
    if not os.path.exists(path):
        createConfig(path)
    
    config = configparser.ConfigParser()
    config.read(path)
    
    # Читаем некоторые значения из конфиг. файла.
    font = config.get("Settings", "font")
    font_size = config.get("Settings", "font_size")
    
    # Меняем значения из конфиг. файла.
    config.set("Settings", "font_size", "12")
    
    # Удаляем значение из конфиг. файла.
    config.remove_option("Settings", "font_style")
 
    # Вносим изменения в конфиг. файл.
    with open(path, "w") as config_file:
        config.write(config_file)
 
 
if __name__ == "__main__":
    path = "settings.ini"
    crudConfig(path)
```

Этот код сначала проверяет, существует ли ini-файл в принципе. Если его нет, то он использует созданную нами ранее функцию createConfig, чтобы создать файл. Далее мы создаем объект ConfigParser и указываем путь к файлу для чтения. Чтобы прочесть опцию в вашем config файле, мы вызываем метод нашего объекта ConfigParser, указываем ему наименование секции и опции.

Это вернет значение параметра. Если вы хотите изменить значение опции, вам нужно использовать метод set, в котором вы указываете название секции, опции, и новое значение. Наконец, мы можем использовать метод remove_option, чтобы удалить опцию. В нашем примере мы изменили значение font_size, и задали ему размер 12, затем мы удалили опцию font_style. После этого мы записали наши изменения на диск. 

Если же вспомнить одну из предыдущих лекций, где мы говорили о правилах написания "правильных" функций, то код лучше разделить на более простые функции, каждая из которых делает что-то одно:

```py
import configparser
import os
 
 
def create_config(path):
    """
    Create a config file
    """
    config = configparser.ConfigParser()
    config.add_section("Settings")
    config.set("Settings", "font", "Courier")
    config.set("Settings", "font_size", "10")
    config.set("Settings", "font_style", "Normal")
    config.set("Settings", "font_info",
                "You are using %(font)s at %(font_size)s pt")
    
    with open(path, "w") as config_file:
        config.write(config_file)
 
 
def get_config(path):
    """
    Returns the config object
    """
    if not os.path.exists(path):
        create_config(path)
    
    config = configparser.ConfigParser()
    config.read(path)
    return config
 
 
def get_setting(path, section, setting):
    """
    Print out a setting
    """
    config = get_config(path)
    value = config.get(section, setting)
    return value
 
 
def update_setting(path, section, setting, value):
    """
    Update a setting
    """
    config = get_config(path)
    config.set(section, setting, value)
    with open(path, "w") as config_file:
        config.write(config_file)
 
 
def delete_setting(path, section, setting):
    """
    Delete a setting
    """
    config = get_config(path)
    config.remove_option(section, setting)
    with open(path, "w") as config_file:
        config.write(config_file)
 
 
if __name__ == "__main__":
    path = "settings.ini"
    font = get_setting(path, 'Settings', 'font')
    print("Settings font_size is %s" % font_size)

    font_size = get_setting(path, 'Settings', 'font_size')
    print("Settings font_size is %s" % font_size)

    update_setting(path, "Settings", "font_size", "12")
    delete_setting(path, "Settings", "font_style")
```

Этот пример выглядит более организованно, по сравнению с первым. Каждая функция должна объяснять сама себя и выполнять лишь одну задачу. Вместо того, чтобы помещать всю логику в одну единственную функцию, мы разделяем её на несколько функций, после чего демонстрируем их функционал в конце оператора if. Теперь вы можете импортировать модуль и использовать по назначению. 

Может показаться, что файл слишком часто открывается/закрываеся. Но, как я уже упоминал, в современных ОС дисковые операции кэшируются и файл с большой вероятностью витоге будет открыт и закрыт всего один раз.

### Интерполяция
Модуль configparser также подразумевает возможность интерполяции, что значит, что вы можете использовать существующие опции, для создания другой опции. Мы на самом деле это делали с опцией font_info, чьи параметры основаны на опциях font и font_size. Мы можем изменить интерполированное значение при помощи словаря Python. Давайте уделим несколько минут, и взглянем на оба случая.

```py
import configparser
import os
 
 
def interpolationDemo(path):
    if not os.path.exists(path):
        createConfig(path)
    
    config = configparser.ConfigParser()
    config.read(path)
    return config    
 
 
if __name__ == "__main__":
    path = "settings.ini"
    config = interpolationDemo(path)

    print(config.get("Settings", "font_info"))
    print(config.get(
        "Settings", "font_info", vars={"font": "Arial", "font_size": "100"})
    )
```

Обратите внимание, при печати втрой строки мы одновременно считываем два параметра.

>На самом деле, судя по докстроке метода *get*, там более сложное поведение, на практике постараемся разобраться с этим подробнее.

Хотя возможностей configparser вполне достаточно для типовых задач, существует еще один модуль, под названием ConfigObj, который не является частью Python. ConfigObj более гибкий, и обладает большим количеством функций, чем configparser. 

## Работа с файловой системой
Прежде чем попытаться прочитать какой-то файл, нужно узнать есть ли он на диска. А перед записью убедиться, что пишем в нужный нам каталог.

Стандартный модуль os имеет интерфейс работы с файловой системой. 

**Текущий каталог** - каталог, в котором программа будет открывать файлы, если в названии файла не указан абсолютный путь к нему. Обычно каталог, в котором прграмму запустили.

Функция os.getcwd возвращает текущий каталог:
```py
import os

cwd = os.getcwd()
print(cwd)
```

Проверить наличие файла в текущем каталоге:
```py
os.path.exists('my_file')
```

Вывести список файлов и подкаталогов для данного каталога:
```py
os.listdir(path)
```

Следующий пример рекурсивно выводит список всех файлов и подкаталогов для текущего каталога:
```py
import os

def walk(dir):
  for name in os.listdir(dir):
    path = os.path.join(dir, name)
    if os.path.isfile(path):
        print(path)
    else:
        walk(path)

walk(os.getcwd())
```

В следующем примере мы получим статистическую информацию о текущем каталоге: общий размер каталога в байтах, число файлов, число подкаталогов. Стандартная функция os.path.walk имеет три параметра: каталог, пользовательская функция, список для подсчета:

```py не запустилось под Python3 - Разобраться
import os, sys

def getlocaldata(sms, dr, flst):
   for f in flst:
      fullf = os.path.join(dr,f)
      if os.path.islink(fullf): continue # don't count linked files
      if os.path.isfile(fullf):
          sms[0] += os.path.getsize(fullf)
          sms[1] += 1
      else:
          sms[2] += 1

def dtstat(dtroot):
   sums = [0,0,1] # 0 bytes, 0 files, 1 directory so far
   os.path.walk(dtroot, getlocaldata, sums)
   return sums
 
report = dtstat('.') # '.' обозначает текущий каталог
print(report)
```

В следующем примере сделана интерпретация системной утилиты grep. В текущем каталоге будут найдены файлы с питоновским расширением, в которых будет найдена поисковая строка 'import os':

```py
import os, sys, fnmatch
 
mask = '*.py'
pattern = 'import os'
 
def walk(arg,dir,files):
   for file in files:
     if fnmatch.fnmatch(file,mask):
        name = os.path.join(dir,file)
        try:
          data = open(name,'rb').read()
          if data.find(pattern) != -1:
            print name
        except:
            pass    

os.path.walk('.', walk, [])
```

***
* [Операции над строками (окончание)](#str)
* [Рекурсия](#recursia)
* [Типы файлов](#file_types)
