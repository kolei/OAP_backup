[содержание](/readme.md)  

# Тема 10. Знакомство с отдельными модулями<br/>Лекция 3. SQLite

* [SQLite в питоне](#SQLite-в-питоне)
    * [Соединение с базой, получение курсора](#Соединение-с-базой-получение-курсора)
    * [Чтение из базы](#Чтение-из-базы)
    * [Запись в базу](#Запись-в-базу)
    * [Объединяем запросы к базе данных в один вызов метода](#Объединяем-запросы-к-базе-данных-в-один-вызов-метода)
    * [Делаем подстановку значений в запрос](#Делаем-подстановку-значений-в-запрос)
    * [Множественная вставка строк](#Множественная-вставка-строк)
    * [Курсор как итератор](#Курсор-как-итератор)
* [Динамическое изменение структуры таблицы](#Динамическое-изменение-структуры-таблицы)

Сначала небольшое отступление про SQLite вообще (содрано [отсюда](https://habr.com/ru/post/149635/)):

SQLite — это встраиваемая кроссплатформенная БД, которая поддерживает достаточно полный набор команд SQL.

**Насколько SQLite популярна?**

Кратко: она везде. Как минимум, на любом смартфоне.

**Насколько она надежна?**

Очень. При выпуске версии она проходит через ряд серьезнейших автоматических тестов (проводится ~ 2 млн тестов), покрытие кода тестами 100% (с августа 2009).

**Что значит «достаточно полный набор SQL»?**

Как известно, в своем развитии SQL устремился в разные стороны. Крупные производители начали впихивать всякие расширения. И хотя принимаются всякие стандарты (SQL 92), в реальной жизни все крупные БД не придерживаются стандартов полностью + имеют что-то свое. Так вот, SQLite старается жить по принципу «минимальный, но полный набор». Она не поддерживает сложные штуки, но во многом соответствует SQL 92.

И вводит некие свои особенности, которые очень удобны, но — не стандартны.

**Что конкретно в поддержке SQL может вызвать недоумение?**

* Нельзя удалить или изменить столбец в таблице (ALTER TABLE DROP COLUMN…, ALTER TABLE ALTER COLUMN… ).
* Есть триггеры, но не настолько мощные как у крупных RDBMS.
* Есть поддержка foreign key, но по умолчанию — она ОТКЛЮЧЕНА.
* Нет встроенной поддержки UNICODE (но ее, вообщем, нетрудно добиться).
* Нет хранимых процедур.

**А что своего хорошего или необычного?**

* можно без труда организовать БД в памяти (это очень удобно и чуть позже расскажу подробнее);
* легко переносить: по умолчанию, БД — это один файл (в кроссплатформенном формате); 
* тип столбца не определяет тип хранимого значения в этом поле записи, то есть в любой столбец можно занести любое значение;
* много встроенных функций (которые можно использовать в SQL): www.sqlite.org/lang_corefunc.html

## Использование SQLite в многопоточных приложениях

SQLite может быть собран в однопоточном варианте (параметр компиляции SQLITE_THREADSAFE = 0). 

В этом варианте его нельзя одновременно использовать из нескольких потоков, поскольку полностью отсутствует код синхронизации. Зачем? Для бешеной скорости. 

Проверить, есть ли многопоточность можно через вызов sqlite3_threadsafe(): если вернула 0, то это однопоточный SQLite.

По умолчанию, SQLite собран с поддержкой потоков (sqlite3.dll).

Есть два способа использования многопоточного SQLite: **serialized** и **multi-thread**.

**Serialized** (надо указать флаг SQLITE_OPEN_FULLMUTEX при открытии соединения). В этом режиме потоки могут как угодно дергать вызовы SQLite, никаких ограничений. Но все вызовы блокируют друг друга и обрабатываются строго последовательно.

**Multi-thread** (SQLITE_OPEN_NOMUTEX). В этом режиме нельзя использовать одно и то же соединение одновременно из нескольких потоков (но допускается одновременное использование разных соединений разными потоками). Обычно используется именно этот режим.

## База данных в памяти

Если при открытии базы передать имя файла как ":memory:", то SQLite создаст соединение к новой (чистой) БД в памяти.

Это соединение абсолютно неотличимо от соединения к БД в файле по логике использования: доступен тот же набор SQL команд.

Можно даже открыть два соединения к одной БД в памяти.

rc = sqlite3_open("file:memdb1?mode=memory&cache=shared", &db);

```sql
ATTACH DATABASE 'file:memdb1?mode=memory&cache=shared' AS aux1;
```

База в памяти может быть полезна при тестировании и для кэширования часто используемых данных

## Присоединение одновременно к нескольким БД

Чтобы открыть соединение к БД используется вызов sqlite3_open().

В любой момент времени мы можем к открытому соединению присоединить еще до 10 баз данных через SQL команду ATTACH DATABASE.

```c
sqlite3_open('foo.sqlite3', &db); // откроем соединение к БД в файле "foo.sqlite3"

sqlite3_exec(&db, "ATTACH 'bar.sqlite3' AS bar", ... ); // присоединим "bar.sqlite3"
```

Теперь все таблицы БД в файле db1.sqlite3 стали прозрачно доступны в нашем соединении.

Для разрешения конфликтов имен следует использовать имя присоединения (основная база называется «main»):

```sql
SELECT * FROM main.my_table UNION SELECT * FROM bar.my_table
```

Ничего не мешает присоединить к БД новую базу в памяти и использовать ее для кэширования и пр.

```c
sqlite3_open('foo.sqlite3', &db); // откроем соединение к БД в файле "foo.sqlite3"

sqlite3_exec(&db, "ATTACH ':memory:' AS mem", ... ); // присоединим новую БД в памяти
```

## Тонкие настройки БД через команду PRAGMA

SQL команда PRAGMA служит для задания всевозможных настроек у соединения или у самой БД:

```sql
  PRAGMA name; // запросить текущее значение параметра name

  PRAGMA name = value; // задать параметр name значением value
```

Настройку соединения (очевидно) следует проводить сразу после открытия и до его использования.

Полное описание всех параметров находится [здесь](https://www.sqlite.org/pragma.html). 


## SQLite в питоне

Python имеет встроенную поддержку SQLite базы данных, для этого вам не надо ничего дополнительно устанавливать, достаточно в скрипте указать импорт стандартной библиотеки

```py
import sqlite3
```

>Питон может работать и с другими типами баз данных:
>
>База данных	| модуль
>:----------:|:------:
>PostgreSQL  | psycopg2
>MySQL       | mysql.connector
>ODBC        | pyodbc

### Соединение с базой, получение курсора

Для начала рассмотрим самый базовый шаблон, который будем использовать во всех дальнейших примерах:

```py
import sqlite3

# Создаем соединение с нашей базой данных (напоминаю, что база данных в SQLite это один файл). Если такого файла нет, то создаст новую базу
conn = sqlite3.connect('test.sqlite')

# Создаем курсор - это специальный объект который делает запросы и получает их результаты
cursor = conn.cursor()

# ТУТ БУДЕТ НАШ КОД РАБОТЫ С БАЗОЙ ДАННЫХ
# КОД ДАЛЬНЕЙШИХ ПРИМЕРОВ ВСТАВЛЯТЬ В ЭТО МЕСТО

# Не забываем закрыть соединение с базой данных
conn.close()
```

### Чтение из базы

```py
# Делаем SELECT запрос к базе данных, используя обычный SQL-синтаксис
cursor.execute("SELECT Name FROM Artist ORDER BY Name LIMIT 3")

# Получаем результат сделанного запроса
results = cursor.fetchall()
results2 =  cursor.fetchall()

print(results)   # [('A Cor Do Som',), ('Aaron Copland & London Symphony Orchestra',), ('Aaron Goldberg',)]
print(results2)  # []
```

**Обратите внимание**: После получения результата из курсора, второй раз без повторения самого запроса его получить нельзя — вернется пустой результат!



### Запись в базу

```py
# Делаем INSERT запрос к базе данных, используя обычный SQL-синтаксис
cursor.execute("insert into Artist values (Null, 'A Aagrh!') ")

# Если мы не просто читаем, но и вносим изменения в базу данных - необходимо сохранить транзакцию
conn.commit()

# Проверяем результат
cursor.execute("SELECT Name FROM Artist ORDER BY Name LIMIT 3")
results = cursor.fetchall()
print(results)  # [('A Aagrh!',), ('A Cor Do Som',), ('Aaron Copland & London Symphony Orchestra',)]
```

>Если к базе установлено несколько соединений и одно из них осуществляет модификацю базы, то база SQLite залочивается до завершения (метод соединения .commit()) или отмены (метод соединения .rollback()) транзакции.

### Разбиваем запрос на несколько строк в тройных кавычках

Длинные запросы можно разбивать на несколько строк в произвольном порядке, если они заключены в тройные кавычки — одинарные ('''…''') или двойные ("""...""")

```py
cursor.execute("""
  SELECT name
  FROM Artist
  ORDER BY Name LIMIT 3
""")
```

Конечно в таком простом примере разбивка не имеет смысла, но на сложных длинных запросах она может кардинально повышать читаемость кода.


### Объединяем запросы к базе данных в один вызов метода

Метод курсора .execute() позволяет делать только один запрос за раз, при попытке сделать несколько через точку с запятой будет ошибка.

Для решения такой задачи можно использовать метод курсора .executescript()

```py
cursor.executescript("""
 insert into Artist values (Null, 'A Aagrh!');
 insert into Artist values (Null, 'A Aagrh-2!');
""")
```

Данный метод также удобен, когда у нас запросы сохранены в отдельной переменной или даже в файле и нам надо применить такой запрос к базе.

### Делаем подстановку значений в запрос

**Важно!** Никогда, ни при каких условиях, не используйте конкатенацию строк (+) или интерполяцию параметра в строке (%) для передачи переменных в SQL запрос. Такое формирование запроса, при возможности попадания в него пользовательских данных – это ворота для SQL-инъекций!

Правильный способ – использование второго аргумента метода .execute()

Возможны два варианта: 

```py
# C подставновкой по порядку на места знаков вопросов:
cursor.execute("SELECT Name FROM Artist ORDER BY Name LIMIT ?", ('2'))

# И с использованием именованных замен:
cursor.execute("SELECT Name from Artist ORDER BY Name LIMIT :limit", {"limit": 3})
```

### Множественная вставка строк
Используя коллекцию с помощью метода курсора .executemany()

```py
# Обратите внимание, даже передавая одно значение - его нужно передавать кортежем!
# Именно по этому тут используется запятая в скобках!
new_artists = [
    ('A Aagrh!',),
    ('A Aagrh!-2',),
    ('A Aagrh!-3',),
]
cursor.executemany("insert into Artist values (Null, ?);", new_artists)
```

### Получаем результаты по одному, используя метод курсора .fetchone()

Он всегда возвращает кортеж или None. если запрос пустой.

```py
cursor.execute("SELECT Name FROM Artist ORDER BY Name LIMIT 3")
print(cursor.fetchone())    # ('A Cor Do Som',)
print(cursor.fetchone())    # ('Aaron Copland & London Symphony Orchestra',)
print(cursor.fetchone())    # ('Aaron Goldberg',)
print(cursor.fetchone())    # None
```

**Важно!** Стандартный курсор забирает все данные с сервера сразу, не зависимо от того, используем мы .fetchall() или .fetchone()


### Курсор как итератор

```py
# Использование курсора как итератора
for row in cursor.execute('SELECT Name from Artist ORDER BY Name LIMIT 3'):
        print(row)
# ('A Cor Do Som',)
# ('Aaron Copland & London Symphony Orchestra',)
# ('Aaron Goldberg',)
```

## Динамическое изменение структуры таблицы
В начале лекции уже упоминалось, что SQLite не поддерживает изменение и удаление полей, но добавить таблицы, поля или индексы можно. Я написал нехитрую функцию, которая по описанию структуры базы создает/добавляет таблицы и/или поля (пока без индексов, допилю на досуге).

```py
import sqlite3

# структура базы
STRU = [
        { 'table_name':'some_table',  # название таблицы
          'fields':[                  # массив полей
            { 'field_name':'field1',  # название поля
              'type':'integer',       # тип поля
              'add':'default 0'},     # дополнительная информация (опционально)  
            {'field_name':'field2','type':'text'},
            {'field_name':'field3','type':'integer'}]}
        ,{'table_name':'another_table','fields':[
            {'field_name':'field1','type':'integer','add':'default 0'},
            {'field_name':'field2','type':'text'},
            {'field_name':'field3','type':'integer'}]}
]

def check_stru(cursor):
  """ 
  Функция сверяет структуру базы, добавляет таблицы и поля, если их нет в файле БД
  ВНИМАНИЕ!!! SQLite не поддерживает изменение полей, при обнаружении различий в типе полей 
  функция выбросит исключение
  """
  for table in STRU:
    cursor.execute("SELECT name FROM sqlite_master WHERE type='table' AND name=?;", (table['table_name'],))
    row = cursor.fetchone()
    if row==None:
      # новая таблица
      sql = ''
      for field in table['fields']:
        sql += (',' if sql!='' else '')+field['field_name']+' '+field['type']+(' '+field['add'] if 'add' in field else '')
      sql = 'CREATE TABLE '+table.get('table_name')+' ('+sql+');'
      cursor.execute(sql)
    else:
      # таблица уже существует - сверяем поля
      cursor.execute("PRAGMA table_info("+table['table_name']+");")
      columns = cursor.fetchall()
      for field in table['fields']:
        for info in columns:
          if info[1]==field['field_name']:
            if info[2]!=field['type']:
              # поменялся тип
              raise Exception('SQLite не поддерживает изменение типа поля')
            else:
              break
        else:
          # поля нет
          cursor.execute("ALTER TABLE "+table['table_name']+" ADD COLUMN "+'{} {} {};'.format(field['field_name'], field['type'], field['add'] if field.get('add') else ''))


conn = sqlite3.connect('test.sqlite')
try:
  cursor = conn.cursor()
  check_stru(cursor)
finally:
  conn.close()
```

[содержание](/readme.md)  
