[содержание](/readme.md)  

# Тема 9. Часть 2 Шаблоны проектирования
# Шаблоны проектирования

>содрано [отсюда](https://tproger.ru/translations/design-patterns-simple-words-1/
), только примеры на Питон перевел

Шаблоны проектирования — это руководства по решению повторяющихся проблем. Это не классы, пакеты или библиотеки, которые можно было бы подключить к вашему приложению и сидеть в ожидании чуда. Они скорее являются методиками, как решать определенные проблемы в определенных ситуациях.

Википедия описывает их следующим образом:

Шаблон проектирования, или паттерн, в разработке программного обеспечения — повторяемая архитектурная конструкция, представляющая собой решение проблемы проектирования, в рамках некоторого часто возникающего контекста.

Будьте осторожны
* шаблоны проектирования не являются решением всех ваших проблем;
* не пытайтесь использовать их в обязательном порядке — это может привести к негативным последствиям. Шаблоны — это подходы к решению проблем, а не решения для поиска проблем;
* если их правильно использовать в нужных местах, то они могут стать спасением, а иначе могут привести к ужасному беспорядку.

## Типы шаблонов
Шаблоны бывают следующих трех видов:

* Порождающие
* [Структурные](#структурные-шаблоны)
* [Поведенческие](#поведенческие-шаблоны)

Многие шаблоны проектирования встроены в Python из коробки, а другие очень просто реализовать, используя базовые возможности языка.

## Порождающие шаблоны
Этот тип особенно важен, когда система зависит не столько от наследования классов, сколько от [композиции](https://habr.com/ru/post/325478/) (композиция — это когда один объект предоставляет другому свою функциональность частично или полностью). Порождающие паттерны отвечают за создание объектов и позволяют системе быть независимой от типов этих самых объектов и от процесса порождения.

В свою очередь, порождающие паттерны делятся на:

* Simple Factory
* Factory Method
* Abstract Factory
* Builder
* Prototype
* Singleton

>Примеры написаны на Python 3, он поддерживает UTF-8. Названия методов и классов на русском языке, чтобы студенты не пугались незнакомых слов, а сосредоточились на логике.

### Паттерн Simple Factory (Простая Фабрика)
В объектно-ориентированном программировании (ООП), фабрика — это объект для создания других объектов. Формально фабрика — это функция или метод, который возвращает объекты изменяющегося прототипа или класса из некоторого вызова метода, который считается «новым».

**Пример из жизни**: Представьте, что вам надо построить дом, и вам нужны двери. Было бы глупо каждый раз, когда вам нужны двери, надевать вашу столярную форму и начинать делать дверь. Вместо этого вы заказываете её на фабрике.

**Простыми словами**: Простая фабрика генерирует экземпляр для клиента, не раскрывая никакой логики.

Паттерн предназначен для инкапсуляции процесса образования объектов с помощью отдельного класса. «Простая Фабрика» удобна, но за простоту приходится платить: привязка к конкретной реализации исключает гибкость системы. Simple Factory следует использовать только там, где архитектура не будет изменяться.

Допустим, у нас есть интерфейс двери (пример переведен с java; в Питоне нет интерфейсов, вместо них можно использовать абстрактные классы, хотя в этом примере абстрактный класс и не нужен, срабоало бы и так из-за утиной типизации Питона):

```py
# в чистом питоне нет абстрактных методов - подключаем модуль abc (Abstract Base Class)
from abc import ABC, abstractmethod

class Дверь(ABC):
    @abstractmethod
    def Ширина(self)->float: pass
    @abstractmethod
    def Высота(self)->float: pass

class ДеревяннаяДверь(Дверь):
    """Класс реализует интерфейс `дверь`"""
    _width=None
    _height=None

    def __init__(self, width: float, height: float):
        self._width = width
        self._height = height

    def Ширина(self)->float:
        return self._width

    def Высота(self)->float:
        return self._height
```

Далее появляется завод, который изготавливает дверь и возвращает ее нам:

```py
class ЗаводДверей():
    @staticmethod
    def СделатьДверь(width: float, height: float):
        return ДеревяннаяДверь(width, height)
```

И только после этого мы можем воспользоваться нашей дверью:

```py
    дверь = ЗаводДверей.СделатьДверь(100, 200)
    print('Ширина:', дверь.Ширина())
    print('Высота:', дверь.Высота())
```

Как видно из кода, вызвав статический метод ``ЗаводДверей.СделатьДверь(100, 200)`` мы получили не экземпляр завода, а экземпляр двери, т.е. получили простую фабрику.

**Когда использовать**: Когда создание объекта — это не просто несколько присвоений, а какая-то логика, тогда имеет смысл создать отдельную фабрику вместо повторения одного и того же кода повсюду.

### Паттерн Fabric Method (Фабричный метод)
**Фабричный метод** — порождающий шаблон проектирования, предоставляющий подклассам интерфейс для создания экземпляров некоторого класса. В момент создания наследники могут определить, какой класс создавать. Иными словами, данный шаблон делегирует создание объектов наследникам родительского класса. Это позволяет использовать в коде программы не специфические классы, а манипулировать абстрактными объектами на более высоком уровне.

**Пример из жизни**: Рассмотрим пример с менеджером по найму. Невозможно одному человеку провести собеседования со всеми кандидатами на все вакансии. В зависимости от вакансии он должен распределить этапы собеседования между разными людьми.

**Простыми словами**: Менеджер предоставляет способ делегирования логики создания экземпляра дочерним классам.

Допустим, у нас есть интерфейс соискателя (метод ``задатьВопрос``):

```py
class Соискатель(ABC):
    @abstractmethod
    def задатьВопрос(self)->str: pass

class Разработчик(Соискатель):
    # перекрываем метод абстрактного класса
    def задатьВопрос(self)->str:
        return 'Спросить о шаблонах проектирования'

class АдминистраторБаз(Соискатель):
    # перекрываем метод абстрактного класса
    def задатьВопрос(self)->str:
        return 'Спросить о MySQL'
```

Теперь создаем менеджера по подбору персонала:

```py
class Менеджер(ABC):
    """Абстрактный класс менеджера"""
    @abstractmethod
    def сделатьСоискателя(self)->Соискатель: 
        """
        абстракный метод, декорирован @abstractmethod
        
        если не декорировать, то линтер будет ругаться на метод получитьОтвет (нет результата)
        плюс при обращении к абстактному методу декоратор выбросит исключение
        """
        pass

    def получитьОтвет(self):
        cоискатель = self.сделатьСоискателя()
        return cоискатель.задатьВопрос()
```

Предоставляем соискателей и реализуем в них метод "сделатьСоискателя" (полиморфизм в действии):

```py
class МенеджерРазработчиков(Менеджер):
    def сделатьСоискателя()->Соискатель:
        return Разработчик()

class МенеджерБаз(Менеджер):
    def сделатьСоискателя()->Соискатель:
        return АдминистраторБаз()
```

После чего можно использовать:

```py
менеджерРазработчиков = МенеджерРазработчиков()
print(менеджерРазработчиков.получитьОтвет())

менеджерБаз = МенеджерБаз()
print(менеджерБазanager.получитьОтвет())

чайник = Менеджер()
print(чайник.получитьОтвет()) # выдаст исключение
```

Обратите внимание: абстрактный класс ``class Менеджер(ABC):`` мы сделали потомком класса ABC, в этом случае и линтер предупредит, что нельзя получать экземпляр абстрактного класса и исключение выбросит что не реализован абстракный метод, а если сделать без родителя (``class Менеджер():``), то линтер предупреждений не выдаст, а при вызове метода ``чайник.получитьОтвет()`` получим исключение "у типа ``None`` нет метода получитьОтвет", т.к. абстрактный метод ``сделатьСоискателя()`` неявно возвращает как раз ``None``

**Когда использовать**: Полезен, когда есть некоторая общая обработка в классе, но необходимый подкласс динамически определяется во время выполнения. Иными словами, когда клиент не знает, какой именно подкласс ему может понадобиться.

### Абстрактная фабрика (Abstract Factory)
**Абстрактная фабрика** — порождающий шаблон проектирования, предоставляет интерфейс для создания семейств взаимосвязанных или взаимозависимых объектов, не специфицируя их конкретных классов. Шаблон реализуется созданием абстрактного класса Factory, который представляет собой интерфейс для создания компонентов системы (например, для оконного интерфейса он может создавать окна и кнопки). Затем пишутся классы, реализующие этот интерфейс.

Пример из жизни: Расширим наш пример про двери из простой фабрики. В зависимости от ваших нужд вам понадобится деревянная дверь из одного магазина, железная дверь — из другого или пластиковая — из третьего. Кроме того, вам понадобится соответствующий специалист: столяр для деревянной двери, сварщик для железной двери и так далее. Как вы можете заметить, тут есть зависимость между дверьми.

Простыми словами: Фабрика фабрик. Фабрика, которая группирует индивидуальные, но связанные/зависимые фабрики без указания их конкретных классов.

Обратимся к коду. Используем пример про двери. Сначала у нас есть интерфейс Door и несколько его реализаций:

```py
class Дверь(ABC):
    @abstractmethod
    def Описание(self)->str: pass

class ДеревяннаяДверь(Дверь):
    def Описание(self)->str:
        return 'Я деревянная дверь'

class ЖелезнаяДверь(Дверь):
    def Описание(self)->str:
        return 'Я железная дверь'
```

Затем у нас есть несколько мастеров по установке для каждого типа дверей:

```py
class УстановщикДверей(ABC):
    @abstractmethod
    def Описание(self)->str: pass

class Слесарь(УстановщикДверей):
    def Описание(self)->str:
        return 'Я работаю только с железными дверьми'

class Столяр(УстановщикДверей):
    def Описание(self)->str:
        return 'Я работаю только с деревянными дверьми'
```

Теперь нам нужна фабрика дверей, которая позволит нам создать семейство связанных объектов. То есть фабрика деревянных дверей предоставит нам деревянную дверь и эксперта по деревянным дверям. Аналогично для железных дверей:

```py
class ФабрикаДверей(ABC):
    @abstractmethod
    def СделатьДверь(self)->Дверь: pass
    @abstractmethod
    def ПредоставитьУстановщика(self)->УстановщикДверей: pass

# Деревянная фабрика вернет деревянную дверь и столяра
class ФабрикаДеревянныхДверей(ФабрикаДверей):
    def СделатьДверь(self)->Дверь:
        return ДеревяннаяДверь()
    def ПредоставитьУстановщика(self)->УстановщикДверей:
        return Столяр()

# Железная фабрика вернет железную дверь и слесаря
class ФабрикаЖелезныхДверей(ФабрикаДверей):
    def СделатьДверь(self)->Дверь:
        return ЖелезнаяДверь()
    def ПредоставитьУстановщика(self)->УстановщикДверей:
        return Слесарь()
```

Пример использования:

```py
фабрикаДеревянныхДверей = ФабрикаДеревянныхДверей()

дверь = фабрикаДеревянныхДверей.СделатьДверь()
установщик = фабрикаДеревянныхДверей.ПредоставитьУстановщика()

print( дверь.Описание() )       # Вывод: Я деревянная дверь
print( установщик.Описание() )  # Вывод: Я работаю только с деревянными дверями

# Аналогично для железной двери
```

Как вы можете заметить, фабрика деревянных дверей инкапсулирует столяра и деревянную дверь, а фабрика железных дверей инкапсулирует железную дверь и слесаря. Это позволило нам убедиться, что для каждой двери мы получим нужного нам установщика.

**Когда использовать**: Когда есть взаимосвязанные зависимости с не очень простой логикой создания.

### Строитель (Builder)
**Строитель** — порождающий шаблон проектирования, который предоставляет способ создания составного объекта. Предназначен для решения проблемы антипаттерна «Телескопический конструктор».

**Пример из жизни**: Представьте, что вы пришли в McDonalds и заказали конкретный продукт, например, БигМак, и вам готовят его без лишних вопросов. Это пример простой фабрики. Но есть случаи, когда логика создания может включать в себя больше шагов. Например, вы хотите индивидуальный сэндвич в Subway: у вас есть несколько вариантов того, как он будет сделан. Какой хлеб вы хотите? Какие соусы использовать? Какой сыр? В таких случаях на помощь приходит шаблон «Строитель».

**Простыми словами**: Шаблон позволяет вам создавать различные виды объекта, избегая засорения конструктора. Он полезен, когда может быть несколько видов объекта или когда необходимо множество шагов, связанных с его созданием.

Давайте я покажу на примере, что такое «Телескопический конструктор». 

```py
def __init__(size, cheese = True, pepperoni = True, tomato = False, lettuce = True):
    pass
```    

Как вы можете заметить, количество параметров конструктора может резко увеличиться, и станет сложно понимать расположение параметров. Кроме того, этот список параметров будет продолжать расти, если вы захотите добавить новые варианты. Это и есть «Телескопический конструктор».

Перейдем к примеру в коде. Адекватной альтернативой будет использование шаблона «Строитель». Сначала у нас есть Бутерброд, который мы хотим создать:

```py
class Бутерброд():
    _размер=None
    _сыр = False
    _колбаса = False
    _салат = False
    _помидор = False

    def __init__(self, бутерброд):
        self._размер = бутерброд.размер
        self._сыр = бутерброд.сыр
        self._колбаса = бутерброд.колбаса
        self._салат = бутерброд.салат
        self._помидор = бутерброд.помидор

    # реализуем приведение к базовому типу, чтобы при печати печаталось не название класса, а вкусняшка    
    def __str__(self):
        res = 'размер {}'.format(self._размер) 
        if self._сыр: res += ', сыр'
        if self._колбаса: res += ', колбаса'
        if self._салат: res += ', салат'
        if self._помидор: res += ', помидор'
        return res
```

Аттрибуты бутерброда приватные, мы не будем его разбирать - употребим целиком.

Затем мы берём «Строителя»:

```py
class СтроительБутербродов():
    размер=None
    сыр = False
    колбаса = False
    салат = False
    помидор = False

    def __init__(self, размер: int):
        self.размер = размер

    def добавитьКолбасу(self):
        self.колбаса = True
        return self

    def добавитьСалат(self):
        self.салат = True
        return self

    def добавитьСыр(self):
        self.сыр = True
        return self

    def добавитьПомидор(self):
        self.помидор = True
        return self

    def создать(self):
        return Бутерброд(self)
```

А вот у строителя аттрибуты публичные, т.к. используются при постронении бутерброда

Пример использования:

```py
бутерброд = СтроительБутербродов(14).\
                добавитьКолбасу().\
                добавитьСалат().\
                добавитьПомидор().\
                создать()
print(бутерброд)

>размер 14, колбаса, салат, помидор
```

**Когда использовать**: Когда может быть несколько видов объекта и надо избежать «телескопического конструктора». Главное отличие от «фабрики» — это то, что она используется, когда создание занимает один шаг, а «строитель» применяется при множестве шагов.

### Прототип (Prototype)
Задаёт виды создаваемых объектов с помощью экземпляра-прототипа и создаёт новые объекты путём копирования этого прототипа. Он позволяет уйти от реализации и позволяет следовать принципу «программирование через интерфейсы». В качестве возвращающего типа указывается интерфейс / абстрактный класс на вершине иерархии, а классы-наследники могут подставить туда наследника, реализующего этот тип.

**Пример из жизни**: Помните Долли? Овечка, которая была клонирована. Не будем углубляться, главное — это то, что здесь все вращается вокруг клонирования.

**Простыми словами**: Прототип создает объект, основанный на существующем объекте при помощи клонирования.

То есть он позволяет вам создавать копию существующего объекта и модернизировать его согласно вашим нуждам, вместо того, чтобы создавать объект заново.

Паттерн Прототип реализован в базовой библиотеке Python посредством интерфейса Cloneable. 
А непосредственно скопировать можно функцией copy из стандартной библиотеки

```py
import copy

class Какойто():
    аттрибут = 1

какойто = Какойто()

сякой = copy.copy(какойто)
сякой.аттрибут = 2
```

### Одиночка (Singleton)
**Одиночка** — порождающий шаблон проектирования, гарантирующий, что в однопроцессном приложении будет единственный экземпляр некоторого класса, и предоставляющий глобальную точку доступа к этому экземпляру.

**Пример из жизни**: В семье всего одна пара тапочек, одеть их может только один человек.

**Простыми словами**: Обеспечивает тот факт, что создаваемый объект является единственным объектом своего класса.

Вообще шаблон одиночка признан антипаттерном, необходимо избегать его чрезмерного использования. Он необязательно плох и может иметь полезные применения, но использовать его надо с осторожностью, потому что он вводит глобальное состояние в ваше приложение и его изменение в одном месте может повлиять на другие части приложения, что вызовет трудности при отладке. Другой минус — это то, что он делает ваш код связанным.

В Питоне паттерн реализуется простым добавлением метода \_\_new\_\_ (мы уже рассматривали этот пример в теме про ООП)

Напишем класс ЧьиТапки :)

```py
class ЧьиТапки():
  obj = None
  имя = None
  def __new__(cls, имя):
    # если экземпляр класса уже создан, то возвращается ссылка на него
    if cls.obj is None:
      cls.obj = object.__new__(cls)
      cls.имя = имя    
    return cls.obj

первый = ЧьиТапки('Елена Прекрасная')
второй = ЧьиТапки('Иван Дурак')

print('чьи тапки: ', второй.имя)
>чьи тапки: Елена Прекрасная
```

## Структурные шаблоны
**Простыми словами**: Структурные шаблоны в основном связаны с композицией объектов, другими словами, с тем, как сущности могут использовать друг друга. Ещё одним объяснением было бы то, что они помогают ответить на вопрос «Как создать программный компонент?».

Список структурных шаблонов проектирования:

* адаптер (Adapter);
* мост (Bridge);
* компоновщик (Composite);
* декоратор (Decorator);
* фасад (Facade);
* приспособленец (Flyweight);
* заместитель (Proxy).

### Адаптер (Adapter)
**Адаптер** — структурный шаблон проектирования, предназначенный для организации использования функций объекта, недоступного для модификации, через специально созданный интерфейс.

**Пример из жизни**: Представим, что у вас на карте памяти есть какие-то изображения и вам надо перенести их на ваш компьютер. Чтобы это сделать, вам нужен какой-то адаптер, который совместим с портами вашего компьютера. В этом случае карт-ридер — это адаптер. Другим примером будет блок питания. Вилку с тремя ножками нельзя вставить в розетку с двумя отверстиями. Для того, чтобы она подошла, надо использовать адаптер. Ещё одним примером будет переводчик, переводящий слова одного человека для другого.

**Простыми словами**: Шаблон позволяет обернуть несовместимые объекты в адаптер, чтобы сделать их совместимыми с другим классом.

Обратимся к коду. Представим гипотетичекий миномет, стреляющий обычными минами.
 
```py
class Мина():
    _калибр = 10

class Миномет():
    _калибр = 10

    def Зарядить(self, мина):
        # чтобы влезло, нужно,чтобы калибр совпал
        if self._калибр == мина._калибр:
            return True
        else:
            return False
```

Все было хорошо, но яйцеголовые умники изобрели супер-пупер взрывчатку и новые мины стали размером с карандаш (на вес внимания не обращаем). А на складах минобороны этих минометов как у дурака махорки. Те-же умники быстро родили адаптер для выстрела, чтобы совпадало со старым калибром.

```py
class СуперМина():
    _калибр = 1

# Адаптер, чтобы калибры совпадали
class АдаптерДляСуперМины(Мина):
    ОБМОТАТЬ_ИЗОЛЕНТОЙ = 9
    def __init__(self, супер_мина):
        self._калибр = супер_мина._калибр+self.ОБМОТАТЬ_ИЗОЛЕНТОЙ
```

Способ применения:

```py
мина = Мина()
суперМина = СуперМина()
миномет = Миномет()

if миномет.Зарядить(мина):
    print('обычная мина заряжена')    

if not миномет.Зарядить(суперМина):
    print('гранаты не той системы')    

адаптер = АдаптерДляСуперМины(суперМина)

if миномет.Зарядить(адаптер):
    print('супер-мина заряжена')    
```

### Мост (Bridge)
**Мост** — структурный шаблон проектирования, используемый в проектировании программного обеспечения чтобы разделять абстракцию и реализацию так, чтобы они могли изменяться независимо. Шаблон мост использует инкапсуляцию, агрегирование и может использовать наследование для того, чтобы разделить ответственность между классами.

**Пример из жизни**: Представим, что у вас есть сайт с разными страницами, и вам надо разрешить пользователям менять их тему. Что вы будете делать? Создавать множественные копии каждой страницы для каждой темы или просто отдельную тему, которую пользователь сможет выбрать сам? Шаблон мост позволяет вам сделать второе.

**Простыми словами**: Шаблон мост — это предпочтение композиции над наследованием. Детали реализации передаются из одной иерархии в другой объект с отдельной иерархией.

Обратимся к примеру в коде. Возьмем пример с нашими страницами. У нас есть иерархия ВебСтраничка:

```py
class ВебСтраничка(ABC):
    @abstractmethod
    def __init__(self, тема): pass
    @abstractmethod
    def получитьСодержимое(self): pass

class ОНас(ВебСтраничка):
    _тема=None

    def __init__(self, тема):
        self._тема = тема

    def получитьСодержимое(self):
        return "Страница с информацией в " + self._тема.цвет()

class Новости(ВебСтраничка):
    _тема=None

    def __init__(self, тема):
        self._тема = тема

    def получитьСодержимое(self):
        return "Страница с новостями в " + self._тема.цвет()
```

И отдельная иерархия Тема:

```py
class Тема(ABC):
    @abstractmethod
    def цвет(self): pass

class ТёмнаяТема(Тема):
    def цвет(self):
        return 'темной теме'

class СветлаяТема(Тема):
    def цвет(self):
        return 'светлой теме'
```

Применение в коде:

```py
тёмнаяТема = ТёмнаяТема()
светлаяТема = СветлаяТема()

новости = Новости(тёмнаяТема)
оНас = ОНас(светлаяТема)

print(новости.получитьСодержимое()) # "Страница с новостями в темной теме"
print(оНас.получитьСодержимое()) # "Страница с информацией в светлой теме"
```

### Компоновщик (Composite)
**Компоновщик** — структурный шаблон проектирования, объединяющий объекты в древовидную структуру для представления иерархии от частного к целому. Компоновщик позволяет клиентам обращаться к отдельным объектам и к группам объектов одинаково. Паттерн определяет иерархию классов, которые одновременно могут состоять из примитивных и сложных объектов, упрощает архитектуру клиента, делает процесс добавления новых видов объекта более простым.

**Пример из жизни**: Каждая организация скомпонована из сотрудников. У каждого сотрудника есть одинаковые свойства, такие как зарплата, обязанности, отчётность и т.д.

**Простыми словами**: Шаблон компоновщик позволяет клиентам работать с индивидуальными объектами в едином стиле.

Обратимся к коду. Возьмем наш пример с рабочими. У нас есть Работники разных типов:

```py
from abc import ABC, abstractmethod

class Исполнитель(ABC):
    @abstractmethod
    def можетВыполнить(self, задача)->bool: pass
    @abstractmethod
    def получитьЗадание(self, задача): pass

class Работник(Исполнитель):
    def __init__(self, имя):
        self.имя = имя
    def можетВыполнить(self, задача)->bool:
        return True
    def получитьЗадание(self, задача):
        print('{} получил задачу {}'.format(self.имя, задача))

class Команда(Исполнитель):
    _исполнители=set()

    # вспомогательные методы для управления множеством
    def добавить(self, исполнитель):
        self._исполнители.add(исполнитель)
        return self
    def удалить(self, исполнитель):
        self._исполнители.discard(исполнитель)
        return self

    # методы интерфейса Исполнитель
    def можетВыполнить(self, задача)->bool:
        for исполнитель in self._исполнители:
            if исполнитель.можетВыполнить(задача): return True
        return False
  
    def получитьЗадание(self, задача):
        """может быть разная реализация - 
        допустим, некоторые задания требуют нескольких человек из команды одновременно или работники могут быть заняты...
        в простейшем случае берем первого работника 
        (и удяляем его из команды)"""
        исполнитель = self._исполнители.pop()
        исполнитель.получитьЗадание(задача)
```

Еще у нас есть Начальник:

```py
class Начальник():
    _исполнители = set()
    def __init__(self, исполнители):
        self._исполнители.update(исполнители)
    def датьЗадание(self, задача):
        for исполнитель in  self._исполнители:
            if исполнитель.можетВыполнить(задача):
                исполнитель.получитьЗадание(задача)
                # из команды сами рассосуться
                if type(исполнитель) == Работник:
                    self._исполнители.discard(исполнитель)
                return
        raise Exception('не нашел исполнителя для задачи')
```

Способ применения (в моей реализации работники удаляются, но можно просто добавить флаг занятости, зависящий от задачи):

```py
трус = Работник('трус')
балбес = Работник('балбес')
бывалый = Работник('бывалый')

собутыльники = Команда().добавить(трус).добавить(балбес)

степан_степаныч = Начальник({собутыльники, бывалый})

try:
    степан_степаныч.датьЗадание('вскопать грядку')
    степан_степаныч.датьЗадание('наколоть дров')
    степан_степаныч.датьЗадание('наносить воды')
    степан_степаныч.датьЗадание('написать отчет')
except Exception as e:
    print('что-то случилось: ', e)
```

На выходе получим что-то подобное:

```
балбес получил задачу вскопать грядку
трус получил задачу наколоть дров
бывалый получил задачу наносить воды
что-то случилось:  не нашел исполнителя для задачи    
```

остановился тут

## Поведенческие шаблоны
Поведенческие паттерны отвечают за эффективное взаимодействие объектов. В отличие от структурных, они также затрагивают шаблоны для обмена сообщениями.

Эта группа решений объясняет, как организовывать связи между объектами. Банда четырех определила 11 моделей поведения. Среди них Итератор, Цепочка обязанностей и Команда.

### Итератор
Итераторы встроены в Python. Это одна из самых мощных возможностей языка. Во многом именно итераторы делают его таким удобным. Чтобы разобраться в паттерне Итератор, следует просто изучить механизм работы итераторов и генераторов языка.

[содержание](/readme.md)  

