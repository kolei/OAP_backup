[содержание](/readme.md)  

# Тема 9. Часть 2 Шаблоны проектирования
# Шаблоны проектирования

>содрано [отсюда](https://tproger.ru/translations/design-patterns-simple-words-1/
), только примеры на Питон перевел

Шаблоны проектирования — это руководства по решению повторяющихся проблем. Это не классы, пакеты или библиотеки, которые можно было бы подключить к вашему приложению и сидеть в ожидании чуда. Они скорее являются методиками, как решать определенные проблемы в определенных ситуациях.

Википедия описывает их следующим образом:

Шаблон проектирования, или паттерн, в разработке программного обеспечения — повторяемая архитектурная конструкция, представляющая собой решение проблемы проектирования, в рамках некоторого часто возникающего контекста.

Будьте осторожны
* шаблоны проектирования не являются решением всех ваших проблем;
* не пытайтесь использовать их в обязательном порядке — это может привести к негативным последствиям. Шаблоны — это подходы к решению проблем, а не решения для поиска проблем;
* если их правильно использовать в нужных местах, то они могут стать спасением, а иначе могут привести к ужасному беспорядку.

## Типы шаблонов
Шаблоны бывают следующих трех видов:

* Порождающие
* [Структурные](#структурные-шаблоны)
* [Поведенческие](#поведенческие-шаблоны)

Многие шаблоны проектирования встроены в Python из коробки, а другие очень просто реализовать, используя базовые возможности языка.

## Порождающие шаблоны
Этот тип особенно важен, когда система зависит не столько от наследования классов, сколько от [композиции](https://habr.com/ru/post/325478/) (композиция — это когда один объект предоставляет другому свою функциональность частично или полностью). Порождающие паттерны отвечают за создание объектов и позволяют системе быть независимой от типов этих самых объектов и от процесса порождения.

В свою очередь, порождающие паттерны делятся на:

* Simple Factory
* Factory Method
* Abstract Factory
* Builder
* Prototype
* Singleton

>Примеры написаны на Python 3, он поддерживает UTF-8. Названия методов и классов на русском языке, чтобы студенты не пугались незнакомых слов, а сосредоточились на логике.

### Шаблон Simple Factory (Простая Фабрика)
В объектно-ориентированном программировании (ООП), фабрика — это объект для создания других объектов. Формально фабрика — это функция или метод, который возвращает объекты изменяющегося прототипа или класса из некоторого вызова метода, который считается «новым».

**Пример из жизни**: Представьте, что вам надо построить дом, и вам нужны двери. Было бы глупо каждый раз, когда вам нужны двери, надевать вашу столярную форму и начинать делать дверь. Вместо этого вы заказываете её на фабрике.

**Простыми словами**: Простая фабрика генерирует экземпляр для клиента, не раскрывая никакой логики.

Паттерн предназначен для инкапсуляции процесса образования объектов с помощью отдельного класса. «Простая Фабрика» удобна, но за простоту приходится платить: привязка к конкретной реализации исключает гибкость системы. Simple Factory следует использовать только там, где архитектура не будет изменяться.

Допустим, у нас есть интерфейс двери (пример переведен с java; в Питоне нет интерфейсов, вместо них можно использовать абстрактные классы, хотя в этом примере абстрактный класс и не нужен, срабоало бы и так из-за утиной типизации Питона):

```py
# в чистом питоне нет абстрактных методов - подключаем модуль abc (Abstract Base Class)
from abc import ABC, abstractmethod

class Дверь(ABC):
    @abstractmethod
    def Ширина(self)->float: pass
    @abstractmethod
    def Высота(self)->float: pass

class ДеревяннаяДверь(Дверь):
    """Класс реализует интерфейс `дверь`"""
    _width=None
    _height=None

    def __init__(self, width: float, height: float):
        self._width = width
        self._height = height

    def Ширина(self)->float:
        return self._width

    def Высота(self)->float:
        return self._height
```

Далее появляется завод, который изготавливает дверь и возвращает ее нам:

```py
class ЗаводДверей():
    @staticmethod
    def СделатьДверь(width: float, height: float):
        return ДеревяннаяДверь(width, height)
```

И только после этого мы можем воспользоваться нашей дверью:

```py
    дверь = ЗаводДверей.СделатьДверь(100, 200)
    print('Ширина:', дверь.Ширина())
    print('Высота:', дверь.Высота())
```

Как видно из кода, вызвав статический метод ``ЗаводДверей.СделатьДверь(100, 200)`` мы получили не экземпляр завода, а экземпляр двери, т.е. получили простую фабрику.

**Когда использовать**: Когда создание объекта — это не просто несколько присвоений, а какая-то логика, тогда имеет смысл создать отдельную фабрику вместо повторения одного и того же кода повсюду.

### Шаблон Fabric Method (Фабричный метод)
**Фабричный метод** — порождающий шаблон проектирования, предоставляющий подклассам интерфейс для создания экземпляров некоторого класса. В момент создания наследники могут определить, какой класс создавать. Иными словами, данный шаблон делегирует создание объектов наследникам родительского класса. Это позволяет использовать в коде программы не специфические классы, а манипулировать абстрактными объектами на более высоком уровне.

**Пример из жизни**: Рассмотрим пример с менеджером по найму. Невозможно одному человеку провести собеседования со всеми кандидатами на все вакансии. В зависимости от вакансии он должен распределить этапы собеседования между разными людьми.

**Простыми словами**: Менеджер предоставляет способ делегирования логики создания экземпляра дочерним классам.

Допустим, у нас есть интерфейс соискателя (метод ``задатьВопрос``):

```py
class Соискатель(ABC):
    @abstractmethod
    def задатьВопрос(self)->str: pass

class Разработчик(Соискатель):
    # перекрываем метод абстрактного класса
    def задатьВопрос(self)->str:
        return 'Спросить о шаблонах проектирования'

class АдминистраторБаз(Соискатель):
    # перекрываем метод абстрактного класса
    def задатьВопрос(self)->str:
        return 'Спросить о MySQL'
```

Теперь создаем менеджера по подбору персонала:

```py
class Менеджер(ABC):
    """Абстрактный класс менеджера"""
    @abstractmethod
    def сделатьСоискателя(self)->Соискатель: 
        """
        абстракный метод, декорирован @abstractmethod
        
        если не декорировать, то линтер будет ругаться на метод получитьОтвет (нет результата)
        плюс при обращении к абстактному методу декоратор выбросит исключение
        """
        pass

    def получитьОтвет(self):
        cоискатель = self.сделатьСоискателя()
        return cоискатель.задатьВопрос()
```

Предоставляем соискателей и реализуем в них метод "сделатьСоискателя" (полиморфизм в действии):

```py
class МенеджерРазработчиков(Менеджер):
    def сделатьСоискателя()->Соискатель:
        return Разработчик()

class МенеджерБаз(Менеджер):
    def сделатьСоискателя()->Соискатель:
        return АдминистраторБаз()
```

После чего можно использовать:

```py
менеджерРазработчиков = МенеджерРазработчиков()
print(менеджерРазработчиков.получитьОтвет())

менеджерБаз = МенеджерБаз()
print(менеджерБазanager.получитьОтвет())

чайник = Менеджер()
print(чайник.получитьОтвет()) # выдаст исключение
```

Обратите внимание: абстрактный класс ``class Менеджер(ABC):`` мы сделали потомком класса ABC, в этом случае и линтер предупредит, что нельзя получать экземпляр абстрактного класса и исключение выбросит что не реализован абстракный метод, а если сделать без родителя (``class Менеджер():``), то линтер предупреждений не выдаст, а при вызове метода ``чайник.получитьОтвет()`` получим исключение "у типа ``None`` нет метода получитьОтвет", т.к. абстрактный метод ``сделатьСоискателя()`` неявно возвращает как раз ``None``

**Когда использовать**: Полезен, когда есть некоторая общая обработка в классе, но необходимый подкласс динамически определяется во время выполнения. Иными словами, когда клиент не знает, какой именно подкласс ему может понадобиться.

### Абстрактная фабрика (Abstract Factory)
**Абстрактная фабрика** — порождающий шаблон проектирования, предоставляет интерфейс для создания семейств взаимосвязанных или взаимозависимых объектов, не специфицируя их конкретных классов. Шаблон реализуется созданием абстрактного класса Factory, который представляет собой интерфейс для создания компонентов системы (например, для оконного интерфейса он может создавать окна и кнопки). Затем пишутся классы, реализующие этот интерфейс.

Пример из жизни: Расширим наш пример про двери из простой фабрики. В зависимости от ваших нужд вам понадобится деревянная дверь из одного магазина, железная дверь — из другого или пластиковая — из третьего. Кроме того, вам понадобится соответствующий специалист: столяр для деревянной двери, сварщик для железной двери и так далее. Как вы можете заметить, тут есть зависимость между дверьми.

Простыми словами: Фабрика фабрик. Фабрика, которая группирует индивидуальные, но связанные/зависимые фабрики без указания их конкретных классов.

Обратимся к коду. Используем пример про двери. Сначала у нас есть интерфейс Door и несколько его реализаций:

```py
class Дверь(ABC):
    @abstractmethod
    def Описание(self)->str: pass

class ДеревяннаяДверь(Дверь):
    def Описание(self)->str:
        return 'Я деревянная дверь'

class ЖелезнаяДверь(Дверь):
    def Описание(self)->str:
        return 'Я железная дверь'
```

Затем у нас есть несколько мастеров по установке для каждого типа дверей:

```py
class УстановщикДверей(ABC):
    @abstractmethod
    def Описание(self)->str: pass

class Слесарь(УстановщикДверей):
    def Описание(self)->str:
        return 'Я работаю только с железными дверьми'

class Столяр(УстановщикДверей):
    def Описание(self)->str:
        return 'Я работаю только с деревянными дверьми'
```

Теперь нам нужна фабрика дверей, которая позволит нам создать семейство связанных объектов. То есть фабрика деревянных дверей предоставит нам деревянную дверь и эксперта по деревянным дверям. Аналогично для железных дверей:

```py
class ФабрикаДверей(ABC):
    @abstractmethod
    def СделатьДверь(self)->Дверь: pass
    @abstractmethod
    def ПредоставитьУстановщика(self)->УстановщикДверей: pass

# Деревянная фабрика вернет деревянную дверь и столяра
class ФабрикаДеревянныхДверей(ФабрикаДверей):
    def СделатьДверь(self)->Дверь:
        return ДеревяннаяДверь()
    def ПредоставитьУстановщика(self)->УстановщикДверей:
        return Столяр()

# Железная фабрика вернет железную дверь и слесаря
class ФабрикаЖелезныхДверей(ФабрикаДверей):
    def СделатьДверь(self)->Дверь:
        return ЖелезнаяДверь()
    def ПредоставитьУстановщика(self)->УстановщикДверей:
        return Слесарь()
```

Пример использования:

```py
фабрикаДеревянныхДверей = ФабрикаДеревянныхДверей()

дверь = фабрикаДеревянныхДверей.СделатьДверь()
установщик = фабрикаДеревянныхДверей.ПредоставитьУстановщика()

print( дверь.Описание() )       # Вывод: Я деревянная дверь
print( установщик.Описание() )  # Вывод: Я работаю только с деревянными дверями

# Аналогично для железной двери
```

Как вы можете заметить, фабрика деревянных дверей инкапсулирует столяра и деревянную дверь, а фабрика железных дверей инкапсулирует железную дверь и слесаря. Это позволило нам убедиться, что для каждой двери мы получим нужного нам установщика.

**Когда использовать**: Когда есть взаимосвязанные зависимости с не очень простой логикой создания.

### Строитель (Builder)
**Строитель** — порождающий шаблон проектирования, который предоставляет способ создания составного объекта. Предназначен для решения проблемы антипаттерна «Телескопический конструктор».

**Пример из жизни**: Представьте, что вы пришли в McDonalds и заказали конкретный продукт, например, БигМак, и вам готовят его без лишних вопросов. Это пример простой фабрики. Но есть случаи, когда логика создания может включать в себя больше шагов. Например, вы хотите индивидуальный сэндвич в Subway: у вас есть несколько вариантов того, как он будет сделан. Какой хлеб вы хотите? Какие соусы использовать? Какой сыр? В таких случаях на помощь приходит шаблон «Строитель».

**Простыми словами**: Шаблон позволяет вам создавать различные виды объекта, избегая засорения конструктора. Он полезен, когда может быть несколько видов объекта или когда необходимо множество шагов, связанных с его созданием.

Давайте я покажу на примере, что такое «Телескопический конструктор». 

```py
def __init__(size, cheese = True, pepperoni = True, tomato = False, lettuce = True):
    pass
```    

Как вы можете заметить, количество параметров конструктора может резко увеличиться, и станет сложно понимать расположение параметров. Кроме того, этот список параметров будет продолжать расти, если вы захотите добавить новые варианты. Это и есть «Телескопический конструктор».

Перейдем к примеру в коде. Адекватной альтернативой будет использование шаблона «Строитель». Сначала у нас есть Бутерброд, который мы хотим создать:

```py
class Бутерброд():
    _размер=None
    _сыр = False
    _колбаса = False
    _салат = False
    _помидор = False

    def __init__(self, бутерброд):
        self._размер = бутерброд.размер
        self._сыр = бутерброд.сыр
        self._колбаса = бутерброд.колбаса
        self._салат = бутерброд.салат
        self._помидор = бутерброд.помидор

    # реализуем приведение к базовому типу, чтобы при печати печаталось не название класса, а вкусняшка    
    def __str__(self):
        res = 'размер {}'.format(self._размер) 
        if self._сыр: res += ', сыр'
        if self._колбаса: res += ', колбаса'
        if self._салат: res += ', салат'
        if self._помидор: res += ', помидор'
        return res
```

Аттрибуты бутерброда приватные, мы не будем его разбирать - употребим целиком.

Затем мы берём «Строителя»:

```py
class СтроительБутербродов():
    размер=None
    сыр = False
    колбаса = False
    салат = False
    помидор = False

    def __init__(self, размер: int):
        self.размер = размер

    def добавитьКолбасу(self):
        self.колбаса = True
        return self

    def добавитьСалат(self):
        self.салат = True
        return self

    def добавитьСыр(self):
        self.сыр = True
        return self

    def добавитьПомидор(self):
        self.помидор = True
        return self

    def создать(self):
        return Бутерброд(self)
```

А вот у строителя аттрибуты публичные, т.к. используются при постронении бутерброда

Пример использования:

```py
бутерброд = СтроительБутербродов(14).\
                добавитьКолбасу().\
                добавитьСалат().\
                добавитьПомидор().\
                создать()
print(бутерброд)

>размер 14, колбаса, салат, помидор
```

**Когда использовать**: Когда может быть несколько видов объекта и надо избежать «телескопического конструктора». Главное отличие от «фабрики» — это то, что она используется, когда создание занимает один шаг, а «строитель» применяется при множестве шагов.

### Прототип (Prototype)
Задаёт виды создаваемых объектов с помощью экземпляра-прототипа и создаёт новые объекты путём копирования этого прототипа. Он позволяет уйти от реализации и позволяет следовать принципу «программирование через интерфейсы». В качестве возвращающего типа указывается интерфейс / абстрактный класс на вершине иерархии, а классы-наследники могут подставить туда наследника, реализующего этот тип.

**Пример из жизни**: Помните Долли? Овечка, которая была клонирована. Не будем углубляться, главное — это то, что здесь все вращается вокруг клонирования.

**Простыми словами**: Прототип создает объект, основанный на существующем объекте при помощи клонирования.

То есть он позволяет вам создавать копию существующего объекта и модернизировать его согласно вашим нуждам, вместо того, чтобы создавать объект заново.

Паттерн Прототип реализован в базовой библиотеке Python посредством интерфейса Cloneable. 
А непосредственно скопировать можно функцией copy из стандартной библиотеки

```py
import copy

class Какойто():
    аттрибут = 1

какойто = Какойто()

сякой = copy.copy(какойто)
сякой.аттрибут = 2
```

### Одиночка (Singleton)
**Одиночка** — порождающий шаблон проектирования, гарантирующий, что в однопроцессном приложении будет единственный экземпляр некоторого класса, и предоставляющий глобальную точку доступа к этому экземпляру.

**Пример из жизни**: В семье всего одна пара тапочек, одеть их может только один человек.

**Простыми словами**: Обеспечивает тот факт, что создаваемый объект является единственным объектом своего класса.

Вообще шаблон одиночка признан антипаттерном, необходимо избегать его чрезмерного использования. Он необязательно плох и может иметь полезные применения, но использовать его надо с осторожностью, потому что он вводит глобальное состояние в ваше приложение и его изменение в одном месте может повлиять на другие части приложения, что вызовет трудности при отладке. Другой минус — это то, что он делает ваш код связанным.

В Питоне паттерн реализуется простым добавлением метода \_\_new\_\_ (мы уже рассматривали этот пример в теме про ООП)

Напишем класс ЧьиТапки :)

```py
class ЧьиТапки():
  obj = None
  имя = None
  def __new__(cls, имя):
    # если экземпляр класса уже создан, то возвращается ссылка на него
    if cls.obj is None:
      cls.obj = object.__new__(cls)
      cls.имя = имя    
    return cls.obj

первый = ЧьиТапки('Елена Прекрасная')
второй = ЧьиТапки('Иван Дурак')

print('чьи тапки: ', второй.имя)
>чьи тапки: Елена Прекрасная
```

## Структурные шаблоны
**Простыми словами**: Структурные шаблоны в основном связаны с композицией объектов, другими словами, с тем, как сущности могут использовать друг друга. Ещё одним объяснением было бы то, что они помогают ответить на вопрос «Как создать программный компонент?».

Список структурных шаблонов проектирования:

* адаптер (Adapter);
* мост (Bridge);
* компоновщик (Composite);
* декоратор (Decorator);
* фасад (Facade);
* приспособленец (Flyweight);
* заместитель (Proxy).

### Адаптер (Adapter)
**Адаптер** — структурный шаблон проектирования, предназначенный для организации использования функций объекта, недоступного для модификации, через специально созданный интерфейс.

**Пример из жизни**: Представим, что у вас на карте памяти есть какие-то изображения и вам надо перенести их на ваш компьютер. Чтобы это сделать, вам нужен какой-то адаптер, который совместим с портами вашего компьютера. В этом случае карт-ридер — это адаптер. Другим примером будет блок питания. Вилку с тремя ножками нельзя вставить в розетку с двумя отверстиями. Для того, чтобы она подошла, надо использовать адаптер. Ещё одним примером будет переводчик, переводящий слова одного человека для другого.

**Простыми словами**: Шаблон позволяет обернуть несовместимые объекты в адаптер, чтобы сделать их совместимыми с другим классом.

Обратимся к коду. Представим гипотетичекий миномет, стреляющий обычными минами.
 
```py
class Мина():
    _калибр = 10

class Миномет():
    _калибр = 10

    def Зарядить(self, мина):
        # чтобы влезло, нужно,чтобы калибр совпал
        if self._калибр == мина._калибр:
            return True
        else:
            return False
```

Все было хорошо, но яйцеголовые умники изобрели супер-пупер взрывчатку и новые мины стали размером с карандаш (на вес внимания не обращаем). А на складах минобороны этих минометов как у дурака махорки. Те-же умники быстро родили адаптер для выстрела, чтобы совпадало со старым калибром.

```py
class СуперМина():
    _калибр = 1

# Адаптер, чтобы калибры совпадали
class АдаптерДляСуперМины(Мина):
    ОБМОТАТЬ_ИЗОЛЕНТОЙ = 9
    def __init__(self, супер_мина):
        self._калибр = супер_мина._калибр+self.ОБМОТАТЬ_ИЗОЛЕНТОЙ
```

Способ применения:

```py
мина = Мина()
суперМина = СуперМина()
миномет = Миномет()

if миномет.Зарядить(мина):
    print('обычная мина заряжена')    

if not миномет.Зарядить(суперМина):
    print('гранаты не той системы')    

адаптер = АдаптерДляСуперМины(суперМина)

if миномет.Зарядить(адаптер):
    print('супер-мина заряжена')    
```

### Мост (Bridge)
**Мост** — структурный шаблон проектирования, используемый в проектировании программного обеспечения чтобы разделять абстракцию и реализацию так, чтобы они могли изменяться независимо. Шаблон мост использует инкапсуляцию, агрегирование и может использовать наследование для того, чтобы разделить ответственность между классами.

**Пример из жизни**: Представим, что у вас есть сайт с разными страницами, и вам надо разрешить пользователям менять их тему. Что вы будете делать? Создавать множественные копии каждой страницы для каждой темы или просто отдельную тему, которую пользователь сможет выбрать сам? Шаблон мост позволяет вам сделать второе.

**Простыми словами**: Шаблон мост — это предпочтение композиции над наследованием. Детали реализации передаются из одной иерархии в другой объект с отдельной иерархией.

Обратимся к примеру в коде. Возьмем пример с нашими страницами. У нас есть иерархия ВебСтраничка:

```py
class ВебСтраничка(ABC):
    @abstractmethod
    def __init__(self, тема): pass
    @abstractmethod
    def получитьСодержимое(self): pass

class ОНас(ВебСтраничка):
    _тема=None

    def __init__(self, тема):
        self._тема = тема

    def получитьСодержимое(self):
        return "Страница с информацией в " + self._тема.цвет()

class Новости(ВебСтраничка):
    _тема=None

    def __init__(self, тема):
        self._тема = тема

    def получитьСодержимое(self):
        return "Страница с новостями в " + self._тема.цвет()
```

И отдельная иерархия Тема:

```py
class Тема(ABC):
    @abstractmethod
    def цвет(self): pass

class ТёмнаяТема(Тема):
    def цвет(self):
        return 'темной теме'

class СветлаяТема(Тема):
    def цвет(self):
        return 'светлой теме'
```

Применение в коде:

```py
тёмнаяТема = ТёмнаяТема()
светлаяТема = СветлаяТема()

новости = Новости(тёмнаяТема)
оНас = ОНас(светлаяТема)

print(новости.получитьСодержимое()) # "Страница с новостями в темной теме"
print(оНас.получитьСодержимое()) # "Страница с информацией в светлой теме"
```

### Компоновщик (Composite)
**Компоновщик** — структурный шаблон проектирования, объединяющий объекты в древовидную структуру для представления иерархии от частного к целому. Компоновщик позволяет клиентам обращаться к отдельным объектам и к группам объектов одинаково. Паттерн определяет иерархию классов, которые одновременно могут состоять из примитивных и сложных объектов, упрощает архитектуру клиента, делает процесс добавления новых видов объекта более простым.

**Пример из жизни**: Каждая организация скомпонована из сотрудников. У каждого сотрудника есть одинаковые свойства, такие как зарплата, обязанности, отчётность и т.д.

**Простыми словами**: Шаблон компоновщик позволяет клиентам работать с индивидуальными объектами в едином стиле.

Обратимся к коду. Возьмем наш пример с рабочими. У нас есть Работники разных типов:

```py
from abc import ABC, abstractmethod

class Исполнитель(ABC):
    @abstractmethod
    def можетВыполнить(self, задача)->bool: pass
    @abstractmethod
    def получитьЗадание(self, задача): pass

class Работник(Исполнитель):
    def __init__(self, имя):
        self.имя = имя
    def можетВыполнить(self, задача)->bool:
        return True
    def получитьЗадание(self, задача):
        print('{} получил задачу {}'.format(self.имя, задача))

class Команда(Исполнитель):
    _исполнители=set()

    # вспомогательные методы для управления множеством
    def добавить(self, исполнитель):
        self._исполнители.add(исполнитель)
        return self
    def удалить(self, исполнитель):
        self._исполнители.discard(исполнитель)
        return self

    # методы интерфейса Исполнитель
    def можетВыполнить(self, задача)->bool:
        for исполнитель in self._исполнители:
            if исполнитель.можетВыполнить(задача): return True
        return False
  
    def получитьЗадание(self, задача):
        """может быть разная реализация - 
        допустим, некоторые задания требуют нескольких человек из команды одновременно или работники могут быть заняты...
        в простейшем случае берем первого работника 
        (и удяляем его из команды)"""
        исполнитель = self._исполнители.pop()
        исполнитель.получитьЗадание(задача)
```

Еще у нас есть Начальник:

```py
class Начальник():
    _исполнители = set()
    def __init__(self, исполнители):
        self._исполнители.update(исполнители)
    def датьЗадание(self, задача):
        for исполнитель in  self._исполнители:
            if исполнитель.можетВыполнить(задача):
                исполнитель.получитьЗадание(задача)
                # из команды сами рассосуться
                if type(исполнитель) == Работник:
                    self._исполнители.discard(исполнитель)
                return
        raise Exception('не нашел исполнителя для задачи')
```

Способ применения (в моей реализации работники удаляются, но можно просто добавить флаг занятости, зависящий от задачи):

```py
трус = Работник('трус')
балбес = Работник('балбес')
бывалый = Работник('бывалый')

собутыльники = Команда().добавить(трус).добавить(балбес)

степан_степаныч = Начальник({собутыльники, бывалый})

try:
    степан_степаныч.датьЗадание('вскопать грядку')
    степан_степаныч.датьЗадание('наколоть дров')
    степан_степаныч.датьЗадание('наносить воды')
    степан_степаныч.датьЗадание('написать отчет')
except Exception as e:
    print('что-то случилось: ', e)
```

На выходе получим что-то подобное:

```
балбес получил задачу вскопать грядку
трус получил задачу наколоть дров
бывалый получил задачу наносить воды
что-то случилось:  не нашел исполнителя для задачи    
```

### Декоратор (Decorator)
**Декоратор** — структурный шаблон проектирования, предназначенный для динамического подключения дополнительного поведения к объекту. Шаблон декоратор предоставляет гибкую альтернативу практике создания подклассов с целью расширения функциональности.

Декораторы мы уже достаточно подробно [рассмотрели](/articles/t7l4.md#декораторы) в теме про исключения, вспомним на еще одном примере:

**Пример из жизни** - в современном программировании принято возникающие ошибки выбрасывать исключениями. Но для функций, загружаемых из DLL, действует другое соглашение: функция НЕ должна вызывать исключений, она должна вернуть HRESULT - целое число, если 0, значит функция выполнена успешно, если больше, то результат обозначает код возникшей ошибки. Напишем декоратор для таких функций:


```py
def ошибки_в_исключения(оригинал):
    """
    Функция декоратор, анализирует результат, возвращаемый оригиналом и 
    в случае ошибки выбрасывает исключение с ТЕКСТОМ ошибки
    """
    #словарь документированных ошибок
    словарь_ошибок = {1:'ошибка 1', 2: 'ошибка 2'} 
    def обертка(*args, **kwargs):
        результат = оригинал(*args, **kwargs)
        if результат==0:
            return 0
        elif результат in словарь_ошибок:
            raise Exception(словарь_ошибок[результат])
        else:
            raise Exception('не документированная ошибка, код: {}'.format(результат))

    return обертка

# для декорирования функции достаточно нашу функцию с плюшкой добавить перед описанием декорируемой функции
@ошибки_в_исключения    
def вызов_функции_из_виндовой_библиотеки():
    #тут логика по получению адреса функции, заданию формата параметров и т.п.
    return dll_fun()

#а тут реальный вызов функции и он будет завернут в "обертку"
вызов_функции_из_виндовой_библиотеки()    
```

### Фасад (Facade)
**Фасад** — структурный шаблон проектирования, позволяющий скрыть сложность системы путём сведения всех возможных внешних вызовов к одному объекту, делегирующему их соответствующим объектам системы.

**Пример из жизни**: Как вы включаете компьютер? Нажимаю на кнопку включения, скажете вы. Это то, во что вы верите, потому что вы используете простой интерфейс, который компьютер предоставляет для доступа снаружи. Внутри же должно произойти гораздо больше вещей. Этот простой интерфейс для сложной подсистемы называется фасадом.

**Простыми словами**: Шаблон фасад предоставляет упрощенный интерфейс для сложной системы.

Перейдем к примерам в коде. Возьмем пример с компьютером. Изначально у нас есть класс Компьютер:

```py
class Компьютер():
    def включить220(self):
        print('Ай!')

    def озвучитьРезультатПроверкиPOST(self):
        print('Бип!')

    def показатьЭкранЗагрузки(self):
        print('Загрузка...')

    def готовРаботать(self):
        print('Готов к использованию!')

    def закрытьВсеПрограммы(self):
        print('Кто не спрятался, я не виноват...')

    def завершитьРаботуОперационнойСистемы(self):
        print('Подождите, операционная система выключается...')

    def записатьОзуНаДиск(self):
        print('Усиленно шуршим')

    def спать(self):
        print('Хррр...')
```

Теперь нарисуем к нему кнопки включения и выключения (фасад)

```py
class КнопкаНаМорде():
    def __init__(компьютер)
        self._компьютер = компьютер

    def включить():
        self._компьютер.включить220()
        self._компьютер.озвучитьРезультатПроверкиPOST()
        self._компьютер.показатьЭкранЗагрузки()
        self._компьютер.готовРаботать()

    def гибернация():
        self._компьютер.записатьОзуНаДиск()
        self._компьютер.спать()

    def выключить():
        self._компьютер.закрытьВсеПрограммы()
        self._компьютер.завершитьРаботуОперационнойСистемы(self):
```

Пример использования:

```py
кнопка = КнопкаНаМорде(Компьютер())
кнопка.включить()
#Ай!
#Бип!
#Загрузка...
#Готов к использованию!

кнопка.выключить()
#Кто не спрятался, я не виноват...
#Подождите, операционная система выключается...
```

У системы, кстати, может быть несколько вариантов включения/выключения (простое, сон, гибернация), вариант выключения можно передать параметром в метод кнопка.выключить и в режиме гибернации, например, вызывать другие методы (в классе Компьютер они реализованы).

### Приспособленец (Flyweight)

**Приспособленец** — структурный шаблон проектирования, при котором объект, представляющий себя как уникальный экземпляр в разных местах программы, по факту не является таковым.

**Приспособленец** используется для уменьшения затрат при работе с большим количеством мелких объектов. При проектировании приспособленца необходимо разделить его свойства на внешние и внутренние. Внутренние свойства всегда неизменны, тогда как внешние могут отличаться в зависимости от места и контекста применения и должны быть вынесены за пределы приспособленца.

**Приспособленец** дополняет шаблон Factory Method таким образом, что при обращении клиента к Factory Method для создания нового объекта ищет уже созданный объект с такими же параметрами, что и у требуемого, и возвращает его клиенту. Если такого объекта нет, то фабрика создаст новый.

**Пример из Википедии**: наряжаем ёлку разноцветными лампочками

```py
class Лампочка:
    def __init__(self, цвет):
        self.цвет = цвет

#setdefault - Возвращает значение по ключу, инициализируя элемент словаря, если необходимо, указанным значением.

class ФабрикаЛампочек:
    лампочки = {}
    @classmethod
    def взять_лампочку(cls, цвет):
        return ФабрикаЛампочек.лампочки.setdefault(цвет, Лампочка(цвет))


class Ветка:
    def __init__(self, номер_ветки):
        self.номер_ветки = номер_ветки

    def повесить(self, лампочка):
        print("Повесили {} [{}] лампочку на ветку {} [{}]".format(лампочка.цвет, id(лампочка), self.номер_ветки, id(self)))


class Ёлка(object):
    def __init__(self):
        self.лампочек_повешено = 0
        self.ветки = {}

    def взять_ветку(self, номер):
        return self.ветки.setdefault(номер, Ветка(номер))

    def повесить_лампочку(self, цвет, номер_ветки):
        self.взять_ветку(номер_ветки).повесить(ФабрикаЛампочек.взять_лампочку(цвет))
        self.лампочек_повешено += 1

    def нарядить_ёлку(self):
        self.повесить_лампочку('red', 1)
        self.повесить_лампочку('blue', 1)
        self.повесить_лампочку('yellow', 1)
        self.повесить_лампочку('red', 2)
        self.повесить_лампочку('blue', 2)
        self.повесить_лампочку('yellow', 2)
        self.повесить_лампочку('red', 3)
        self.повесить_лампочку('blue', 3)
        self.повесить_лампочку('yellow', 3)
        self.повесить_лампочку('red', 4)
        self.повесить_лампочку('blue', 4)
        self.повесить_лампочку('yellow', 4)
        self.повесить_лампочку('red', 5)
        self.повесить_лампочку('blue', 5)
        self.повесить_лампочку('yellow', 5)
        self.повесить_лампочку('red', 6)
        self.повесить_лампочку('blue', 6)
        self.повесить_лампочку('yellow', 6)
        self.повесить_лампочку('red', 7)
        self.повесить_лампочку('blue', 7)
        self.повесить_лампочку('yellow', 7)

if __name__ == '__main__':
    Ёлка().нарядить_ёлку()
```

В консоли получим примерно такое:

```
Повесили red [78852560] лампочку на ветку 1 [78852624]
Повесили blue [78852944] лампочку на ветку 1 [78852624]
Повесили yellow [78855760] лампочку на ветку 1 [78852624]
Повесили red [78852560] лампочку на ветку 2 [78853584]
Повесили blue [78852944] лампочку на ветку 2 [78853584]
Повесили yellow [78855760] лампочку на ветку 2 [78853584]
Повесили red [78852560] лампочку на ветку 3 [78855984]
Повесили blue [78852944] лампочку на ветку 3 [78855984]
Повесили yellow [78855760] лампочку на ветку 3 [78855984]
Повесили red [78852560] лампочку на ветку 4 [78855792]
Повесили blue [78852944] лампочку на ветку 4 [78855792]
Повесили yellow [78855760] лампочку на ветку 4 [78855792]
Повесили red [78852560] лампочку на ветку 5 [78853648]
Повесили blue [78852944] лампочку на ветку 5 [78853648]
Повесили yellow [78855760] лампочку на ветку 5 [78853648]
Повесили red [78852560] лампочку на ветку 6 [78856016]
Повесили blue [78852944] лампочку на ветку 6 [78856016]
Повесили yellow [78855760] лампочку на ветку 6 [78856016]
Повесили red [78852560] лампочку на ветку 7 [78856144]
Повесили blue [78852944] лампочку на ветку 7 [78856144]
Повесили yellow [78855760] лампочку на ветку 7 [78856144]
```

Лампочка каждого цвета всего в одном экземпляре и одновременно висит на всех ветках.

### Заместитель (Proxy)

**Заместитель** — структурный шаблон проектирования, который предоставляет объект, который контролирует доступ к другому объекту, перехватывая все вызовы (выполняет функцию контейнера).

**Пример из жизни**: Вы когда-нибудь использовали карту доступа, чтобы пройти через дверь? Есть несколько способов открыть дверь: например, она может быть открыта при помощи карты доступа или нажатия кнопки, которая обходит защиту. Основная функциональность двери — это открытие, но заместитель, добавленный поверх этого, добавляет функциональность. Но лучше я объясню это на примере кода чуть ниже.

**Простыми словами**: Используя шаблон заместитель, класс отображает функциональность другого класса.

Перейдем к коду. Возьмем наш пример с безопасностью. Сначала у нас есть интерфейс Дверь и его реализация:

```py
from abc import ABC, abstractmethod

class Дверь(ABC):
    @abstractmethod
    def открыть(self): pass
    @abstractmethod
    def закрыть(self): pass

class ДверьЛаборатории(Дверь):
    def открыть(self):
        print("Открытие двери лаборатории")

    def закрыть(self):
        print("Закрытие двери лаборатории")

# Затем у нас есть заместитель Безопасность для защиты любых наших дверей:

class Безопасность:
    def __init__(self, дверь: Дверь):
        self._дверь = дверь

    def открыть(self, пароль):
        if self.проверить(пароль):
            self._дверь.открыть()
        else:
            print("Нет! Это невозможно.")

    def проверить(self, пароль: str):
        return пароль == '$ecr@t'

    def закрыть(self):
        self._дверь.закрыть()

# Пример использования:

дверь = Безопасность(ДверьЛаборатории())
дверь.открыть('invalid') # Нет! Это невозможно.

дверь.открыть('$ecr@t') # Открытие двери лаборатории
дверь.закрыть() # Закрытие двери лаборатории
```

## Поведенческие шаблоны
Поведенческие шаблоны связаны с распределением обязанностей между объектами. Их отличие от структурных шаблонов заключается в том, что они не просто описывают структуру, но также описывают шаблоны для передачи сообщений / связи между ними. Или, другими словами, они помогают ответить на вопрос «Как запустить поведение в программном компоненте?»

**Поведенческие шаблоны** — шаблоны проектирования, определяющие алгоритмы и способы реализации взаимодействия различных объектов и классов.

### Цепочка обязанностей (Chain of Responsibility)
**Цепочка обязанностей** — поведенческий шаблон проектирования предназначенный для организации в системе уровней ответственности.

**Пример из жизни**: например, у вас есть три платежных метода (A, B и C), настроенных на вашем банковском счёте. На каждом лежит разное количество денег. На A есть 100 рублей, на B есть 300 рублей и на C — 1000 рублей. Предпочтение отдается в следующем порядке: A, B и C. Вы пытаетесь заказать что-то, что стоит 210 долларов. Используя цепочку обязанностей, первым на возможность оплаты будет проверен метод А, и в случае успеха пройдет оплата и цепь разорвется. Если нет, то запрос перейдет к методу B для аналогичной проверки. Здесь A, B и C — это звенья цепи, а все явление — цепочка обязанностей.

**Простыми словами**: цепочка обязанностей помогает строить цепочки объектов. Запрос входит с одного конца и проходит через каждый объект, пока не найдет подходящий обработчик.

Обратимся к коду. Приведем пример с банковскими счетами. Изначально у нас есть базовый Счёт с логикой для соединения счетов цепью и некоторые счета:

```py
class Счёт:
    _преемник = None
    _баланс = 0

    def следующий(self, счёт):
        self._преемник = счёт

    def оплатить(self, сумма):
        if self.могу_оплатить(сумма):
            print('Оплата {}, используя {}'.format(сумма, type(self).__name__)
        elif self._преемник:
            print('Нельзя заплатить, используя {}. Обработка ..'.format(type(self).__name__))
            self._преемник.оплатить(сумма)
        else:
            raise Exception('Ни на одном из счетов нет необходимого количества денег')

    def могу_оплатить(self, сумма)->bool:
        return self._баланс >= сумма

class Банк(Счёт):
    _баланс = 0

    def __init__(self, баланс):
        self._баланс = баланс

class Paypal(Счёт):
    _баланс = 0

    def __init__(self, баланс):
        self._баланс = баланс

class Bitcoin(Счёт):
    _баланс = 0

    def __init__(self, баланс):
        self._баланс = баланс

"""
Теперь приготовим цепь, используя объявленные выше звенья
Первый по приоритету банк
      Если нельзя через банк, то Paypal
      Если нельзя через Paypal, то Bitcoin
"""

банк = Банк(100)          # Банк с балансом 100
paypal = Paypal(200)      # Paypal с балансом 200
bitcoin = Bitcoin(300)    # Bitcoin с балансом 300

банк.следующий(paypal)
paypal.следующий(bitcoin)

# Попробуем оплатить через банк
банк.оплатить(259)
```

```
Нельзя заплатить, используя Банк. Обработка ..
Нельзя заплатить, используя Paypal. Обработка ..:
Оплата 259, используя Bitcoin!
```

### Команда (Command)
**Команда** — поведенческий шаблон проектирования, используемый при объектно-ориентированном программировании, представляющий действие. Объект команды заключает в себе само действие и его параметры.

**Пример из жизни**: Типичный пример: вы заказываете еду в ресторане. Вы (т.е. Client) просите официанта (например, Invoker) принести еду (то есть Command), а официант просто переправляет запрос шеф-повару (то есть Receiver), который знает, что и как готовить. Другим примером может быть то, что вы (Client) включаете (Command) телевизор (Receiver) с помощью пульта дистанционного управления (Invoker).

**Простыми словами**: Позволяет вам инкапсулировать действия в объекты. Основная идея, стоящая за шаблоном — это предоставление средств, для разделения клиента и получателя.

Обратимся к коду. Изначально у нас есть получатель Bulb, в котором есть реализация каждого действия, которое может быть выполнено:

```py
from abc import ABC, abstractmethod

class Лампочка:
    def включить(self):
        print("Лампочка загорелась")

    def выключить(self):
        print("Темнота!")

# Затем у нас есть интерфейс Команда, который каждая команда должна реализовывать, и затем у нас будет набор команд:

class Команда(ABC):
    @abstractmethod
    def выполнить(self): pass
    @abstractmethod
    def отменить(self): pass
    @abstractmethod
    def переделать(self): pass

class Включить(Команда):
    def __init__(self, лампочка: Лампочка):
        self._лампочка = лампочка

    def выполнить(self):
        self._лампочка.включить()

    def отменить(self):
        self._лампочка.выключить()

    def переделать(self):
        self.выполнить()

class Выключить(Команда):
    def __init__(self, лампочка: Лампочка):
        self._лампочка = лампочка

    def выполнить(self):
        self._лампочка.выключить()

    def отменить(self):
        self._лампочка.включить()

    def переделать(self):
        self.выполнить()

# Затем у нас есть Пульт, с которым клиент будет взаимодействовать для обработки любых команд:

class Пульт:
    def нажать(self, команда: Команда):
        команда.выполнить()

#Наконец, мы можем увидеть, как использовать нашего клиента:

лампочка = Лампочка()

выключатель = Выключить(лампочка)
включатель = Включить(лампочка)

пульт = Пульт()
пульт.нажать(включатель)   # Лампочка загорелась!
пульт.нажать(выключатель)  # Темнота!
```

Шаблон **команда** может быть использован для реализации системы, основанной на транзакциях, где вы сохраняете историю команд, как только их выполняете. Если окончательная команда успешно выполнена, то все хорошо, иначе алгоритм просто перебирает историю и продолжает выполнять отмену для всех выполненных команд.



### Итератор
**Итератор** — поведенческий шаблон проектирования. Представляет собой объект, позволяющий получить последовательный доступ к элементам объекта-агрегата без использования описаний каждого из агрегированных объектов.

Итераторы встроены в Python. Это одна из самых мощных возможностей языка. Во многом именно итераторы делают его таким удобным. Чтобы разобраться в паттерне Итератор, следует просто изучить механизм работы итераторов и генераторов языка.



### Посредник (Mediator)
**Посредник** — поведенческий шаблон проектирования, обеспечивающий взаимодействие множества объектов, формируя при этом слабую связанность, и избавляя объекты, от необходимости явно ссылаться друг на друга.

**Пример из жизни**: Общим примером будет, когда вы говорите с кем-то по мобильнику, то между вами и собеседником находится мобильный оператор. То есть сигнал передаётся через него, а не напрямую. В данном примере оператор — посредник.

**Простыми словами**: Шаблон посредник подразумевает добавление стороннего объекта (посредника) для управления взаимодействием между двумя объектами (коллегами). Шаблон помогает уменьшить связанность (coupling) классов, общающихся друг с другом, ведь теперь они не должны знать о реализациях своих собеседников.

Разберем пример в коде. Простейший пример: чат (посредник), в котором пользователи (коллеги) отправляют друг другу сообщения.

Изначально у нас есть посредник ChatRoomMediator:

interface ChatRoomMediator 
{
    public function showMessage(User $user, string $message);
}

// Посредник
class ChatRoom implements ChatRoomMediator
{
    public function showMessage(User $user, string $message)
    {
        $time = date('M d, y H:i');
        $sender = $user->getName();

        echo $time . '[' . $sender . ']:' . $message;
    }
}
Затем у нас есть наши User (коллеги):

class User {
    protected $name;
    protected $chatMediator;

    public function __construct(string $name, ChatRoomMediator $chatMediator) {
        $this->name = $name;
        $this->chatMediator = $chatMediator;
    }

    public function getName() {
        return $this->name;
    }

    public function send($message) {
        $this->chatMediator->showMessage($this, $message);
    }
}
Пример использования:

$mediator = new ChatRoom();

$john = new User('John Doe', $mediator);
$jane = new User('Jane Doe', $mediator);

$john->send('Привет!');
$jane->send('Привет!');

// Вывод
// Feb 14, 10:58 [John]: Привет!
// Feb 14, 10:58 [Jane]: Привет!

Примеры на Java и Python.

Хранитель (Memento)
Википедия гласит:

Хранитель — поведенческий шаблон проектирования, позволяющий, не нарушая инкапсуляцию, зафиксировать и сохранить внутреннее состояние объекта так, чтобы позднее восстановить его в этом состоянии.

Пример из жизни: В качестве примера можно привести калькулятор (создатель), у которого любая последняя выполненная операция сохраняется в памяти (хранитель), чтобы вы могли снова вызвать её с помощью каких-то кнопок (опекун).

Простыми словами: Шаблон хранитель фиксирует и хранит текущее состояние объекта, чтобы оно легко восстанавливалось.

Обратимся к коду. Возьмем наш пример текстового редактора, который время от времени сохраняет состояние, которое вы можете восстановить.

Изначально у нас есть наш объект EditorMemento, который может содержать состояние редактора:

class EditorMemento
{
    protected $content;

    public function __construct(string $content)
    {
        $this->content = $content;
    }

    public function getContent()
    {
        return $this->content;
    }
}
Затем у нас есть наш Editor (создатель), который будет использовать объект хранитель:

class Editor
{
    protected $content = '';

    public function type(string $words)
    {
        $this->content = $this->content . ' ' . $words;
    }

    public function getContent()
    {
        return $this->content;
    }

    public function save()
    {
        return new EditorMemento($this->content);
    }

    public function restore(EditorMemento $memento)
    {
        $this->content = $memento->getContent();
    }
}
Пример использования:

$editor = new Editor();

// Печатаем что-нибудь
$editor->type('Это первое предложение.');
$editor->type('Это второе.');

// Сохраняем состояние для восстановления : Это первое предложение. Это второе.
$saved = $editor->save();

// Печатаем ещё
$editor->type('И это третье.');

// Вывод: Данные до сохранения
echo $editor->getContent(); // Это первое предложение. Это второе. И это третье.

// Восстановление последнего сохранения
$editor->restore($saved);

$editor->getContent(); // Это первое предложение. Это второе.

Примеры на Java и Python.

Наблюдатель (Observer)
Википедия гласит:

Наблюдатель — поведенческий шаблон проектирования, также известен как «подчинённые» (Dependents). Создает механизм у класса, который позволяет получать экземпляру объекта этого класса оповещения от других объектов об изменении их состояния, тем самым наблюдая за ними.

Пример из жизни: Хороший пример: люди, ищущие работу, подписываются на публикации на сайтах вакансий и получают уведомления, когда появляются вакансии подходящие по параметрам.

Простыми словами: Шаблон определяет зависимость между объектами, чтобы при изменении состояния одного из них зависимые от него узнавали об этом.

Обратимся к коду. Приводя наш пример. Изначально у нас есть JobSeeker, которые ищут работы JobPost и должны быть уведомлены о её появлении:

class JobPost
{
    protected $title;

    public function __construct(string $title)
    {
        $this->title = $title;
    }

    public function getTitle()
    {
        return $this->title;
    }
}

class JobSeeker implements Observer
{
    protected $name;

    public function __construct(string $name)
    {
        $this->name = $name;
    }

    public function onJobPosted(JobPost $job)
    {
        // Делаем что-то с публикациями вакансий
        echo 'Привет ' . $this->name . '! Появилась новая работа: '. $job->getTitle();
    }
}
Затем мы делаем публикации JobPostings на которые соискатели могут подписываться:

class JobPostings implements Observable
{
    protected $observers = [];

    protected function notify(JobPost $jobPosting)
    {
        foreach ($this->observers as $observer) {
            $observer->onJobPosted($jobPosting);
        }
    }

    public function attach(Observer $observer)
    {
        $this->observers[] = $observer;
    }

    public function addJob(JobPost $jobPosting)
    {
        $this->notify($jobPosting);
    }
}
Пример использования:

// Создаем соискателей
$johnDoe = new JobSeeker('John Doe');
$janeDoe = new JobSeeker('Jane Doe');

// Создаем публикацию и добавляем подписчика
$jobPostings = new JobPostings();
$jobPostings->attach($johnDoe);
$jobPostings->attach($janeDoe);

// Добавляем новую работу и смотрим получит ли соискатель уведомление
$jobPostings->addJob(new JobPost('Software Engineer'));

// Вывод
// Привет John Doe! Появилась новая работа: Software Engineer
// Привет Jane Doe! Появилась новая работа: Software Engineer

Примеры на Java и Python.

Посетитель (Visitor)
Википедия гласит:

Посетитель — поведенческий шаблон проектирования, описывающий операцию, которая выполняется над объектами других классов. При изменении visitor нет необходимости изменять обслуживаемые классы.

Пример из жизни: Туристы собрались в Дубай. Сначала им нужен способ попасть туда (виза). После прибытия они будут посещать любую часть города, не спрашивая разрешения ходить где вздумается. Просто скажите им о каком-нибудь месте — и туристы могут там побывать. Шаблон посетитель помогает добавлять места для посещения.

Простыми словами: Шаблон посетитель позволяет добавлять будущие операции для объектов без их модифицирования.

Перейдем к примерам в коде. Возьмём зоопарк: у нас есть несколько видов Animal, и нам нужно послушать издаваемые ими звуки.

// Посещаемый
interface Animal
{
    public function accept(AnimalOperation $operation);
}

// Посетитель
interface AnimalOperation
{
    public function visitMonkey(Monkey $monkey);
    public function visitLion(Lion $lion);
    public function visitDolphin(Dolphin $dolphin);
}
Затем у нас есть реализация для животных:

class Monkey implements Animal
{
    public function shout()
    {
        echo 'У-у-а-а!';
    }

    public function accept(AnimalOperation $operation)
    {
        $operation->visitMonkey($this);
    }
}

class Lion implements Animal
{
    public function roar()
    {
        echo 'рррр!';
    }

    public function accept(AnimalOperation $operation)
    {
        $operation->visitLion($this);
    }
}

class Dolphin implements Animal
{
    public function speak()
    {
        echo '*звуки дельфина*!'; // Я понятия не имею как описать их звуки
    }

    public function accept(AnimalOperation $operation)
    {
        $operation->visitDolphin($this);
    }
}
Давайте реализуем посетителя:

class Speak implements AnimalOperation
{
    public function visitMonkey(Monkey $monkey)
    {
        $monkey->shout();
    }

    public function visitLion(Lion $lion)
    {
        $lion->roar();
    }

    public function visitDolphin(Dolphin $dolphin)
    {
        $dolphin->speak();
    }
}
Пример использования:

$monkey = new Monkey();
$lion = new Lion();
$dolphin = new Dolphin();

$speak = new Speak();

$monkey->accept($speak);    // У-у-а-а!    
$lion->accept($speak);      // Рррр!
$dolphin->accept($speak);   // *звуки дельфина*!
Это можно было сделать просто с помощью иерархии наследования, но тогда пришлось бы модифицировать животных при каждом добавлении к ним новых действий. А здесь менять их не нужно. Например, мы можем добавить животным прыжки, просто создав нового посетителя:

class Jump implements AnimalOperation
{
    public function visitMonkey(Monkey $monkey)
    {
        echo 'Прыгает на 20 футов!';
    }

    public function visitLion(Lion $lion)
    {
        echo 'Прыгает на 7 футов!';
    }

    public function visitDolphin(Dolphin $dolphin)
    {
        echo 'Появился над водой и исчез!';
    }
}
Пример использования:

$jump = new Jump();

$monkey->accept($speak);   // У-у-а-а!
$monkey->accept($jump);    // Прыгает на 20 футов!

$lion->accept($speak);     // Рррр!
$lion->accept($jump);      // Прыгает на 7 футов!

$dolphin->accept($speak);  // *звуки дельфинов*!
$dolphin->accept($jump);   // Появился над водой и исчез

Примеры на Java и Python.

Стратегия (Strategy)
Википедия гласит:

Стратегия — поведенческий шаблон проектирования, предназначенный для определения семейства алгоритмов, инкапсуляции каждого из них и обеспечения их взаимозаменяемости. Это позволяет выбирать алгоритм путём определения соответствующего класса. Шаблон Strategy позволяет менять выбранный алгоритм независимо от объектов-клиентов, которые его используют.

Пример из жизни: Возьмём пример с пузырьковой сортировкой. Мы её реализовали, но с ростом объёмов данных сортировка работа стала выполняться очень медленно. Тогда мы сделали быструю сортировку. Алгоритм работает быстрее на больших объёмах, но на маленьких он очень медленный. Тогда мы реализовали стратегию, при которой для маленьких объёмов данных используется пузырьковая сортировка, а для больших объёмов — быстрая.

Простыми словами: Шаблон стратегия позволяет переключаться между алгоритмами или стратегиями в зависимости от ситуации.

Перейдем к коду. Возьмем наш пример. Изначально у нас есть наша SortStrategy и разные её реализации:

interface SortStrategy
{
    public function sort(array $dataset): array;
}

class BubbleSortStrategy implements SortStrategy
{
    public function sort(array $dataset): array
    {
        echo "Сортировка пузырьком";

        // Сортировка
        return $dataset;
    }
}

class QuickSortStrategy implements SortStrategy
{
    public function sort(array $dataset): array
    {
        echo "Быстрая сортировка";

        // Сортировка
        return $dataset;
    }
}
И у нас есть Sorter, который собирается использовать какую-то стратегию:

class Sorter
{
    protected $sorter;

    public function __construct(SortStrategy $sorter)
    {
        $this->sorter = $sorter;
    }

    public function sort(array $dataset): array
    {
        return $this->sorter->sort($dataset);
    }
}
Пример использования:

$dataset = [1, 5, 4, 3, 2, 8];

$sorter = new Sorter(new BubbleSortStrategy());
$sorter->sort($dataset); // Вывод : Сортировка пузырьком

$sorter = new Sorter(new QuickSortStrategy());
$sorter->sort($dataset); // Вывод : Быстрая сортировка

Примеры на Java и Python.

Состояние (State)
Википедия гласит:

Состояние — поведенческий шаблон проектирования. Используется в тех случаях, когда во время выполнения программы объект должен менять своё поведение в зависимости от своего состояния.

Пример из жизни: Допустим, в графическом редакторе вы выбрали кисть. Она меняет своё поведение в зависимости от настройки цвета, т. е. рисует линию выбранного цвета.

Простыми словами: Шаблон позволяет менять поведение класса при изменении состояния.

Перейдем к примерам в коде. Возьмем пример текстового редактора, он позволяет вам менять состояние напечатанного текста. Например, если у вас выбран курсив, то он будет писать курсивом и так далее.

Изначально у нас есть интерфейс WritingState и несколько его реализаций:

interface WritingState
{
    public function write(string $words);
}

class UpperCase implements WritingState
{
    public function write(string $words)
    {
        echo strtoupper($words);
    }
}

class LowerCase implements WritingState
{
    public function write(string $words)
    {
        echo strtolower($words);
    }
}

class Default implements WritingState
{
    public function write(string $words)
    {
        echo $words;
    }
}
Затем TextEditor:

class TextEditor
{
    protected $state;

    public function __construct(WritingState $state)
    {
        $this->state = $state;
    }

    public function setState(WritingState $state)
    {
        $this->state = $state;
    }

    public function type(string $words)
    {
        $this->state->write($words);
    }
}
Пример использования:

$editor = new TextEditor(new Default());

$editor->type('Первая строка');

$editor->setState(new UpperCase());

$editor->type('Вторая строка');
$editor->type('Третья строка');

$editor->setState(new LowerCase());

$editor->type('Четвертая строка');
$editor->type('Пятая строка');

// Output:
// Первая строка
// ВТОРАЯ СТРОКА
// ТРЕТЬЯ СТРОКА
// четвертая строка
// пятая строка

Примеры на Java и Python.

Шаблонный метод (Template Method)
Википедия гласит:

Шаблонный метод — поведенческий шаблон проектирования, определяющий основу алгоритма и позволяющий наследникам переопределять некоторые шаги алгоритма, не изменяя его структуру в целом.

Пример из жизни: Допустим, вы собрались строить дома. Этапы будут такими:

Подготовка фундамента.
Возведение стен.
Настил крыши.
Настил перекрытий.
Порядок этапов никогда не меняется. Вы не настелите крышу до возведения стен и т. д. Но каждый этап модифицируется: стены, например, можно возвести из дерева, кирпича или газобетона.

Простыми словами: Шаблонный метод определяет каркас выполнения определённого алгоритма, но реализацию самих этапов делегирует дочерним классам.

Обратимся к коду. Допустим, у нас есть программный инструмент, позволяющий тестировать, проводить контроль качества кода, выполнять сборку, генерировать отчёты сборки (отчёты о покрытии кода, о качестве кода и т. д.), а также развёртывать приложение на тестовом сервере.

Изначально у нас есть наш Builder, который описывает скелет для построения алгоритма:

abstract class Builder
{

    // Шаблонный метод
    final public function build()
    {
        $this->test();
        $this->lint();
        $this->assemble();
        $this->deploy();
    }

    abstract public function test();
    abstract public function lint();
    abstract public function assemble();
    abstract public function deploy();
}
Затем у нас есть его реализации:

class AndroidBuilder extends Builder
{
    public function test()
    {
        echo 'Запуск Android тестов';
    }

    public function lint()
    {
        echo 'Копирование Android кода';
    }

    public function assemble()
    {
        echo 'Android сборка';
    }

    public function deploy()
    {
        echo 'Развертывание сборки на сервере';
    }
}

class IosBuilder extends Builder
{
    public function test()
    {
        echo 'Запуск iOS тестов';
    }

    public function lint()
    {
        echo 'Копирование iOS кода';
    }

    public function assemble()
    {
        echo 'iOS сборка';
    }

    public function deploy()
    {
        echo 'Развертывание сборки на сервере';
    }
}
Пример использования:

$androidBuilder = new AndroidBuilder();
$androidBuilder->build();

// Вывод:
// Запуск Android тестов
// Копирование Android кода
// Android сборка
// Развертывание сборки на сервере

$iosBuilder = new IosBuilder();
$iosBuilder->build();

// Вывод:
// Запуск iOS тестов
// Копирование iOS кода
// iOS сборка
// Развертывание сборки на сервере

[содержание](/readme.md)  

